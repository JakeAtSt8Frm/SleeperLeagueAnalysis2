<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sleeper League Analytics</title>

  <!-- Chart.js 3.x for broader browser compatibility -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            sleeper: {
              teal: '#10b981',
              boom: '#22c55e',
              bust: '#ef4444',
              mid:  '#3b82f6',
              majorBoom: '#d303fc',
              majorBust: '#f97316'
            },
            madden: {
              gold: '#FFD700',
              goldDark: '#C9A227',
              red: '#E31837'
            },
            myteam: {
              bronze: '#CD7F32',
              silver: '#C0C0C0',
              gold: '#FFD700',
              sapphire: '#0F52BA',
              ruby: '#E0115F',
              amethyst: '#9966CC',
              diamond: '#B9F2FF',
              pinkdiamond: '#FF69B4',
              darkmatter: '#1a0033',
              goat: '#FFD700'
            }
          }
        }
      }
    }
  </script>

  <style>
    /* Custom Scrollbar */
    ::-webkit-scrollbar{width:6px;height:6px}
    ::-webkit-scrollbar-track{background:transparent}
    ::-webkit-scrollbar-thumb{background:#3f4451;border-radius:6px}
    ::-webkit-scrollbar-thumb:hover{background:#10b981}

    /* Utility Classes */
    .line-clamp-2{display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
    .glow-majorBoom{box-shadow:0 0 6px rgba(211,3,252,.4)}
    .glow-majorBust{box-shadow:0 0 6px rgba(249,115,22,.4)}
    .bb-pill{display:inline-block;white-space:nowrap;min-width:84px;text-align:center;font-size:9px;line-height:1.1;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;padding:0.25rem 0.625rem;border-radius:0.5rem}

    /* Sidebar Active States */
    .nav-btn-active {
      background: linear-gradient(135deg, rgba(16,185,129,0.15) 0%, rgba(16,185,129,0.05) 100%) !important;
      color: #10b981 !important;
      border: 1px solid rgba(16,185,129,0.3);
      box-shadow: none;
    }
    
    /* Card Hover */
    .card-hover:hover {
      border-color: rgba(16,185,129,0.3);
    }
    
    /* Backgrounds */
    .bg-card {
      background: var(--surface-2);
    }

    .player-card {
      background: var(--surface-2);
      border: 1px solid var(--border);
    }
    .player-card:hover {
      border-color: rgba(16,185,129,0.3);
    }

    /* Card grid */
    .ui2k-card-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 10px;
      align-items: start;
      justify-items: center;
      width: 100%;
      max-width: calc(3 * 520px + 2 * 10px);
      margin-inline: auto;
    }
    @media (max-width: 520px){
      .ui2k-card-grid{
        grid-template-columns: 1fr;
        max-width: 100%;
      }
      .player-card{
        min-width: 0 !important;
        width: 100% !important;
      }
    }

    .stat-chip {
      background: var(--surface-3);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.3rem 0.5rem;
    }
    
    /* Table row hover */
    .table-row-hover:hover {
      background: rgba(255,255,255,0.02);
    }
    
    /* Focus states */
    button:focus, select:focus, input:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(16,185,129,0.3);
    }
    
    /* Select dropdown styling */
    select option {
      background: #111827;
      color: white;
    }

  
    /* ===========================
       UI2K (Modern 2K-like Theme)
       =========================== */

    /* Charts containers */
    canvas{ }

    /* Tables */
    table{ border-collapse:separate; border-spacing:0; }
    tr:hover td{ background: rgba(255,255,255,.02); }

    /* ===========================
       CLEAN MODERN THEME
       =========================== */
    :root{
      --accent: #10b981;
      --accent-dim: rgba(16,185,129,0.15);
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --surface-1: #0f1012;
      --surface-2: #16181c;
      --surface-3: #1e2025;
      --border: rgba(255,255,255,0.06);
    }

    /* Scrollbar */
    ::-webkit-scrollbar-thumb{background:rgba(100,116,139,0.3);border-radius:3px}
    ::-webkit-scrollbar-thumb:hover{background:rgba(100,116,139,0.5)}

    /* Body */
    body.ui2k{
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--surface-1);
    }

    /* Header */
    header.ui2k-header{
      background: var(--surface-2);
      border-bottom: 1px solid var(--border);
    }

    header.ui2k-header::before{ display:none; }
    header.ui2k-header::after{ display:none; }

    /* Logo */
    .madden-logo{
      background: var(--accent) !important;
      border: none !important;
      color: #fff !important;
      font-weight: 700;
    }

    /* Title */
    #hdrLeague{
      color: var(--text-primary);
      font-weight: 600;
      background: none;
      -webkit-text-fill-color: unset;
    }

    #hdrMeta{
      color: var(--text-muted) !important;
      font-family: inherit;
      letter-spacing: 0;
      text-transform: uppercase;
      opacity: 0.8;
    }

    /* Sidebar */
    aside.ui2k-sidebar{
      background: var(--surface-2);
      border-right: 1px solid var(--border);
    }

    aside.ui2k-sidebar::before{ display:none; }

    /* Nav Buttons */
    .ui2k-navbtn{
      background: transparent !important;
      border: 1px solid transparent !important;
      font-family: inherit;
      font-weight: 500;
      font-size: 9px;
      color: var(--text-muted);
    }

    .ui2k-navbtn:hover{
      color: var(--text-primary) !important;
      background: var(--surface-3) !important;
    }

    /* Active Nav Button */
    .nav-btn-active{
      background: var(--accent-dim) !important;
      color: var(--accent) !important;
      border: 1px solid transparent !important;
      font-weight: 600;
    }

    .nav-btn-active::after{ display:none; }

    /* Panels */
    .ui2k-panel{
      background: var(--surface-2) !important;
      border: 1px solid var(--border) !important;
    }

    .ui2k-panel::before{ display:none; }

    /* Tabs */
    .madden-tab{
      font-family: inherit !important;
      font-weight: 500;
      text-transform: none;
      letter-spacing: 0;
      background: var(--surface-3);
      border: 1px solid var(--border);
      color: var(--text-secondary);
    }

    .madden-tab:hover{
      color: var(--text-primary);
    }

    .madden-tab-active, .bg-accent{
      background: var(--accent-dim) !important;
      color: var(--accent) !important;
      border: 1px solid rgba(16,185,129,0.3) !important;
    }

    /* Section Headers */
    .text-2xl.font-bold.text-white{
      font-family: inherit !important;
      font-weight: 600;
      letter-spacing: 0;
      text-transform: none;
      color: var(--text-primary);
      font-size: 1.5rem !important;
    }

    /* Dividers */
    .madden-divider{
      background: var(--border);
      height:1px;
    }

    /* Selects */
    select{
      font-family: inherit;
      font-weight: 500;
    }

    /* Progress Bar */
    #hdrProgress{
      background: var(--accent) !important;
    }

    /* Roster grid - max 2 columns */
    .ui2k-card-grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(420px, 1fr));
      gap: 10px;
      align-items: start;
      justify-items: center;
      width: 100%;
      max-width: calc(2 * 540px + 10px);
      margin-inline: auto;
    }
    @media (max-width: 960px){
      .ui2k-card-grid{
        grid-template-columns: 1fr;
        max-width: 100%;
      }
      .player-card{
        min-width: 0 !important;
        width: 100% !important;
      }
    }

    /* Status bar on left of panel headers */
    .madden-status-bar{
      width:3px;
      background: var(--accent);
      border-radius:2px;
    }

    /* Accent colors for text */
    .text-accent{
      color: var(--accent) !important;
    }

    /* ===========================
       GEM TIER BADGES (Simplified)
       =========================== */
    .myteam-badge {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 11px;
      font-weight: 600;
    }

    .myteam-tier {
      font-size: 9px;
      opacity: 0.8;
    }

    /* Bronze */
    .myteam-badge-bronze {
      background: #92400e;
      color: #fef3c7;
    }

    /* Silver */
    .myteam-badge-silver {
      background: #6b7280;
      color: #f9fafb;
    }

    /* Gold */
    .myteam-badge-gold {
      background: #b45309;
      color: #fef3c7;
    }

    /* Sapphire */
    .myteam-badge-sapphire {
      background: #1d4ed8;
      color: #dbeafe;
    }

    /* Ruby */
    .myteam-badge-ruby {
      background: #be123c;
      color: #fce7f3;
    }

    /* Amethyst */
    .myteam-badge-amethyst {
      background: #7c3aed;
      color: #ede9fe;
    }

    /* Diamond */
    .myteam-badge-diamond {
      background: #0891b2;
      color: #ecfeff;
    }

    /* Pink Diamond */
    .myteam-badge-pinkdiamond {
      background: #db2777;
      color: #fce7f3;
    }

    /* Dark Matter */
    .myteam-badge-darkmatter {
      background: #581c87;
      color: #f3e8ff;
    }

    /* G.O.A.T */
    .myteam-badge-goat {
      background: linear-gradient(135deg, #b45309 0%, #d97706 50%, #b45309 100%);
      color: #fef3c7;
      font-weight: 700;
    }

    /* Card tier borders - subtle colored left border */
    .player-card.tier-bronze { border-left: 3px solid #92400e; }
    .player-card.tier-silver { border-left: 3px solid #6b7280; }
    .player-card.tier-gold { border-left: 3px solid #b45309; }
    .player-card.tier-sapphire { border-left: 3px solid #1d4ed8; }
    .player-card.tier-ruby { border-left: 3px solid #be123c; }
    .player-card.tier-amethyst { border-left: 3px solid #7c3aed; }
    .player-card.tier-diamond { border-left: 3px solid #0891b2; }
    .player-card.tier-pinkdiamond { border-left: 3px solid #db2777; }
    .player-card.tier-darkmatter { border-left: 3px solid #581c87; }
    .player-card.tier-goat { border-left: 3px solid #d97706; }

</style>
</head>

<body class="bg-gray-950 text-gray-200 h-screen overflow-hidden ui2k">
  <!-- Header -->
  <header class="h-14 border-b border-gray-800/50 flex items-center justify-between px-3.5 shrink-0 ui2k-header">
    <div class="flex items-center gap-7">
      <div class="w-14 h-9 rounded-lg flex items-center justify-center text-white font-bold text-sm madden-logo">SLA</div>
      <div>
        <div class="text-white font-semibold leading-tight text-base" id="hdrLeague">Sleeper League</div>
        <div class="text-xs text-gray-500" id="hdrMeta">Season ‚Äî | Week ‚Äî</div>
      </div>
    </div>
    <div class="flex items-center gap-4">
      <div class="flex items-center gap-2 rounded px-2 py-1">
        <span class="text-xs text-gray-500">Season</span>
        <select id="seasonSelect" class="bg-transparent border-none text-sm text-gray-300 font-medium focus:outline-none cursor-pointer">
          <option value="2024" class="bg-gray-900">2024</option>
          <option value="2025" class="bg-gray-900">2025</option>
          <option value="2026" class="bg-gray-900">2026</option>
        </select>
      </div>
      <div class="flex items-center gap-3">
        <div class="text-xs text-gray-400" id="hdrStatus">Loading‚Ä¶</div>
        <div class="w-24 h-1 rounded-full bg-gray-800 overflow-hidden">
          <div class="h-full w-0" id="hdrProgress"></div>
        </div>
      </div>
    </div>
  </header>

  <!-- Layout -->
  <div class="flex h-[calc(100vh-3.5rem)]">
    <!-- Sidebar -->
    <aside class="w-20 border-r border-gray-800/50 flex flex-col items-center py-7 gap-3 shrink-0 ui2k-sidebar">
      <div class="flex flex-col items-center gap-1">
        <button class="w-10 h-10 rounded-lg text-gray-400 font-medium text-[9px] ui2k-navbtn" id="btnTabTeams" title="Current Rosters">ROST</button>
        <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabOptimal" title="Optimal Lineups">OPT</button>
        <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabHistory" title="Historical Rosters">HIST</button>
      </div>

      <div class="w-8 h-px my-2 bg-gray-800"></div>

      <div class="flex flex-col items-center gap-1">
        <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabMatchups" title="Weekly Matchups">VS</button>
        <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabFA" title="Free Agents">FA</button>
        <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabTrades" title="Recent Trades">TRD</button>
        <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabDef" title="NFL Defense Rankings">DEF</button>
      </div>
      
      <div class="w-8 h-px my-2 bg-gray-800"></div>
      
      <div class="flex flex-col items-center gap-1">
        <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabInsights" title="League Analytics">STAT</button>
      </div>
      
      <div class="flex-1"></div>
      <button class="w-10 h-10 rounded-lg text-gray-500 font-medium text-[9px] ui2k-navbtn" id="btnTabSettings" title="Settings">SET</button>
      <div class="text-[8px] text-gray-600 mt-1">v3.1</div>
    </aside>

    <!-- Main -->
    <main class="flex-1 overflow-hidden relative bg-gradient-to-br from-gray-950 via-gray-950 to-gray-900/50 ui2k-main">
      <!-- Tabs: Teams -->
      <section id="viewTeams" class="h-full flex flex-col p-5 gap-3">
        <div class="flex items-end justify-between gap-4">
          <div>
            <div class="text-2xl font-bold text-white tracking-tight">CURRENT ROSTERS</div>
            <div class="text-sm text-accent" >CURRENT LINEUP SNAPSHOTS</div>
          </div>
          <div class="px-3 py-1.5 bg-gray-800/50 rounded-lg border border-accent/30 ui2k-panel">
            <span class="text-xs text-accent font-mono" id="currentWeekLabel" >Week ‚Äî</span>
          </div>
        </div>

        <!-- Team tabs -->
        <div class="flex gap-2 overflow-x-auto pb-2 scrollbar-thin" id="teamTabs"></div>

        <!-- Team roster -->
        <div class="grid grid-cols-1 xl:grid-cols-3 gap-5 overflow-hidden flex-1">
          <div class="xl:col-span-2 bg-gray-900/80  border border-gray-800/50 rounded-2xl overflow-hidden flex flex-col shadow-xl shadow-black/20 ui2k-panel">
            <div class="p-4 border-b border-accent/20 flex items-center justify-between bg-black/40">
              <div class="flex items-center gap-3">
                <div class="madden-status-bar h-10"></div>
                <div>
                  <div class="text-white font-bold uppercase tracking-wide" id="teamTitle" >Roster</div>
                  <div class="text-xs text-accent/70 font-mono" id="teamSubtitle"></div>
                </div>
              </div>
              <div class="flex items-center gap-3">
                <button id="btnRosterRefresh" class="px-3 py-1.5 rounded-lg text-xs font-medium madden-tab">Refresh</button>
                <span class="text-xs text-gray-500">Click player for details</span>
              </div>
            </div>
            <div class="flex-1 overflow-y-auto overflow-x-hidden p-4" id="rosterList"></div>
          </div>

          <div class="bg-gray-900/80  border border-gray-800/50 rounded-2xl overflow-hidden flex flex-col shadow-xl shadow-black/20 ui2k-panel">
            <div class="p-4 border-b border-accent/20 bg-black/40">
              <div class="flex items-center gap-3">
                <div class="madden-status-bar h-10"></div>
                <div>
                  <div class="text-white font-bold uppercase tracking-wide" >Team Comparison</div>
                  <div class="text-xs text-accent/70 font-mono">Projected totals by position</div>
                </div>
              </div>
            </div>
            <div class="flex-1 overflow-y-auto overflow-x-hidden p-4" id="compareBox"></div>
          </div>
        </div>
      </section>

      <!-- Tabs: Matchups -->
      <section id="viewMatchups" class="h-full hidden flex flex-col p-6 gap-4">
        <div class="flex items-end justify-between gap-4">
          <div>
            <div class="text-2xl font-bold text-white tracking-tight">MATCHUPS</div>
          </div>
          <div class="flex items-center gap-2 bg-gray-800/50 rounded-lg px-3 py-1.5 border border-accent/30 ui2k-panel">
            <span class="text-[10px] font-semibold text-accent uppercase tracking-wider" >Week</span>
            <select id="matchupsWeekSelect" class="bg-transparent border-none text-sm text-accent font-medium focus:outline-none cursor-pointer"></select>
          </div>
        </div>
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-5 overflow-y-auto pr-2 pb-6" id="matchupGrid"></div>
      </section>

      <!-- Tabs: Free Agents -->
      <section id="viewFA" class="h-full hidden flex flex-col p-6 gap-4">
        <div class="flex items-end justify-between gap-4">
          <div>
            <div class="text-2xl font-bold text-white tracking-tight">FREE AGENTS</div>
            <div class="text-sm text-accent" >TOP UNROSTERED PLAYERS BY SEASON TOTAL</div>
          </div>
        </div>

        <div class="flex gap-2 overflow-x-auto pb-2" id="faTabs"></div>

        <div class="bg-gray-900/80  border border-gray-800/50 rounded-2xl overflow-hidden flex flex-col flex-1 shadow-xl shadow-black/20 ui2k-panel">
          <div class="flex-1 overflow-y-auto p-4" id="faList">
            <!-- Player cards will be inserted here in a 2-column grid -->
          </div>
        </div>
      </section>

      <!-- Tabs: NFL Defense -->
      <section id="viewDef" class="h-full hidden flex flex-col p-6 gap-4 overflow-hidden">
        <div class="flex items-end justify-between gap-4 shrink-0">
          <div>
            <div class="text-2xl font-bold text-white">NFL DEFENSES</div>
            <div class="text-sm text-accent" >DEFENSIVE RANKINGS & MATCHUP ANALYSIS</div>
          </div>
        </div>

        <div class="flex gap-2 pb-2 shrink-0" id="defTabs">
          <button class="px-4 py-2 rounded-xl font-bold madden-tab madden-tab-active" id="defTabAFC">AFC</button>
          <button class="px-4 py-2 rounded-xl font-bold madden-tab text-gray-300" id="defTabNFC">NFC</button>
        </div>

        <div class="flex-1 overflow-y-auto pr-2 pb-6">
          <div class="grid grid-cols-1 xl:grid-cols-2 gap-6" id="defContent"></div>
        </div>
      </section>

      <!-- Tabs: Trades -->
      <section id="viewTrades" class="h-full flex flex-col p-6 gap-4 hidden">
        <div class="flex items-end justify-between gap-4">
          <div>
            <div class="text-2xl font-bold text-white">TRANSACTIONS</div>
            <div class="text-sm text-accent" >COMPLETED TRADES & MOVES</div>
          </div>
          <div class="flex items-center gap-2">
            <div class="text-xs text-accent font-bold" id="tradeWeekLabel" >Week ‚Äî</div>
            <input id="tradeSearch" placeholder="Search player/team‚Ä¶" class="bg-gray-900 border border-accent/20 rounded-lg px-3 py-2 text-sm text-white w-56" />
            <select id="tradeType" class="bg-gray-900 border border-gray-800 rounded-lg px-3 py-2 text-sm text-white">
              <option value="all" selected>All Transactions</option>
              <option value="trade">Trades</option>
              <option value="add_drop">Adds/Drops</option>
              <option value="waiver">Waivers</option>
              <option value="free_agent">Free Agent Adds</option>
            </select>
            <button id="btnTradeRefresh" class="bg-gray-800 hover:bg-gray-700 text-white rounded-lg px-3 py-2 text-sm font-bold">Refresh</button>
          </div>
        </div>

        <div class="bg-gray-900 border border-gray-800 rounded-2xl overflow-hidden flex flex-col">
          <div class="flex-1 overflow-y-auto overflow-x-hidden p-4" id="tradeContent"></div>
        </div>
      </section>

      <!-- Tabs: League Analysis -->
      <section id="viewInsights" class="h-full flex flex-col p-6 gap-4 hidden overflow-hidden">
        <div class="flex items-end justify-between gap-4 shrink-0">
          <div>
            <div class="text-2xl font-bold text-white flex items-center gap-2"><span>üìä</span> LEAGUE ANALYSIS</div>
            <div class="text-sm text-accent" >ADVANCED ANALYTICS: ALL-PLAY, EXPECTED WINS, LUCK & MORE</div>
          </div>
        </div>

        <div class="flex-1 overflow-y-auto space-y-6">
          <!-- League Standings Table -->
          <div class="rounded-2xl overflow-hidden ui2k-panel">
            <div class="p-4 border-b border-accent/20">
              <div class="text-white font-bold" >LEAGUE STANDINGS & METRICS</div>
              <div class="text-xs text-accent/70 font-mono">Sorted by expected wins (xW) - click headers to sort</div>
            </div>
            <div class="overflow-x-auto">
              <table class="w-full text-sm">
                <thead class="bg-black/40">
                  <tr>
                    <th class="px-4 py-2 text-left text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="name" >Team</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="record" >W-L</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="pf" >PF</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="pa" >PA</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="allplay" >All-Play</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="xw" >xW</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="luck" >Luck</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="stddev" >StdDev</th>
                    <th class="px-4 py-2 text-right text-accent font-bold uppercase cursor-pointer hover:text-white" data-sort="sos" >SoS</th>
                  </tr>
                </thead>
                <tbody id="leagueInsights"></tbody>
              </table>
            </div>
          </div>

          <!-- Visual Charts Row -->
          <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
            <!-- Points For Chart -->
            <div class="bg-gray-900 border border-gray-800 rounded-2xl p-4">
              <div class="text-white font-bold mb-3">Points For Distribution</div>
              <div class="h-64"><canvas id="insightsPFChart"></canvas></div>
            </div>
            <!-- Luck Analysis Chart -->
            <div class="bg-gray-900 border border-gray-800 rounded-2xl p-4">
              <div class="text-white font-bold mb-3">Luck vs Expected Wins</div>
              <div class="h-64"><canvas id="insightsLuckChart"></canvas></div>
            </div>
          </div>

          <!-- Additional Insights -->
          <div class="grid grid-cols-1 xl:grid-cols-3 gap-6">
            <!-- Luckiest Teams -->
            <div class="bg-gray-900 border border-gray-800 rounded-2xl p-4">
              <div class="text-sleeper-boom font-bold mb-3 flex items-center gap-2">üçÄ Luckiest Teams</div>
              <div class="space-y-2" id="insightsLucky"></div>
            </div>
            <!-- Unluckiest Teams -->
            <div class="bg-gray-900 border border-gray-800 rounded-2xl p-4">
              <div class="text-red-400 font-bold mb-3 flex items-center gap-2">üò¢ Unluckiest Teams</div>
              <div class="space-y-2" id="insightsUnlucky"></div>
            </div>
            <!-- Most Consistent -->
            <div class="bg-gray-900 border border-gray-800 rounded-2xl p-4">
              <div class="text-accent font-bold mb-3 flex items-center gap-2">üìè Most Consistent</div>
              <div class="space-y-2" id="insightsConsistent"></div>
            </div>
          </div>


          <!-- Lineup Management -->
          <div class="bg-gray-900 border border-gray-800 rounded-2xl overflow-hidden">
            <div class="p-4 border-b border-gray-800">
              <div class="text-white font-bold">Lineup Management</div>
              <div class="text-xs text-gray-400 font-mono">Optimal points, bench points, and start/sit efficiency (hybrid stats/projections)</div>
            </div>
            <div class="p-4 space-y-4">
              <div class="grid grid-cols-1 xl:grid-cols-3 gap-4">
                <div class="bg-gray-950/40 border border-gray-800 rounded-xl p-4">
                  <div class="text-accent font-bold mb-2">Best Lineup Efficiency</div>
                  <div class="space-y-2" id="insightsBestEfficiency"></div>
                </div>
                <div class="bg-gray-950/40 border border-gray-800 rounded-xl p-4">
                  <div class="text-red-400 font-bold mb-2">Most Points Left on Bench</div>
                  <div class="space-y-2" id="insightsMostRegret"></div>
                </div>
                <div class="bg-gray-950/40 border border-gray-800 rounded-xl p-4">
                  <div class="text-white font-bold mb-2">Bench Scoring Leaders</div>
                  <div class="space-y-2" id="insightsBenchLeaders"></div>
                </div>
              </div>

              <div class="overflow-x-auto">
                <table class="w-full text-sm">
                  <thead class="bg-gray-950/40">
                    <tr>
                      <th class="px-4 py-2 text-left text-gray-400 font-mono">Team</th>
                      <th class="px-4 py-2 text-right text-gray-400 font-mono">PF</th>
                      <th class="px-4 py-2 text-right text-gray-400 font-mono">OptPF</th>
                      <th class="px-4 py-2 text-right text-gray-400 font-mono">BenchPF</th>
                      <th class="px-4 py-2 text-right text-gray-400 font-mono">Regret</th>
                      <th class="px-4 py-2 text-right text-gray-400 font-mono">Eff%</th>
                    </tr>
                  </thead>
                  <tbody id="leagueLineupInsights"></tbody>
                </table>
              </div>
            </div>
          </div>

          <!-- Positional Scoring Baselines -->
          <div class="bg-gray-900 border border-gray-800 rounded-2xl overflow-hidden">
            <div class="p-4 border-b border-gray-800">
              <div class="text-white font-bold">Positional Scoring Baselines</div>
              <div class="text-xs text-gray-400 font-mono">Season-to-date starter scoring (Median / P25 / P75) using actual starter stats</div>
            </div>
            <div class="p-4 overflow-x-auto">
              <table class="w-full text-sm">
                <thead class="bg-gray-950/40">
                  <tr>
                    <th class="px-4 py-2 text-left text-gray-400 font-mono">Pos</th>
                    <th class="px-4 py-2 text-right text-gray-400 font-mono">Median</th>
                    <th class="px-4 py-2 text-right text-gray-400 font-mono">P25</th>
                    <th class="px-4 py-2 text-right text-gray-400 font-mono">P75</th>
                    <th class="px-4 py-2 text-right text-gray-400 font-mono">Avg</th>
                    <th class="px-4 py-2 text-right text-gray-400 font-mono">N</th>
                  </tr>
                </thead>
                <tbody id="posBaselineTable"></tbody>
              </table>
            </div>
          </div>

                    <!-- Defense vs Role Effectiveness -->
          <div class="bg-gray-900 border border-gray-800 rounded-2xl overflow-hidden">
            <div class="p-4 border-b border-gray-800">
              <div class="text-white font-bold">Defense vs Role Effectiveness</div>
              <div class="text-xs text-gray-400 font-mono">Top scorer per position vs each defense. PPG = avg of top-1 player per game. L4 = last 4 games (hover for breakdown).</div>
            </div>
            <div class="p-4 space-y-3">
              <div class="flex flex-wrap items-center gap-2">
                <div class="text-xs text-gray-400 font-mono">Role</div>
                <select id="defRoleSelect" class="bg-gray-950/40 border border-gray-800 rounded-lg px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-accent/40"></select>
                <div class="flex items-center gap-2 ml-auto">
                  <button id="defRoleModeMost" class="px-3 py-2 rounded-lg bg-gray-800 text-xs font-mono text-white border border-gray-700 hover:bg-gray-700">Most Generous</button>
                  <button id="defRoleModeLeast" class="px-3 py-2 rounded-lg bg-gray-900 text-xs font-mono text-gray-300 border border-gray-800 hover:bg-gray-800 hover:text-white">Stingiest</button>
                </div>
              </div>
              <div class="overflow-x-auto">
                <table class="w-full text-sm">
                  <thead class="bg-gray-950/40">
                    <tr>
                      <th class="px-3 py-2 text-left text-gray-400 font-mono text-xs">DEF</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs">G</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" title="Points Per Game - Average of top scorer each game">PPG</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" title="Last 4 Games Average - Hover row for breakdown">L4</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" title="Volatility - Standard Deviation">Vol</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs">Rk</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" title="Ceiling Rate - % of games in top 25% league-wide">Ceil%</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" title="Floor Rate - % of games in bottom 25% league-wide">Flr%</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" title="Top-10 Rate - % of weeks as top 10 most generous">T10%</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" id="defRoleStatCol1">Stat1</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" id="defRoleStatCol2">Stat2</th>
                      <th class="px-2 py-2 text-right text-gray-400 font-mono text-xs" id="defRoleStatCol3">Stat3</th>
                      <th class="px-3 py-2 text-right text-accent font-mono text-xs font-bold" title="Matchup Score (0-100) - Higher = better matchup">MU</th>
                    </tr>
                  </thead>
                  <tbody id="defRoleTableBody"></tbody>
                </table>
              </div>
              <div class="mt-2 text-[10px] text-gray-500 font-mono">
                MU Score = Rank Base + Trend Bonus + Ceiling Bonus ‚àí Floor Penalty + Consistency + Top10 Rate. Higher = better matchup.
              </div>
            </div>
          </div>

          <!-- Weekly Scoring Trends -->
          <div class="bg-gray-900 border border-gray-800 rounded-2xl p-4">
            <div class="text-white font-bold mb-3">Weekly Scoring Trends</div>
            <div class="h-80"><canvas id="insightsTrendsChart"></canvas></div>
          </div>
        </div>
      </section>


      <!-- Tabs: History -->
      <section id="viewHistory" class="h-full flex flex-col p-6 gap-4 hidden">
        <div class="flex items-end justify-between gap-4">
          <div>
            <div class="text-2xl font-bold text-white tracking-tight" id="historyHeaderTitle">HISTORICAL ROSTERS</div>
            <div class="text-sm text-accent" id="historyHeaderSubtitle" >WEEKLY LINEUP SNAPSHOTS</div>
          </div>
          <div class="flex items-center gap-2">
            <button id="optSettingsToggle" class="hidden px-3 py-1.5 rounded-lg text-xs font-semibold madden-tab">Settings</button>
            <div class="flex items-center gap-2 bg-gray-800/50 rounded-lg px-3 py-1.5 border border-accent/30 ui2k-panel">
              <span class="text-[10px] font-semibold text-accent uppercase tracking-wider" >Week</span>
              <select id="historyWeekSelect" class="bg-transparent border-none text-sm text-accent font-medium focus:outline-none cursor-pointer"></select>
            </div>
          </div>
        </div>

        <div id="optSettingsPanel" class="hidden bg-gray-900/80  border border-gray-800/50 rounded-2xl p-4 shadow-xl shadow-black/20 ui2k-panel">
          <div class="flex items-center justify-between gap-3 mb-3">
            <div>
              <div class="text-sm font-bold text-white">Optimal weighting sliders</div>
              <div class="text-[10px] text-gray-500 font-mono">Weights auto-normalize to 100%.</div>
            </div>
            <button id="optSettingsReset" class="px-3 py-1.5 rounded-lg bg-gray-800 text-xs font-semibold text-gray-200 hover:bg-gray-700">Reset</button>
          </div>
          <div class="grid grid-cols-1 xl:grid-cols-2 2xl:grid-cols-3 gap-3">
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">Value</div>
              <input type="range" min="0" max="100" value="16" data-weight-key="value" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="value">16%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">Proj</div>
              <input type="range" min="0" max="100" value="16" data-weight-key="proj" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="proj">16%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">MU</div>
              <input type="range" min="0" max="100" value="10" data-weight-key="mu" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="mu">10%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">FIT</div>
              <input type="range" min="0" max="100" value="10" data-weight-key="fit" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="fit">10%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">PPG</div>
              <input type="range" min="0" max="100" value="5" data-weight-key="ppg" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="ppg">5%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">L4</div>
              <input type="range" min="0" max="100" value="15" data-weight-key="l4" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="l4">15%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">Cons</div>
              <input type="range" min="0" max="100" value="8" data-weight-key="consistency" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="consistency">8%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">Snaps</div>
              <input type="range" min="0" max="100" value="6" data-weight-key="snaps" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="snaps">6%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">B/B</div>
              <input type="range" min="0" max="100" value="4" data-weight-key="boomBust" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="boomBust">4%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">Delta</div>
              <input type="range" min="0" max="100" value="4" data-weight-key="delta" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="delta">4%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">Ceil</div>
              <input type="range" min="0" max="100" value="3" data-weight-key="ceil" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="ceil">3%</div>
            </div>
            <div class="flex items-center gap-3">
              <div class="w-20 text-xs text-gray-400">Season</div>
              <input type="range" min="0" max="100" value="3" data-weight-key="season" class="flex-1 accent-accent">
              <div class="w-10 text-xs text-gray-300 text-right" data-weight-value="season">3%</div>
            </div>
          </div>
        </div>

        <!-- Team tabs for history -->
        <div class="flex gap-2 overflow-x-auto pb-2" id="historyTeamTabs"></div>

        <!-- Loading indicator (inline) -->
        <div id="historyLoading" class="hidden items-center justify-center py-4">
          <div class="text-gray-400 text-sm flex items-center gap-2">
            <svg class="animate-spin h-4 w-4 text-accent" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Loading week data...
          </div>
        </div>

        <!-- Team roster for history -->
        <div class="grid grid-cols-1 xl:grid-cols-3 gap-5 overflow-hidden flex-1" id="historyMainContent">
          <div class="xl:col-span-2 bg-gray-900/80  border border-gray-800/50 rounded-2xl overflow-hidden flex flex-col shadow-xl shadow-black/20 ui2k-panel">
            <div class="p-4 border-b border-accent/20 flex items-center justify-between bg-black/40">
              <div class="flex items-center gap-3">
                <div class="madden-status-bar h-10"></div>
                <div>
                  <div class="text-white font-bold uppercase tracking-wide" id="historyTeamTitle" >Roster</div>
                  <div class="text-xs text-accent/70 font-mono" id="historyTeamSubtitle"></div>
                </div>
              </div>
              <span class="text-xs text-gray-500">Click player for details</span>
            </div>
            <div class="flex-1 overflow-y-auto overflow-x-hidden p-4" id="historyRosterList"></div>
          </div>

          <div class="bg-gray-900/80  border border-gray-800/50 rounded-2xl overflow-hidden flex flex-col shadow-xl shadow-black/20 ui2k-panel">
            <div class="p-4 border-b border-accent/20 bg-black/40">
              <div class="flex items-center gap-3">
                <div class="madden-status-bar h-10"></div>
                <div>
                  <div class="text-white font-bold uppercase tracking-wide" >Team Comparison</div>
                  <div class="text-xs text-accent/70 font-mono" id="historyCompareSubtitle">Week ‚Äî projected totals by position</div>
                </div>
              </div>
            </div>
            <div class="flex-1 overflow-y-auto overflow-x-hidden p-4" id="historyCompareBox"></div>
          </div>
        </div>
      </section>

      <!-- Settings -->
      <section id="viewSettings" class="hidden h-full overflow-y-auto p-6">
        <div class="max-w-4xl mx-auto">
          <div class="flex items-center justify-between mb-5">
            <div>
              <div class="text-2xl font-bold text-white">‚öôÔ∏è SETTINGS</div>
              <div class="text-sm text-accent" >CONFIGURE YOUR LEAGUE DATA & PREFERENCES</div>
            </div>
          </div>

          <div class="rounded-2xl p-5 shadow-lg ui2k-panel">
            <div class="flex items-center justify-between gap-4 flex-wrap">
              <label class="flex items-center gap-3 text-gray-200">
                <input id="settingsAutoSetup" type="checkbox" class="accent-yellow-500 w-4 h-4" checked />
                <span class="font-semibold">Auto setup</span>
                <span class="text-xs text-accent/70">(recommended)</span>
              </label>

              <div class="text-xs text-accent/50">Saved locally in your browser.</div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-5">
              <div>
                <label class="block text-xs text-accent mb-1" >LEAGUE ID (override)</label>
                <input id="settingsLeagueId" type="text" placeholder="e.g., 1312656463549726720" class="w-full rounded-xl bg-black/50 border border-accent/20 px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-accent/40" />
                <div class="text-xs text-gray-500 mt-1">Leave blank to use the Year ‚Üí League mapping.</div>
              </div>

              <div>
                <label class="block text-xs text-accent mb-1" >SEASON (year)</label>
                <select id="settingsSeason" class="w-full rounded-xl bg-black/50 border border-accent/20 px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-accent/40"></select>
                <div class="text-xs text-gray-500 mt-1">In auto mode, league.season is preferred.</div>
              </div>

              <div>
                <label class="block text-xs text-accent mb-1" >SEASON TYPE</label>
                <select id="settingsSeasonType" class="w-full rounded-xl bg-black/50 border border-accent/20 px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-accent/40" disabled>
                  <option value="regular">regular</option>
                </select>
                <div class="text-xs text-gray-500 mt-1">Locked to regular for stats/projections.</div>
              </div>

              <div>
                <label class="block text-xs text-accent mb-1" >AUTO WEEK SELECTION</label>
                <select id="settingsWeekMode" class="w-full rounded-xl bg-black/50 border border-accent/20 px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-accent/40">
                  <option value="max_week">Use max week (latest available)</option>
                  <option value="last_scored">Use last scored week</option>
                </select>
                <div class="text-xs text-gray-500 mt-1">Only applies when Auto setup is on.</div>
              </div>

              <div class="grid grid-cols-2 gap-3">
                <div>
                  <label class="block text-xs text-gray-400 mb-1">Current week</label>
                  <input id="settingsCurrentWeek" type="number" min="1" max="25" class="w-full rounded-xl bg-gray-950/60 border border-gray-800 px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-600/40" />
                </div>
                <div>
                  <label class="block text-xs text-gray-400 mb-1">Max week</label>
                  <input id="settingsMaxWeek" type="number" min="1" max="25" class="w-full rounded-xl bg-gray-950/60 border border-gray-800 px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-600/40" />
                </div>
                <div class="col-span-2 text-xs text-gray-500">Only applied when Auto setup is off.</div>
              </div>
            </div>

            <div class="flex items-center gap-3 mt-5 flex-wrap">
              <button id="settingsApply" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-white font-semibold shadow">Apply & reload</button>
              <button id="settingsReset" class="px-4 py-2 rounded-xl bg-gray-800 hover:bg-gray-700 text-gray-100 font-semibold">Reset saved settings</button>
            </div>

            <div class="mt-5 rounded-xl bg-gray-950/50 border border-gray-800 p-4">
              <div class="text-xs text-gray-400 mb-2">Effective config</div>
              <pre id="settingsEffective" class="text-xs text-gray-200 whitespace-pre-wrap"></pre>
            </div>
          </div>
        </div>
      </section>

      <!-- Player modal -->
      <div id="playerModal" class="fixed inset-0 hidden items-center justify-center bg-black/80  p-4 z-50">
        <div class="w-full max-w-5xl max-h-[95vh] bg-gray-900 border border-gray-800 rounded-2xl overflow-hidden flex flex-col">
          <div class="p-4 border-b border-gray-800 flex items-start justify-between gap-4">
            <div>
              <div class="text-white text-2xl font-bold" id="pmName">Player</div>
              <div class="mt-3 text-xs text-gray-400 font-mono" id="pmMeta"></div>
              <div class="mt-2 flex gap-2 text-xs font-mono flex-wrap">
                <span class="px-2 py-1 rounded bg-gray-800 text-gray-300" id="pmRank">Rank: ‚Äî</span>
                <span class="px-2 py-1 rounded bg-gray-800 text-gray-300" id="pmBoomBustOverall">Overall: ‚Äî</span>
              </div>
            </div>
            <button class="px-3 py-2 rounded-lg bg-gray-800 text-gray-200 hover:bg-gray-700" id="pmClose">Close</button>
          </div>
          <div class="p-4 overflow-y-auto">
            <!-- Player Efficiency Metrics Section -->
            <div class="bg-gray-950 border border-gray-800 rounded-xl p-4 mb-4" id="pmEfficiencySection">
              <div class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">Season Efficiency Metrics</div>
              <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-3" id="pmEfficiencyGrid">
                <!-- Populated dynamically -->
              </div>
            </div>
            
            <!-- Matchup Analysis Section -->
            <div class="bg-gray-950 border border-gray-800 rounded-xl p-4 mb-4" id="pmMatchupSection">
              <div class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">Current Matchup Analysis</div>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="pmMatchupGrid">
                <!-- Populated dynamically -->
              </div>
            </div>

            <div class="bg-gray-950 border border-gray-800 rounded-xl p-4">
              <div class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2">Weekly Actual vs Projected (Custom Scoring)</div>
              <div class="h-72">
                <canvas id="pmChart"></canvas>
              </div>
            </div>

            <div class="mt-4 bg-gray-950 border border-gray-800 rounded-xl overflow-hidden">
              <div class="px-4 py-3 border-b border-gray-800 text-xs font-bold text-gray-400 uppercase tracking-wider">Week-by-week boom/bust</div>
              <div class="overflow-x-auto">
                <table class="w-full text-sm">
                  <thead class="bg-gray-900 text-gray-400 text-xs uppercase">
                    <tr>
                      <th class="text-left px-4 py-2">Week</th>
                      <th class="text-left px-4 py-2">Opp</th>
                      <th class="text-right px-4 py-2">Proj</th>
                      <th class="text-right px-4 py-2">Actual</th>
                      <th class="text-right px-4 py-2">Delta</th>
                      <th class="text-left px-4 py-2">Status</th>
                    </tr>
                  </thead>
                  <tbody id="pmTable" class="divide-y divide-gray-800"></tbody>
                </table>
              </div>
            </div>

            <div class="mt-4 text-xs text-gray-500 font-mono">
              Note: If the week hasn't been played yet (no stats), "Actual" is blank and status is "Not played".
            </div>
          </div>
        </div>
      </div>
      
      <!-- Matchup modal -->
      <div id="matchupModal" class="fixed inset-0 hidden items-center justify-center bg-black/80  p-4 z-[60]">
        <div class="w-full max-w-6xl max-h-[95vh] bg-gray-900 border border-gray-800 rounded-2xl overflow-hidden flex flex-col">
          <div class="p-4 border-b border-gray-800 flex items-start justify-between gap-4">
            <div class="min-w-0">
              <div class="text-white text-2xl font-bold truncate" id="mmTitle">Matchup</div>
              <div class="mt-2 grid grid-cols-2 gap-3">
                <div class="bg-gray-950 border border-gray-800 rounded-xl p-3">
                  <div class="flex items-center justify-between gap-2">
                    <div class="text-white font-bold truncate" id="mmTeamA">Team A</div>
                    <div class="text-accent font-black font-mono" id="mmTotalA">0.00</div>
                  </div>
                  <div class="text-[11px] text-gray-500 font-mono">Starters hybrid total</div>
                </div>
                <div class="bg-gray-950 border border-gray-800 rounded-xl p-3">
                  <div class="flex items-center justify-between gap-2">
                    <div class="text-white font-bold truncate" id="mmTeamB">Team B</div>
                    <div class="text-accent font-black font-mono" id="mmTotalB">0.00</div>
                  </div>
                  <div class="text-[11px] text-gray-500 font-mono">Starters hybrid total</div>
                </div>
              </div>
            </div>
            <button class="px-3 py-2 rounded-lg bg-gray-800 text-gray-200 hover:bg-gray-700" id="mmClose">Close</button>
          </div>

          <div class="p-4 overflow-y-auto">
            <div class="grid grid-cols-1 xl:grid-cols-2 gap-4">
              <div class="bg-gray-950 border border-gray-800 rounded-xl overflow-hidden">
                <div class="px-3 py-2 border-b border-gray-800 text-xs font-bold text-gray-400 uppercase tracking-wider">Team A starters</div>
                <div id="mmListA" class="divide-y divide-gray-800"></div>
              </div>
              <div class="bg-gray-950 border border-gray-800 rounded-xl overflow-hidden">
                <div class="px-3 py-2 border-b border-gray-800 text-xs font-bold text-gray-400 uppercase tracking-wider">Team B starters</div>
                <div id="mmListB" class="divide-y divide-gray-800"></div>
              </div>
            </div>

            <div class="mt-3 text-xs text-gray-500 font-mono">
              Click a player to open their week-by-week chart.
            </div>
          </div>
        </div>
      </div>

    </main>
  </div>

<script>
/* ==========================
   Sleeper League Analytics
   Standalone, no backend
   ES5 Compatible
   ========================== */

// Helper function to replace nullish coalescing
function nvl(val, fallback) {
  return (val !== null && val !== undefined) ? val : fallback;
}

var SEASON_LEAGUES = {
  "2024": "1122650835105759232",
  "2025": "1180280389862244352",
  "2026": "1312656463549726720"
};
var DEFAULT_SEASON_CHOICE = "2025";
var SAVED_SEASON_CHOICE = null;
try { SAVED_SEASON_CHOICE = localStorage.getItem("sleeper_app_season_choice"); } catch(e) {}
var INITIAL_SEASON_CHOICE = (SAVED_SEASON_CHOICE && SEASON_LEAGUES[SAVED_SEASON_CHOICE]) ? SAVED_SEASON_CHOICE : DEFAULT_SEASON_CHOICE;

var APP = {
  cfg: {
    seasonLeagues: SEASON_LEAGUES,
    selectedSeasonChoice: INITIAL_SEASON_CHOICE,
    leagueId: SEASON_LEAGUES[INITIAL_SEASON_CHOICE],
    seasonType: "regular",

      // Auto setup uses /state/nfl + league metadata. Manual overrides are stored in localStorage.
      autoSetup: true,
      manual: { leagueId: "", season: "", seasonType: "regular", currentWeek: 1, maxWeek: 18 },
      weekSelectionMode: "max_week",
    boomPct: 1.20,
    bustPct: 0.80
  },
  optWeightDefaults: {
    value: 16,
    proj: 16,
    mu: 10,
    fit: 10,
    ppg: 5,
    l4: 15,
    consistency: 8,
    snaps: 6,
    boomBust: 4,
    delta: 4,
    ceil: 3,
    season: 3
  },
  data: {
    nflState: null,
    league: null,
    appSeason: null,
    maxWeek: null,
    usersById: {},
    rosters: [],
    matchups: [],
    weekMatchups: {},
        weekTrans: {},
    teamWeekScores: {},
    leagueMetrics: null,
playersById: {},
    weekStats: {},
    weekProj: {},
    weekLoadPromises: {},
    winnersBracket: [],
    losersBracket: [],
    seasonTotals: null,
    pfrDefenseStats: null,
    nflSchedule: null,
    playerDeltaRanks: {},
    defRoleMetrics: null,
    playerValueIndex: null
  },
  
  // NFL Schedule - will be loaded dynamically
  nflSchedule: {},
  
  ui: {
    currentView: "teams",
    selectedRosterId: null,
    selectedWeek: null,
    selectedFA: "QB",
    selectedConference: "AFC",
    chart: null,
    pfChart: null,
    luckChart: null,
    trendsChart: null,
    historySelectedWeek: null,
    historySelectedRosterId: null,
    historyMatchups: null,
    historyMode: "roster",
    faConfig: [],
    optSettingsOpen: false,
    optWeights: null
  },

  dom: {},

  cacheDom: function() {
    var ids = ['hdrStatus', 'hdrProgress', 'seasonSelect', 'hdrLeague', 'hdrMeta', 'weekSelect', 
               'teamTabs', 'teamTitle', 'teamSubtitle', 'btnRosterRefresh', 'rosterList', 'compareBox',
               'matchupGrid', 'matchupsWeekSelect', 'faTabs', 'faList', 'playerModal', 'matchupModal',
               'pmName', 'pmMeta', 'pmRank', 'pmBoomBustOverall', 'pmChart', 'pmTable',
               'pmEfficiencySection', 'pmEfficiencyGrid', 'pmMatchupSection', 'pmMatchupGrid',
               'mmTitle', 'mmTeamA', 'mmTeamB', 'mmTotalA', 'mmTotalB', 'mmListA', 'mmListB',
               'viewTeams', 'viewMatchups', 'viewFA', 'viewDef', 'btnTabTeams', 'btnTabMatchups', 
               'btnTabFA', 'btnTabDef', 'pmClose', 'mmClose', 'defContent', 'defTabAFC', 'defTabNFC', 'viewTrades', 'btnTabTrades', 'tradeContent', 'tradeSearch', 'tradeType', 'btnTradeRefresh', 'tradeWeekLabel', 'leagueInsights',
             'viewInsights', 'btnTabInsights', 'insightsPFChart', 'insightsLuckChart', 'insightsLucky', 'insightsUnlucky', 'insightsConsistent', 'insightsTrendsChart',
             'viewHistory', 'btnTabHistory', 'btnTabOptimal', 'historyHeaderTitle', 'historyHeaderSubtitle', 'historyWeekSelect', 'optSettingsToggle', 'optSettingsPanel', 'optSettingsReset', 'historyTeamTabs', 'historyTeamTitle', 'historyTeamSubtitle', 'historyRosterList', 'historyCompareBox', 'historyCompareSubtitle', 'historyLoading', 'historyMainContent', 'currentWeekLabel', 'leagueLineupInsights', 'posBaselineTable', 'insightsBestEfficiency', 'insightsMostRegret', 'insightsBenchLeaders',
               'defRoleSelect',
               'defRoleModeMost',
               'defRoleModeLeast',
               'defRoleTableBody', 'viewSettings', 'btnTabSettings', 'settingsAutoSetup', 'settingsLeagueId', 'settingsSeason', 'settingsSeasonType', 'settingsWeekMode', 'settingsCurrentWeek', 'settingsMaxWeek', 'settingsApply', 'settingsReset', 'settingsEffective'];
    var self = this;
    ids.forEach(function(id) { self.dom[id] = document.getElementById(id); });
  },

  setProgress: function(msg, pct) {
    if (this.dom.hdrStatus) this.dom.hdrStatus.textContent = msg;
    if (this.dom.hdrProgress) this.dom.hdrProgress.style.width = pct + "%";
  },

  getNflStateWeek: function() {
    var ns = this.data.nflState || {};
    var leg = Number(ns.leg != null ? ns.leg : ns.week);
    if (!isFinite(leg) || leg < 1) leg = 1;
    return leg;
  },

  getOptimalWeights: function() {
    var base = this.optWeightDefaults || {};
    var current = (this.ui && this.ui.optWeights) ? this.ui.optWeights : {};
    var merged = {};
    var total = 0;
    Object.keys(base).forEach(function(key) {
      var v = Number(current[key] != null ? current[key] : base[key]);
      if (!isFinite(v) || v < 0) v = 0;
      merged[key] = v;
      total += v;
    });
    if (!total) total = 1;
    var normalized = {};
    Object.keys(merged).forEach(function(key) {
      normalized[key] = merged[key] / total;
    });
    return normalized;
  },

  syncOptimalSliderUI: function() {
    var panel = this.dom.optSettingsPanel;
    if (!panel) return;
    var self = this;
    var weights = this.ui.optWeights || {};
    Object.keys(this.optWeightDefaults || {}).forEach(function(key) {
      var input = panel.querySelector('[data-weight-key="' + key + '"]');
      var valueEl = panel.querySelector('[data-weight-value="' + key + '"]');
      var baseVal = self.optWeightDefaults[key];
      var val = (weights[key] != null) ? weights[key] : baseVal;
      if (input) input.value = val;
      if (valueEl) valueEl.textContent = Math.round(val) + "%";
    });
  },

  bindOptimalSettings: function() {
    if (this._optSettingsWired) return;
    this._optSettingsWired = true;
    var self = this;
    var panel = this.dom.optSettingsPanel;
    var toggle = this.dom.optSettingsToggle;
    if (toggle) {
      toggle.onclick = function() {
        self.ui.optSettingsOpen = !self.ui.optSettingsOpen;
        if (panel) panel.classList.toggle("hidden", !self.ui.optSettingsOpen);
        if (toggle) toggle.textContent = self.ui.optSettingsOpen ? "Close" : "Settings";
      };
    }
    if (!panel) return;

    var inputs = panel.querySelectorAll("[data-weight-key]");
    inputs.forEach(function(input) {
      var key = input.getAttribute("data-weight-key");
      input.oninput = function() {
        var val = Number(input.value);
        if (!self.ui.optWeights) self.ui.optWeights = {};
        self.ui.optWeights[key] = val;
        var valueEl = panel.querySelector('[data-weight-value="' + key + '"]');
        if (valueEl) valueEl.textContent = Math.round(val) + "%";
        self.ui._historyBestCache = {};
        if (self.ui.currentView === "optimal") {
          self.renderHistoryRoster();
          self.renderHistoryComparison();
        }
      };
    });

    if (this.dom.optSettingsReset) {
      this.dom.optSettingsReset.onclick = function() {
        self.ui.optWeights = null;
        self.ui._historyBestCache = {};
        self.syncOptimalSliderUI();
        if (self.ui.currentView === "optimal") {
          self.renderHistoryRoster();
          self.renderHistoryComparison();
        }
      };
    }
  },

  fetchJson: function(url) {
    return fetch(url).then(function(r) {
      if (!r.ok) throw new Error("HTTP " + r.status + " for " + url);
      return r.json();
    });
  },

  // Fetch helper for HTML/text endpoints (used for HTML scraping via CORS-friendly mirrors)
  fetchText: function(url) {
    return fetch(url).then(function(r) {
      if (!r.ok) throw new Error("HTTP " + r.status + " for " + url);
      return r.text();
    });
  },


  escapeHtml: function(str) {
    if (!str) return '';
    var div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  },

  arrToMap: function(arr) {
    var m = {};
    var i, row, pid, vals, v;
    
    if (Array.isArray(arr)) {
      for (i = 0; i < arr.length; i++) {
        row = arr[i];
        if (!row) continue;
        pid = nvl(nvl(row.player_id, row.playerId), row.id);
        if (pid == null) continue;
        m[String(pid)] = row.stats || row.projections || row || {};
      }
      return m;
    }

    if (arr && typeof arr === "object") {
      vals = Object.values(arr);
      if (vals.length && vals[0] && typeof vals[0] === "object" && ("player_id" in vals[0] || "playerId" in vals[0])) {
        for (i = 0; i < vals.length; i++) {
          row = vals[i];
          if (!row) continue;
          pid = nvl(nvl(row.player_id, row.playerId), row.id);
          if (pid == null) continue;
          m[String(pid)] = row.stats || row.projections || row || {};
        }
        return m;
      }

      var entries = Object.entries(arr);
      for (i = 0; i < entries.length; i++) {
        pid = entries[i][0];
        v = entries[i][1];
        if (v && typeof v === "object" && ("stats" in v || "projections" in v)) {
          m[String(pid)] = v.stats || v.projections || {};
        } else {
          m[String(pid)] = v || {};
        }
      }
    }
    return m;
  },

    buildPlayerCardElement: function(item, opts) {
    var self = this;
    opts = opts || {};
    var p = item.player || item.p || {};
    var pid = String(item.pid || p.player_id || "");

    // --- helpers ---
    function esc(x) { return self.escapeHtml(String(x == null ? "" : x)); }
    function num(x) { var n = Number(x); return isFinite(n) ? n : null; }
    function pct01(x) { var n = num(x); return (n == null) ? null : Math.max(0, Math.min(1, n)); }
    function pctStr(x) { var n = pct01(x); return (n == null) ? "‚Äî" : Math.round(n * 100) + "%"; }
    function fmt1(x) { var n = num(x); return (n == null) ? "0.0" : n.toFixed(1); }
    function fmt2signed(x) {
      var n = num(x);
      if (n == null) return "‚Äî";
      return (n >= 0 ? "+" : "") + n.toFixed(2);
    }
    function safeUpper(x){ return String(x || "").toUpperCase(); }

    // --- display name ---
    var disp = item.disp || {};
    var fullName = (disp && disp.name) ? disp.name : ((p.first_name || p.last_name) ? ((p.first_name || "") + " " + (p.last_name || "")).trim() : (p.full_name || ""));
    fullName = String(fullName || "").trim();
    var first = fullName.split(" ")[0] || fullName || "";
    var last = fullName.split(" ").slice(1).join(" ").trim();
    if (!last && p.last_name) last = p.last_name;

    // --- team / pos / age ---
    var team = safeUpper(p.team || disp.team || item.team);
    var pos = safeUpper(p.position || (p.fantasy_positions && p.fantasy_positions[0]) || disp.pos || item.pos);
    var teamPos = (team ? team : "‚Äî") + (pos ? (" " + pos) : "");

    var age = num(p.age);
    if (age == null && p.birth_date) {
      try {
        var bd = new Date(p.birth_date);
        if (!isNaN(bd.getTime())) {
          var now = new Date();
          var a = now.getFullYear() - bd.getFullYear();
          var m = now.getMonth() - bd.getMonth();
          if (m < 0 || (m === 0 && now.getDate() < bd.getDate())) a--;
          if (isFinite(a)) age = a;
        }
      } catch(e) {}
    }
    age = (age == null) ? "" : String(Math.floor(age));

    // --- scores ---
    var proj = num(item.proj);
    var act = num(item.act);
    var hasPlayed = (typeof item.hasPlayed === "boolean") ? item.hasPlayed : (act != null && act !== 0);

    var muScore = num(item.muScore);
    if (item.enhancedMU && num(item.enhancedMU.matchScore) != null) muScore = num(item.enhancedMU.matchScore);

    // --- status (boom/bust) ---
    var status = item.status || self.boomBustStatus(proj || 0, act || 0, !!hasPlayed, muScore == null ? 50 : muScore);
    var statusLabel = (status && status.label) ? String(status.label) : "In Range";
    var statusKey = statusLabel.toLowerCase();

    function statusPillClasses() {
      if (statusKey === "major bust") return "bg-sleeper-majorBust/10 text-sleeper-majorBust border border-sleeper-majorBust/20 shadow-[0_0_10px_rgba(249,115,22,0.4)]";
      if (statusKey === "bust") return "bg-sleeper-bust/10 text-sleeper-bust border border-sleeper-bust/20 shadow-[0_0_10px_rgba(239,68,68,0.35)]";
      if (statusKey === "major boom") return "bg-sleeper-majorBoom/10 text-sleeper-majorBoom border border-sleeper-majorBoom/20 shadow-[0_0_10px_rgba(211,3,252,0.45)]";
      if (statusKey === "boom") return "bg-sleeper-boom/10 text-sleeper-boom border border-sleeper-boom/20 shadow-[0_0_10px_rgba(34,197,94,0.35)]";
      if (statusKey === "in range") return "bg-sleeper-mid/10 text-sleeper-mid border border-sleeper-mid/20 shadow-[0_0_10px_rgba(59,130,246,0.35)]";
      return "bg-gray-800/40 text-gray-400 border border-gray-700/50";
    }
    function statusArrow() {
      if (statusKey.indexOf("boom") !== -1) return "‚Üó";
      if (statusKey.indexOf("bust") !== -1) return "‚Üò";
      if (statusKey === "in range") return "‚Üí";
      return "‚Ä¢";
    }

    // --- availability pill ---
    var injury = safeUpper(p.injury_status || p.status || "");
    var slot = safeUpper(item.slot || "");
    var avail = "ACTIVE";
    if (slot === "IR") avail = "IR";
    if (injury) avail = injury;
    if (item.isOut) avail = "OUT";
    var availCls = "bg-emerald-900/20 text-emerald-200 border-emerald-900/40";
    var availKey = avail.toLowerCase();
    if (availKey.indexOf("ir") !== -1) availCls = "bg-amber-900/20 text-amber-200 border-amber-900/40";
    else if (availKey.indexOf("out") !== -1) availCls = "bg-red-900/20 text-red-200 border-red-900/40";
    else if (availKey === "d" || availKey.indexOf("doubt") !== -1) availCls = "bg-yellow-900/20 text-yellow-200 border-yellow-900/40";
    else if (availKey === "q" || availKey.indexOf("quest") !== -1) availCls = "bg-sky-900/20 text-sky-200 border-sky-900/40";

    // --- opponent & matchup rates ---
    var opp = String(item.opp || item.opponent || disp.opp || "").trim();
    opp = opp.replace(/^vs\s+/i, "").replace(/^@\s*/i, "").toUpperCase();

    var ceilRate = (item.enhancedMU && item.enhancedMU.ceilRate != null) ? item.enhancedMU.ceilRate : item.ceilRate;
    var flrRate = (item.enhancedMU && item.enhancedMU.floorRate != null) ? item.enhancedMU.floorRate : item.floorRate;
    var t10Rate = (item.enhancedMU && item.enhancedMU.top10Rate != null) ? item.enhancedMU.top10Rate : item.top10Rate;

    // --- ranks ---
    var rankTotal = (item.posRank && item.posRank.rank != null) ? ("#" + item.posRank.rank) : (disp.totalRank ? ("#" + disp.totalRank) : "‚Äî");
    var rankPPG = (item.ppgRank && item.ppgRank.rank != null) ? ("#" + item.ppgRank.rank) : (disp.ppgRank ? ("#" + disp.ppgRank) : "‚Äî");
    var deltaVal = (item.deltaRank && item.deltaRank.rank != null) ? item.deltaRank.rank : (item.delta != null ? item.delta : null);

    // --- value / MU / FIT ---
    var valueScore = num(item.valueScore);
    var valStr = (valueScore == null) ? "‚Äî" : String(Math.round(valueScore));

    var muStr = (muScore == null) ? "‚Äî" : String(Math.round(muScore));

    var fit = num(item.fit);
    if ((fit == null || fit === 0) && self.data && self.data.fitById && pid && self.data.fitById[pid] != null) {
      fit = num(self.data.fitById[pid]);
    }
    if (fit == null || fit === 0) {
      // fallback: blend MU + value + projection to a 0-100 scale
      var muN = (muScore == null) ? 50 : muScore;
      var valN = (valueScore == null) ? 500 : valueScore;
      var projN = (proj == null) ? 0 : proj;
      fit = (0.55 * muN) + (0.25 * (valN / 10)) + (0.20 * Math.max(0, Math.min(100, projN * 4)));
      if (item.isOut || avail === "OUT") fit *= 0.25;
      if (avail === "IR") fit *= 0.45;
      fit = Math.max(0, Math.min(100, fit));
    }
    var fitStr = String(Math.round(fit));

    // --- image URLs ---
    var head = self.playerHeadshotUrl(pid);
    var teamLogo = self.teamLogoUrl(team);
    var fallback = teamLogo ? ("this.onerror=null;this.src='" + teamLogo + "';") : "this.onerror=null;";

    // --- tier class based on value score (2K MyTeam style, 0-1000 scale) ---
    var tierClass = "";
    if (valueScore != null) {
      var vs = Math.round(valueScore);
      if (vs >= 950) tierClass = "tier-goat";
      else if (vs >= 900) tierClass = "tier-darkmatter";
      else if (vs >= 850) tierClass = "tier-pinkdiamond";
      else if (vs >= 780) tierClass = "tier-diamond";
      else if (vs >= 700) tierClass = "tier-amethyst";
      else if (vs >= 600) tierClass = "tier-ruby";
      else if (vs >= 500) tierClass = "tier-sapphire";
      else if (vs >= 400) tierClass = "tier-gold";
      else if (vs >= 280) tierClass = "tier-silver";
      else tierClass = "tier-bronze";
    }

    // --- card element ---
    var card = document.createElement("div");
    var border = item.isOut ? "border-red-900/50" : "";
    card.className = "player-card card-hover rounded-lg cursor-pointer w-full min-w-[400px] max-w-[520px] h-[160px] overflow-hidden " + tierClass + (item.isOut ? " opacity-70" : "");
    card.setAttribute("data-pid", pid);
    card.onclick = function() { self.openPlayerModal(pid); };

    card.innerHTML =
      '<div class="w-full h-full flex gap-0.5 p-1">' +
        // LEFT IMAGE PANEL
        '<div class="w-[36%] rounded-2xl overflow-hidden relative bg-[#10172a] border border-white/5">' +
          '<img src="' + esc(head) + '" class="absolute inset-0 w-full h-full object-cover opacity-90" onerror="' + esc(fallback) + '" loading="lazy" alt="">' +
          '<div class="absolute inset-0 bg-[radial-gradient(circle_at_50%_30%,rgba(255,255,255,0.1),transparent_70%)]"></div>' +
          '<div class="absolute inset-0 bg-gradient-to-t from-black/90 via-black/40 to-transparent"></div>' +
          '<div class="p-3 flex flex-col justify-between h-full relative z-10">' +
            '<div class="absolute top-3 right-3">' +
              '<div class="text-[10px] font-mono font-bold text-white tracking-widest bg-black/10 px-1.5 py-0.5 rounded border border-white/10">' +
                'AGE <span class="text-white">' + esc(age || "‚Äî") + '</span>' +
              '</div>' +
            '</div>' +
            '<div></div>' +
            '<div class="leading-none">' +
              '<div class="text-[11px] font-black tracking-widest text-yellow-400/90 mb-1 truncate">' + esc(teamPos) + '</div>' +
              '<div class="flex items-end flex-wrap gap-x-4">' +
                '<div class="min-w-0">' +
                  '<div class="text-[22px] font-black italic text-white leading-[0.9] truncate">' + esc(first) + '</div>' +
                  '<div class="text-[22px] font-black italic text-white leading-[0.9] truncate">' + esc(last) + '</div>' +
                '</div>' +
                '<div class="text-[22px] font-black italic text-emerald-400 leading-[0.9] drop-shadow-[0_0_8px_rgba(52,211,153,0.6)] shrink-0">' +
                  '<span class="text-[12px] align-top font-black italic text-emerald-400 leading-[0.9] drop-shadow-[0_0_8px_rgba(52,211,153,0.6)]">VAL</span>' + esc(valStr) +
                '</div>' +
              '</div>' +
            '</div>' +
          '</div>' +
        '</div>' +
        // RIGHT DETAILS PANEL
        '<div class="flex-1 min-w-0 rounded-2xl border border-white/5 bg-[#0f111a] p-2 flex flex-col justify-between">' +
          '<div class="flex items-start justify-between gap-2 border-b border-white/5 pb-2">' +
            '<div class="flex items-start gap-4">' +
              '<div class="text-[9px] uppercase tracking-widest text-gray-400 font-bold">' +
                '<div class="text-[9px] text-gray-500">RANK</div>' +
                '<div class="text-emerald-400 text-[12px] font-black mt-0.5">' + esc(rankTotal) + '</div>' +
              '</div>' +
              '<div class="text-[9px] uppercase tracking-widest text-gray-400 font-bold">' +
                '<div class="text-[9px] text-gray-500">PPG</div>' +
                '<div class="text-fuchsia-400 text-[12px] font-black mt-0.5">' + esc(rankPPG) + '</div>' +
              '</div>' +
              '<div class="text-[9px] uppercase tracking-widest text-gray-400 font-bold">' +
                '<div class="text-[9px] text-gray-500">DELTA</div>' +
                '<div class="text-green-400 text-[12px] font-black mt-0.5">' + esc(fmt2signed(deltaVal)) + '</div>' +
              '</div>' +
            '</div>' +
            '<span class="shrink-0 px-2 py-1 rounded-lg border font-mono text-[10px] font-bold ' + esc(availCls) + '">' + esc(avail) + '</span>' +
          '</div>' +

          '<div class="flex items-center justify-between gap-2 py-1">' +
            '<div class="min-w-0">' +
              '<div class="text-[9px] uppercase tracking-widest text-gray-500 font-bold mb-0.5">Opponent</div>' +
              '<div class="text-[14px] font-black text-white leading-none truncate">' + esc(opp || "‚Äî") + '</div>' +
            '</div>' +

            '<div class="flex gap-3 text-[9px] font-mono shrink-0">' +
              '<div class="text-center">' +
                '<div class="text-gray-500 text-[10px] uppercase">Ceil</div>' +
                '<div class="font-bold text-[10px] text-green-400">' + esc(pctStr(ceilRate)) + '</div>' +
              '</div>' +
              '<div class="text-center">' +
                '<div class="text-gray-500 text-[10px] uppercase">Flr</div>' +
                '<div class="font-bold text-[10px] text-red-400">' + esc(pctStr(flrRate)) + '</div>' +
              '</div>' +
              '<div class="text-center">' +
                '<div class="text-gray-500 text-[10px] uppercase">T10</div>' +
                '<div class="font-bold text-[10px] text-yellow-400">' + esc(pctStr(t10Rate)) + '</div>' +
              '</div>' +
            '</div>' +

            '<div class="shrink-0 px-2 py-1 rounded-lg text-[10px] font-bold flex items-center gap-1 ' + esc(statusPillClasses()) + '">' +
              '<span>' + esc(statusArrow()) + '</span><span>' + esc(statusLabel.toUpperCase()) + '</span>' +
            '</div>' +
          '</div>' +

          '<div class="mt-auto rounded-xl bg-gradient-to-r from-blue-900/30 to-indigo-900/20 border border-white/5 px-2 py-2 flex items-center justify-between gap-3 min-w-0 relative">' +
            '<div class="flex flex-col gap-1 shrink-0">' +
              '<div class="px-1.5 py-0.5 rounded bg-fuchsia-900/40 border border-fuchsia-500/30 text-[9px] font-mono font-bold text-fuchsia-200 leading-none text-center">FIT ' + esc(fitStr) + '</div>' +
              '<div class="px-1.5 py-0.5 rounded bg-sky-900/40 border border-sky-500/30 text-[9px] font-mono font-bold text-sky-200 leading-none text-center">MU ' + esc(muStr) + '</div>' +
            '</div>' +

            '<div class="flex-1 flex flex-col items-center justify-center border-r border-white/10 pr-2 min-w-0">' +
              '<div class="text-[8px] uppercase tracking-widest text-blue-200/50 font-bold mb-0.5">Projected</div>' +
              '<div class="text-[18px] font-black text-blue-100 leading-none truncate">' + esc(fmt1(proj)) + '</div>' +
            '</div>' +

            '<div class="flex-1 flex flex-col items-center justify-center pl-2 min-w-0">' +
              '<div class="text-[8px] uppercase tracking-widest text-blue-200/50 font-bold mb-0.5">Actual</div>' +
              '<div class="text-[18px] font-black leading-none truncate ' + esc((status && status.color) ? status.color : "text-white") + '">' + esc(fmt1(act)) + '</div>' +
            '</div>' +
          '</div>' +

        '</div>' +
      '</div>';

    return card;
  },


  scoreFromStats: function(statsObj, playerId) {
    if (!statsObj) return 0;
    var s = (this.data.league && this.data.league.scoring_settings) || {};
    var total = 0;
    var entries = Object.entries(s);
    for (var i = 0; i < entries.length; i++) {
      var k = entries[i][0];
      var mult = entries[i][1];
      if (typeof mult !== "number" || mult === 0) continue;
      var v = statsObj[k];
      if (typeof v === "number") total += v * mult;
    }
    return Math.round((total + Number.EPSILON) * 100) / 100;
  },

  boomBustStatus: function(proj, actual, hasPlayed, muScore) {
    if (!hasPlayed) return { label: "Not played", color: "text-gray-400", bg: "bg-gray-800" };
    if (proj <= 0) return { label: "No projection", color: "text-gray-400", bg: "bg-gray-800" };

    var isBoom = actual >= proj * this.cfg.boomPct;
    var isBust = actual <= proj * this.cfg.bustPct;

    if (isBoom) {
      if (muScore !== null && muScore !== undefined && isFinite(muScore) && muScore < 30) {
        return { label: "Major Boom", color: "text-sleeper-majorBoom", bg: "bg-sleeper-majorBoom/20" };
      }
      return { label: "Boom", color: "text-sleeper-boom", bg: "bg-sleeper-boom/20" };
    }

    if (isBust) {
      if (muScore !== null && muScore !== undefined && isFinite(muScore) && muScore > 80) {
        return { label: "Major Bust", color: "text-sleeper-majorBust", bg: "bg-sleeper-majorBust/20" };
      }
      return { label: "Bust", color: "text-sleeper-bust", bg: "bg-sleeper-bust/20" };
    }

    return { label: "In Range", color: "text-sleeper-mid", bg: "bg-sleeper-mid/20" };
  },

  statusPillsFromCounts: function(counts) {
    if (!counts) return "";
    var parts = [];

    if (counts.mboom) parts.push('<span class="px-1.5 py-0.5 rounded bg-sleeper-majorBoom/20 text-sleeper-majorBoom glow-majorBoom">Major Boom ' + counts.mboom + '</span>');
    if (counts.boom)  parts.push('<span class="px-1.5 py-0.5 rounded bg-sleeper-boom/20 text-sleeper-boom">Boom ' + counts.boom + '</span>');
    if (counts.within) parts.push('<span class="px-1.5 py-0.5 rounded bg-sleeper-mid/20 text-sleeper-mid">In Range ' + counts.within + '</span>');
    if (counts.bust)  parts.push('<span class="px-1.5 py-0.5 rounded bg-sleeper-bust/20 text-sleeper-bust">Bust ' + counts.bust + '</span>');
    if (counts.mbust) parts.push('<span class="px-1.5 py-0.5 rounded bg-sleeper-majorBust/20 text-sleeper-majorBust glow-majorBust">Major Bust ' + counts.mbust + '</span>');

    if (!parts.length) return "";
    return '<div class="flex flex-wrap gap-1 text-[10px] font-mono">' + parts.join("") + '</div>';
  },

  countStatusesForPids: function(pidArray, statsMap, projMap, weekNum) {
    var self = this;
    var c = { mboom: 0, boom: 0, within: 0, bust: 0, mbust: 0 };
    if (!Array.isArray(pidArray)) return c;

    for (var i = 0; i < pidArray.length; i++) {
      var pid = String(pidArray[i]);
      if (!pid || pid === "0") continue;

      var pObj = self.data.playersById[pid] || {};
      var actStats = (statsMap && statsMap[pid]) ? statsMap[pid] : {};
      var projStats = (projMap && projMap[pid]) ? projMap[pid] : {};

      var hasPlayed = actStats && Object.keys(actStats).length > 0;
      var proj = self.scoreFromStats(projStats, pid);
      var act = self.scoreFromStats(actStats, pid);

      var opp = self.getOpponent(actStats, projStats, pObj, weekNum);
      var enh = self.getEnhancedMatchupInfo(pid, opp);
      var muScore = (enh && enh.matchScore !== undefined) ? enh.matchScore : null;

      var st = self.boomBustStatus(proj, act, hasPlayed, muScore);
      if (!st || !st.label) continue;

      if (st.label === "Major Boom") c.mboom += 1;
      else if (st.label === "Boom") c.boom += 1;
      else if (st.label === "In Range") c.within += 1;
      else if (st.label === "Bust") c.bust += 1;
      else if (st.label === "Major Bust") c.mbust += 1;
    }

    return c;
  },


  scoreColor: function(proj, actual, hasPlayed) {
    if (!hasPlayed) return "text-gray-200";
    if (proj <= 0) return "text-gray-200";
    if (actual >= proj * this.cfg.boomPct) return "text-sleeper-boom";
    if (actual <= proj * this.cfg.bustPct) return "text-sleeper-bust";
    return "text-sleeper-mid";
  },

  // Helper to create efficiency metric card HTML
  effMetricCard: function(label, value, colorClass) {
    return '<div class="bg-gray-900 rounded-lg p-3 border border-gray-800">' +
      '<div class="text-[10px] text-gray-500 uppercase">' + label + '</div>' +
      '<div class="text-lg font-bold ' + (colorClass || 'text-white') + '">' + value + '</div>' +
    '</div>';
  },

  playerDisplay: function(p) {
    var firstName = (p && p.first_name) ? p.first_name : "";
    var lastName = (p && p.last_name) ? p.last_name : "";
    var name = [firstName, lastName].filter(Boolean).join(" ").trim() || "Unknown Player";

    var posPrimary = (p && p.position) ? p.position : "?";
    // If Sleeper provides multiple fantasy positions (e.g., DL/LB), show them as a combo on the card
    var posCombo = posPrimary;
    if (p && Array.isArray(p.fantasy_positions) && p.fantasy_positions.length) {
      posPrimary = posPrimary !== "?" ? posPrimary : p.fantasy_positions[0];
      if (p.fantasy_positions.length > 1) posCombo = p.fantasy_positions.join("/");
      else posCombo = p.fantasy_positions[0];
    }

    // Subcategory / depth-chart position (e.g., DL (DE), LB (OLB), DB (CB))
    var subPos = (p && (p.depth_chart_position || p.depth_chart_pos)) ? (p.depth_chart_position || p.depth_chart_pos) : "";
    if (typeof subPos === "string") subPos = subPos.trim().toUpperCase();
    if (subPos && subPos !== "NA" && subPos !== "N/A" && subPos !== posPrimary && (posCombo || "").indexOf(subPos) < 0) {
      posCombo = posCombo + " (" + subPos + ")";
    }

    return {
      name: name,
      pos: posCombo,
      posPrimary: posPrimary,
      team: (p && p.team) ? p.team : "FA",
      age: this.playerAge(p)
    };
  },
  // Roster naming helpers: "Account - Team Name"
  getRosterTeamName: function(roster) {
    if (!roster) return "";
    var m = roster.metadata || roster.meta || {};
    var tn = m.team_name || m.teamName || m.name || m.team || "";
    if (typeof tn === "string") tn = tn.trim();
    if (!tn) {
      var s = roster.settings || {};
      tn = s.team_name || s.teamName || s.name || "";
      if (typeof tn === "string") tn = tn.trim();
    }
    return tn || "";
  },

  getRosterAccountName: function(roster) {
    if (!roster) return "";
    var u = this.data && this.data.usersById ? this.data.usersById[roster.owner_id] : null;
    var acct = (u && (u.display_name || u.username || u.name)) ? (u.display_name || u.username || u.name) : ("Team " + roster.roster_id);
    if (typeof acct === "string") acct = acct.trim();
    return acct || ("Team " + roster.roster_id);
  },

  rosterLabel: function(roster) {
    if (!roster) return "";
    var acct = this.getRosterAccountName(roster);
    var tn = this.getRosterTeamName(roster);
    return tn ? (acct + " - " + tn) : acct;
  },




  // Compute age from Sleeper birth_date (YYYY-MM-DD). Returns integer years or null.
  computeAgeFromBirth: function(birthDateStr) {
    if (!birthDateStr || typeof birthDateStr !== "string") return null;
    var parts = birthDateStr.split("-");
    if (parts.length < 3) return null;
    var y = parseInt(parts[0], 10), m = parseInt(parts[1], 10), d = parseInt(parts[2], 10);
    if (!isFinite(y) || !isFinite(m) || !isFinite(d)) return null;
    var now = new Date();
    var age = now.getFullYear() - y;
    var birthdayThisYear = new Date(now.getFullYear(), m - 1, d);
    if (now < birthdayThisYear) age -= 1;
    return (age >= 0 && age <= 60) ? age : null;
  },

  playerAge: function(p) {
    if (!p) return null;
    if (typeof p._age === "number") return p._age;
    var bd = p.birth_date || p.birthDate || null;
    var a = this.computeAgeFromBirth(bd);
    if (typeof a === "number") p._age = a;
    return a;
  },

  // Effective season/week handling: in the NFL offseason Sleeper's /state/nfl may advance to the next season (week 1),
  // but a fantasy league remains tied to its league.season. Prefer league.season whenever available.
  getSeason: function() {
    if (this.data.appSeason != null) return String(this.data.appSeason);
    if (this.data.league && this.data.league.season != null) return String(this.data.league.season);
    if (this.data.nflState && this.data.nflState.season != null) return String(this.data.nflState.season);
    return "2025";
  },

  getMaxWeek: function() {
    var w = (this.data.maxWeek != null) ? Number(this.data.maxWeek)
          : (this.ui && this.ui.selectedWeek != null) ? Number(this.ui.selectedWeek)
          : Number(this.getNflStateWeek());
    if (!isFinite(w) || w < 1) w = 1;
    if (w > 18) w = 18;
    return w;
  },

  // Find last week in this league that actually has matchup data (useful for offseason / historical leagues)
  findLastWeekWithMatchups: function(startWeek) {
    var self = this;
    var w0 = Number(startWeek);
    if (!isFinite(w0) || w0 < 1) w0 = 18;
    if (w0 > 18) w0 = 18;

    var tryWeek = function(w) {
      if (w < 1) return Promise.resolve(w0);
      return self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/matchups/" + w)
        .then(function(mu) {
          if (Array.isArray(mu) && mu.length) {
            self.data.weekMatchups[String(w)] = mu;
            return w;
          }
          return tryWeek(w - 1);
        })
        .catch(function() { return tryWeek(w - 1); });
    };
    return tryWeek(w0);
  },


  // Aggregate season stats for a player across all weeks
  getPlayerSeasonStats: function(pid) {
    var self = this;
    pid = String(pid);
    var weekStats = this.data.weekStats || {};
    var weekProj = this.data.weekProj || {};
    var agg = {
      games: 0,
      // Offensive
      rec: 0, rec_tgt: 0, rec_yd: 0, rec_td: 0, rec_20p: 0,
      rush_att: 0, rush_yd: 0, rush_td: 0, rush_20p: 0,
      pass_att: 0, pass_cmp: 0, pass_yd: 0, pass_td: 0, pass_int: 0,
      // IDP
      tkl: 0, tkl_solo: 0, tkl_ast: 0, tkl_loss: 0,
      sack: 0, qb_hit: 0, int: 0, pass_def: 0,
      ff: 0, fr: 0, def_td: 0, safe: 0,
      // Kicker
      fgm: 0, fga: 0, xpm: 0, xpa: 0,
      // Fantasy
      totalPts: 0
    };
    
    var currentWeek = Number(this.getMaxWeek());
    for (var w = 1; w <= currentWeek; w++) {
      var statsMap = weekStats[String(w)] || {};
      var projMapW = weekProj[String(w)] || {};
      var st = statsMap[pid];
      if (!st || Object.keys(st).length === 0) continue;
      
      agg.games++;
      agg.rec += st.rec || 0;
      agg.rec_tgt += st.rec_tgt || 0;
      agg.rec_yd += st.rec_yd || 0;
      agg.rec_td += st.rec_td || 0;
      agg.rec_20p += st.rec_20p || (st.rec_lng >= 20 ? 1 : 0);
      agg.rush_att += st.rush_att || 0;
      agg.rush_yd += st.rush_yd || 0;
      agg.rush_td += st.rush_td || 0;
      agg.rush_20p += st.rush_20p || (st.rush_lng >= 20 ? 1 : 0);
      agg.pass_att += st.pass_att || 0;
      agg.pass_cmp += st.pass_cmp || 0;
      agg.pass_yd += st.pass_yd || 0;
      agg.pass_td += st.pass_td || 0;
      agg.pass_int += st.pass_int || 0;
      agg.tkl += (st.tkl_solo || 0) + (st.tkl_ast || 0) + (st.tkl || 0);
      agg.tkl_solo += st.tkl_solo || 0;
      agg.tkl_ast += st.tkl_ast || 0;
      agg.tkl_loss += st.tkl_loss || 0;
      agg.sack += st.sack || 0;
      agg.qb_hit += st.qb_hit || 0;
      agg.int += st.int || 0;
      agg.pass_def += st.pass_def || 0;
      agg.ff += st.ff || 0;
      agg.fr += st.fr || 0;
      agg.def_td += st.def_td || 0;
      agg.safe += st.safe || 0;
      agg.fgm += st.fgm || 0;
      agg.fga += st.fga || 0;
      agg.xpm += st.xpm || 0;
      agg.xpa += st.xpa || 0;
      agg.totalPts += this.scoreFromStats(st, pid);
    }
    
    return agg;
  },

  // Calculate player efficiency metrics based on position
  getPlayerEfficiencyMetrics: function(pid, p) {
    var self = this;
    pid = String(pid);
    if (!p) p = this.data.playersById[pid] || {};
    
    var stats = this.getPlayerSeasonStats(pid);
    var g = stats.games || 1;
    var role = this.primaryRoleKeyForPlayer(p);
    
    var metrics = {
      games: stats.games,
      role: role
    };
    
    // Offensive metrics
    if (role === 'QB') {
      metrics.passYdPerGame = stats.pass_yd / g;
      metrics.passTdPerGame = stats.pass_td / g;
      metrics.intPerGame = stats.pass_int / g;
      metrics.cmpRate = stats.pass_att > 0 ? (stats.pass_cmp / stats.pass_att * 100) : 0;
      metrics.rushYdPerGame = stats.rush_yd / g;
      metrics.tdRate = (stats.pass_td + stats.rush_td) / g;
      metrics.label1 = { name: 'Cmp%', value: metrics.cmpRate.toFixed(0) + '%' };
      metrics.label2 = { name: 'TD/G', value: metrics.tdRate.toFixed(1) };
      metrics.label3 = { name: 'INT/G', value: metrics.intPerGame.toFixed(1) };
    } else if (role === 'RB') {
      metrics.rushYdPerGame = stats.rush_yd / g;
      metrics.rushTdPerGame = stats.rush_td / g;
      metrics.ypc = stats.rush_att > 0 ? (stats.rush_yd / stats.rush_att) : 0;
      metrics.tgtPerGame = stats.rec_tgt / g;
      metrics.recPerGame = stats.rec / g;
      metrics.catchRate = stats.rec_tgt > 0 ? (stats.rec / stats.rec_tgt * 100) : 0;
      metrics.tdRate = (stats.rush_td + stats.rec_td) / g;
      metrics.bigPlayRate = stats.rush_att > 0 ? ((stats.rush_20p + stats.rec_20p) / (stats.rush_att + stats.rec) * 100) : 0;
      metrics.label1 = { name: 'YPC', value: metrics.ypc.toFixed(1) };
      metrics.label2 = { name: 'Tgt/G', value: metrics.tgtPerGame.toFixed(1) };
      metrics.label3 = { name: 'TD/G', value: metrics.tdRate.toFixed(1) };
    } else if (role === 'WR' || role === 'TE') {
      metrics.tgtPerGame = stats.rec_tgt / g;
      metrics.recPerGame = stats.rec / g;
      metrics.recYdPerGame = stats.rec_yd / g;
      metrics.recTdPerGame = stats.rec_td / g;
      metrics.catchRate = stats.rec_tgt > 0 ? (stats.rec / stats.rec_tgt * 100) : 0;
      metrics.ypr = stats.rec > 0 ? (stats.rec_yd / stats.rec) : 0;
      metrics.tdRate = stats.rec_td / g;
      metrics.bigPlayRate = stats.rec > 0 ? (stats.rec_20p / stats.rec * 100) : 0;
      metrics.label1 = { name: 'Tgt/G', value: metrics.tgtPerGame.toFixed(1) };
      metrics.label2 = { name: 'Catch%', value: metrics.catchRate.toFixed(0) + '%' };
      metrics.label3 = { name: 'YPR', value: metrics.ypr.toFixed(1) };
    } else if (role === 'K') {
      metrics.fgmPerGame = stats.fgm / g;
      metrics.fgPct = stats.fga > 0 ? (stats.fgm / stats.fga * 100) : 0;
      metrics.xpmPerGame = stats.xpm / g;
      metrics.label1 = { name: 'FGM/G', value: metrics.fgmPerGame.toFixed(1) };
      metrics.label2 = { name: 'FG%', value: metrics.fgPct.toFixed(0) + '%' };
      metrics.label3 = { name: 'XPM/G', value: metrics.xpmPerGame.toFixed(1) };
    }
    // IDP metrics
    else if (role === 'DL' || role === 'LB' || role === 'DB') {
      metrics.tklPerGame = stats.tkl / g;
      metrics.tklSoloPerGame = stats.tkl_solo / g;
      metrics.tflPerGame = stats.tkl_loss / g;
      metrics.sackPerGame = stats.sack / g;
      metrics.qbHitPerGame = stats.qb_hit / g;
      metrics.intPerGame = stats.int / g;
      metrics.passDefPerGame = stats.pass_def / g;
      metrics.ffPerGame = stats.ff / g;
      
      // Disruption Score (weighted big plays)
      metrics.disruptionScore = ((stats.sack * 3) + (stats.tkl_loss * 2) + stats.qb_hit + stats.pass_def + (stats.ff * 2) + (stats.int * 3)) / g;
      
      // Big Play Rate (impact plays per game)
      metrics.bigPlayRate = (stats.sack + stats.int + stats.ff + stats.fr + stats.def_td) / g;
      
      // Pressure Rate (sacks + qb hits per game)
      metrics.pressureRate = (stats.sack + stats.qb_hit) / g;
      
      // Tackle Share - would need team totals, estimate as raw
      metrics.tackleShare = stats.tkl; // raw tackles (share would need team data)
      
      if (role === 'DL') {
        metrics.label1 = { name: 'Sack/G', value: metrics.sackPerGame.toFixed(2) };
        metrics.label2 = { name: 'Press/G', value: metrics.pressureRate.toFixed(1) };
        metrics.label3 = { name: 'Disrupt', value: metrics.disruptionScore.toFixed(1) };
      } else if (role === 'LB') {
        metrics.label1 = { name: 'Tkl/G', value: metrics.tklPerGame.toFixed(1) };
        metrics.label2 = { name: 'TFL/G', value: metrics.tflPerGame.toFixed(1) };
        metrics.label3 = { name: 'BigPlay', value: metrics.bigPlayRate.toFixed(1) };
      } else if (role === 'DB') {
        metrics.label1 = { name: 'INT/G', value: metrics.intPerGame.toFixed(2) };
        metrics.label2 = { name: 'PD/G', value: metrics.passDefPerGame.toFixed(1) };
        metrics.label3 = { name: 'Tkl/G', value: metrics.tklPerGame.toFixed(1) };
      }
    }
    
    return metrics;
  },

  // Get enhanced matchup info for a player against a defense
  getEnhancedMatchupInfo: function(pid, oppTeam) {
    var self = this;
    pid = String(pid);
    if (!oppTeam) return null;
    
    var p = this.data.playersById[pid] || {};
    var role = this.primaryRoleKeyForPlayer(p);
    if (!role) return null;
    
    var m = this.data.defRoleMetrics;
    if (!m || !m.roleRanks) return null;
    
    var info = (m.roleRanks[role] && m.roleRanks[role][oppTeam]) ? m.roleRanks[role][oppTeam] : null;
    if (!info) return null;
    
    var detailed = info.detailed || {};
    var result = {
      matchScore: info.matchScore || 0,
      ppg: info.ppg || 0,
      last4: info.last4 || 0,
      rank: info.rankMost || 16,
      ceilRate: info.ceilRate || 0,
      floorRate: info.floorRate || 0,
      top10Rate: info.top10Rate || 0,
      breakdown: info.matchScoreBreakdown || {},
      role: role
    };
    
    // Add position-specific matchup stats
    if (role === 'QB') {
      result.statLine = (detailed.passYdPerGame || 0).toFixed(0) + ' yd, ' + (detailed.passTdPerGame || 0).toFixed(1) + ' TD';
      result.keyMetric = { name: 'Pass Yd/G', value: (detailed.passYdPerGame || 0).toFixed(0) };
    } else if (role === 'RB') {
      result.statLine = (detailed.rushYdPerGame || 0).toFixed(0) + ' rush, ' + (detailed.tgtPerGame || 0).toFixed(1) + ' tgt';
      result.keyMetric = { name: 'Rush Yd/G', value: (detailed.rushYdPerGame || 0).toFixed(0) };
    } else if (role === 'WR' || role === 'TE') {
      result.statLine = (detailed.tgtPerGame || 0).toFixed(1) + ' tgt, ' + (detailed.catchRate || 0).toFixed(0) + '% catch';
      result.keyMetric = { name: 'Tgt/G', value: (detailed.tgtPerGame || 0).toFixed(1) };
    } else if (role === 'K') {
      result.statLine = (detailed.fgmPerGame || 0).toFixed(1) + ' FG, ' + (detailed.fgPct || 0).toFixed(0) + '%';
      result.keyMetric = { name: 'FGM/G', value: (detailed.fgmPerGame || 0).toFixed(1) };
    } else if (role === 'DL') {
      result.statLine = (detailed.sackPerGame || 0).toFixed(2) + ' sack, ' + (detailed.tklPerGame || 0).toFixed(1) + ' tkl';
      result.keyMetric = { name: 'Disrupt', value: (detailed.disruptionScore || 0).toFixed(1) };
    } else if (role === 'LB') {
      result.statLine = (detailed.tklPerGame || 0).toFixed(1) + ' tkl, ' + (detailed.sackPerGame || 0).toFixed(2) + ' sack';
      result.keyMetric = { name: 'Tkl/G', value: (detailed.tklPerGame || 0).toFixed(1) };
    } else if (role === 'DB') {
      result.statLine = (detailed.intPerGameDef || 0).toFixed(2) + ' INT, ' + (detailed.passDefPerGame || 0).toFixed(1) + ' PD';
      result.keyMetric = { name: 'INT/G', value: (detailed.intPerGameDef || 0).toFixed(2) };
    }
    
    return result;
  },

  // Role keys for defense-vs-role aggregation. Includes aggregates + depth-chart roles when available.
  roleKeysForPlayer: function(p) {
    // Returns simplified role categories: QB, RB, WR, TE, K, DL, LB, DB
    // Aggregates all variants into parent categories
    var roles = [];
    if (!p) return roles;

    var pos = (p.position || "").toUpperCase();
    var fpos = Array.isArray(p.fantasy_positions) ? p.fantasy_positions.map(function(x){return String(x||"").toUpperCase();}) : [];
    var depth = (p.depth_chart_position || p.depth_chart_pos || "").toString().trim().toUpperCase();

    // Offensive positions - map all variants to parent
    // QB
    if (pos === "QB" || fpos.indexOf("QB") >= 0) roles.push("QB");
    
    // RB (includes FB, HB variants)
    if (pos === "RB" || fpos.indexOf("RB") >= 0 || /^(FB|HB)$/.test(depth)) roles.push("RB");
    
    // WR - includes all WR variants (LWR, RWR, SWR, WR1, WR2, WR3, etc.)
    if (pos === "WR" || fpos.indexOf("WR") >= 0 || /WR|LWR|RWR|SWR/.test(depth)) roles.push("WR");
    
    // TE
    if (pos === "TE" || fpos.indexOf("TE") >= 0) roles.push("TE");
    
    // K (Kicker)
    if (pos === "K" || fpos.indexOf("K") >= 0 || /^(PK|K)$/.test(depth)) roles.push("K");

    // IDP positions - aggregate into DL, LB, DB
    // DL - includes DE, DT, NT, LDE, RDE, EDGE, IDL variants
    if (pos === "DL" || fpos.indexOf("DL") >= 0 || 
        /^(DE|DT|NT|LDE|RDE|EDGE|IDL|LE|RE|DLE|DRE)$/.test(pos) ||
        /DE|DT|NT|LDE|RDE|EDGE|IDL/.test(depth)) {
      roles.push("DL");
    }
    
    // LB - includes MLB, ILB, OLB, ROLB, LOLB variants
    if (pos === "LB" || fpos.indexOf("LB") >= 0 ||
        /^(MLB|ILB|OLB|ROLB|LOLB|RILB|LILB|WLB|SLB)$/.test(pos) ||
        /MLB|ILB|OLB|ROLB|LOLB/.test(depth)) {
      roles.push("LB");
    }
    
    // DB - includes CB, S, FS, SS variants
    if (pos === "DB" || fpos.indexOf("DB") >= 0 ||
        /^(CB|S|FS|SS|SCB|LCB|RCB|NB|SAF)$/.test(pos) ||
        /CB|FS|SS|^S$/.test(depth)) {
      roles.push("DB");
    }

    // Deduplicate
    var seen = {};
    var out = [];
    for (var i = 0; i < roles.length; i++) {
      var k = roles[i];
      if (!k) continue;
      if (!seen[k]) { seen[k] = true; out.push(k); }
    }
    return out;
  },

  // Build defense-vs-role fantasy points allowed (using this league's scoring).
  buildDefenseRoleMetrics: function() {
    var self = this;
    var currentWeek = Number(this.getMaxWeek());
    var schedule = this.nflSchedule || {};
    var weekStats = this.data.weekStats || {};
    var weekProj = this.data.weekProj || {};
    var players = this.data.playersById || {};

    var defTeams = Object.keys(schedule);
    var defGames = {};
    defTeams.forEach(function(t) {
      var arr = schedule[t] || [];
      var g = 0;
      for (var w = 1; w <= currentWeek; w++) {
        var opp = arr[w - 1];
        if (opp && opp !== "BYE") g++;
      }
      defGames[t] = g;
    });

    var weeklyRoleRaw = {}; // role -> DEF -> week -> [player fantasy points]
    var weeklyRoleStats = {}; // role -> DEF -> week -> [{ pts, stats object }] for detailed analysis
    var roleSet = {};

    // Aggregate: use player stats for team, map to opponent DEF for that week.
    for (var w = 1; w <= currentWeek; w++) {
      var statsMap = weekStats[String(w)] || {};
      var projMapW = weekProj[String(w)] || {};
      var pids = Object.keys(statsMap);
      for (var i = 0; i < pids.length; i++) {
        var pid = String(pids[i]);
        var st = statsMap[pid];
        if (!st || Object.keys(st).length === 0) continue;

        // Do not filter by projections here; projections can be missing/0 for real games.
var p = players[pid];
        if (!p || !p.team) continue;

        var team = String(p.team).toUpperCase();
        var oppArr = schedule[team];
        if (!oppArr || !oppArr.length) continue;

        var opp = oppArr[w - 1];
        if (!opp || opp === "BYE") continue;

        var pts = self.scoreFromStats(st, pid);
        if (!isFinite(pts)) continue;

        var roles = self.roleKeysForPlayer(p);
        for (var r = 0; r < roles.length; r++) {
          var role = roles[r];
          if (!role) continue;
          role = String(role).toUpperCase();
          roleSet[role] = true;
          if (!weeklyRoleRaw[role]) weeklyRoleRaw[role] = {};
          if (!weeklyRoleRaw[role][opp]) weeklyRoleRaw[role][opp] = {};
          if (!weeklyRoleRaw[role][opp][w]) weeklyRoleRaw[role][opp][w] = [];
          weeklyRoleRaw[role][opp][w].push(pts);
          
          // Also store detailed stats for analysis
          if (!weeklyRoleStats[role]) weeklyRoleStats[role] = {};
          if (!weeklyRoleStats[role][opp]) weeklyRoleStats[role][opp] = {};
          if (!weeklyRoleStats[role][opp][w]) weeklyRoleStats[role][opp][w] = [];
          weeklyRoleStats[role][opp][w].push({
            pts: pts,
            pid: pid,
            // Offensive stats
            rec: st.rec || 0,
            rec_tgt: st.rec_tgt || 0,
            rec_yd: st.rec_yd || 0,
            rec_td: st.rec_td || 0,
            rec_20p: st.rec_20p || st.rec_lng >= 20 ? 1 : 0,
            rush_att: st.rush_att || 0,
            rush_yd: st.rush_yd || 0,
            rush_td: st.rush_td || 0,
            rush_20p: st.rush_20p || st.rush_lng >= 20 ? 1 : 0,
            pass_att: st.pass_att || 0,
            pass_cmp: st.pass_cmp || 0,
            pass_yd: st.pass_yd || 0,
            pass_td: st.pass_td || 0,
            pass_int: st.pass_int || 0,
            // IDP stats
            tkl: (st.tkl_solo || 0) + (st.tkl_ast || 0) + (st.tkl || 0),
            tkl_solo: st.tkl_solo || 0,
            tkl_ast: st.tkl_ast || 0,
            tkl_loss: st.tkl_loss || 0,
            sack: st.sack || 0,
            qb_hit: st.qb_hit || 0,
            int: st.int || 0,
            pass_def: st.pass_def || 0,
            ff: st.ff || 0,
            fr: st.fr || 0,
            def_td: st.def_td || 0,
            safe: st.safe || 0,
            // Kicker stats
            fgm: st.fgm || 0,
            fga: st.fga || 0,
            xpm: st.xpm || 0,
            xpa: st.xpa || 0
          });
        }
      }
    }

    var rolesList = Object.keys(roleSet).sort();
    // Keep the UI focused on 8 main fantasy-relevant role categories
    var KEEP_ROLES = { QB:1, RB:1, WR:1, TE:1, K:1, DL:1, LB:1, DB:1 };
    rolesList = rolesList.filter(function(r){ r = String(r||'').toUpperCase(); return KEEP_ROLES[r]; });
    if (!rolesList.length) {
      this.data.defRoleMetrics = { maxWeek: currentWeek, defTeams: defTeams, defGames: defGames, roles: [], weeklyRole: {}, roleRanks: {} };
      return Promise.resolve();
    }

    // Helpers
    var clamp = function(x, a, b) { return Math.max(a, Math.min(b, x)); };
    var avg = function(arr) { if (!arr || !arr.length) return 0; var s = 0; for (var i = 0; i < arr.length; i++) s += arr[i]; return s / arr.length; };
    var stdev = function(arr) {
      if (!arr || arr.length < 2) return 0;
      var m = avg(arr);
      var ss = 0;
      for (var i = 0; i < arr.length; i++) { var dx = arr[i] - m; ss += dx * dx; }
      return Math.sqrt(ss / (arr.length - 1));
    };
    var percentileSorted = function(sortedArr, p) {
      if (!sortedArr || !sortedArr.length) return 0;
      var idx = (sortedArr.length - 1) * p;
      var lo = Math.floor(idx), hi = Math.ceil(idx);
      if (lo === hi) return sortedArr[lo];
      var w = idx - lo;
      return sortedArr[lo] * (1 - w) + sortedArr[hi] * w;
    };

    // Role bucket for share calculation - simplified
    var roleBucket = function(role) {
      role = String(role || "").toUpperCase();
      if (role === "QB" || role === "RB" || role === "WR" || role === "TE" || role === "K") return "OFF";
      if (role === "DL") return "DL";
      if (role === "LB") return "LB";
      if (role === "DB") return "DB";
      return "OTHER";
    };

    // How many top scorers to average for each role per game
    // This represents typical starter counts
    // Dynamic "starter-equivalent" top-N based on your league's configured starter slots.
// This keeps Defense vs Role Effectiveness comparable to Positional Scoring Baselines.
var roleTopN = function(role) {
      var FIXED = { 
        QB: 1, 
        RB: 2, 
        WR: 2, 
        TE: 1, 
        K: 1, 
        DL: 2, 
        LB: 2, 
        DB: 2 
      };
      
      role = String(role || "").toUpperCase();
      return FIXED[role] || 1; // Default to 1 if role is unknown
    };
    // Average the top N scorers for a role in a given week
    // This gives a "starter-equivalent" value
    var starterVal = function(list, role) {
      if (!list || !list.length) return null;
      var n = roleTopN(role);
      var arr = list.slice().sort(function(a,b){ return b - a; });
      var take = Math.min(n, arr.length);
      var sum = 0;
      for (var i = 0; i < take; i++) sum += arr[i];
      return sum / take;
    };

    var weeklyRole = {}; // role -> DEF -> week -> starter-equivalent points
    rolesList.forEach(function(role) {
      weeklyRole[role] = {};
      defTeams.forEach(function(defTeam) {
        var raw = (weeklyRoleRaw[role] && weeklyRoleRaw[role][defTeam]) ? weeklyRoleRaw[role][defTeam] : {};
        var map = {};
        for (var wk = 1; wk <= currentWeek; wk++) {
          var arr = raw[wk];
          if (!arr || !arr.length) continue;
          var v = starterVal(arr, role);
          if (v == null) continue;
          map[wk] = v;
        }
        weeklyRole[role][defTeam] = map;
      });
    });

    // Build per-role per-team weekly arrays (skip games with no data)
    var roleTeamVals = {}; // role -> team -> [vals per game (no byes)]
    var roleDist = {};     // role -> all weekly vals across teams
    rolesList.forEach(function(role) {
      roleTeamVals[role] = {};
      roleDist[role] = [];
      defTeams.forEach(function(defTeam) {
        var arr = schedule[defTeam] || [];
        var wmap = (weeklyRole[role] && weeklyRole[role][defTeam]) ? weeklyRole[role][defTeam] : {};
        var vals = [];
        for (var wk = 1; wk <= currentWeek; wk++) {
          var opp = arr[wk - 1];
          if (!opp || opp === "BYE") continue;
          if (wmap[wk] != null) vals.push(wmap[wk]);
        }
        roleTeamVals[role][defTeam] = vals;
        for (var k = 0; k < vals.length; k++) roleDist[role].push(vals[k]);
      });
    });

    // Role distribution thresholds (for ceiling/floor rates)
    var roleThresholds = {}; // role -> {p25, p75, iqr}
    rolesList.forEach(function(role) {
      var dist = (roleDist[role] || []).slice().sort(function(a,b){ return a - b; });
      var p25 = percentileSorted(dist, 0.25);
      var p75 = percentileSorted(dist, 0.75);
      roleThresholds[role] = { p25: p25, p75: p75, iqr: (p75 - p25) || 1 };
    });

    // Top-10 weekly generosity rate by role
    var top10Counts = {}; // role -> team -> count
    rolesList.forEach(function(role) {
      top10Counts[role] = {};
      defTeams.forEach(function(t){ top10Counts[role][t] = 0; });
    });

    for (var wk = 1; wk <= currentWeek; wk++) {
      rolesList.forEach(function(role) {
        var list = [];
        defTeams.forEach(function(defTeam) {
          var arr = schedule[defTeam] || [];
          var opp = arr[wk - 1];
          if (!opp || opp === "BYE") return;
          var val = (weeklyRole[role] && weeklyRole[role][defTeam] && (weeklyRole[role][defTeam][wk] != null)) ? weeklyRole[role][defTeam][wk] : null;
          if (val == null) return;
          list.push({ team: defTeam, val: val });
        });
        list.sort(function(a,b){ return b.val - a.val; });
        var topN = Math.min(10, list.length);
        for (var i2 = 0; i2 < topN; i2++) top10Counts[role][list[i2].team] += 1;
      });
    }

    // Totals by defense + role (for concentration/share)
    var defTotalsByRole = {};
    defTeams.forEach(function(t){ defTotalsByRole[t] = {}; });
    rolesList.forEach(function(role) {
      defTeams.forEach(function(defTeam) {
        var vals = roleTeamVals[role][defTeam] || [];
        var total = 0;
        for (var i3 = 0; i3 < vals.length; i3++) total += vals[i3];
        defTotalsByRole[defTeam][role] = total;
      });
    });

    var denomForShare = function(defTeam, role) {
      var b = roleBucket(role);
      if (b === "OFF") {
        // For offensive positions, share is relative to total offensive fantasy points allowed
        return (defTotalsByRole[defTeam]["QB"] || 0) + (defTotalsByRole[defTeam]["RB"] || 0) + (defTotalsByRole[defTeam]["WR"] || 0) + (defTotalsByRole[defTeam]["TE"] || 0) + (defTotalsByRole[defTeam]["K"] || 0);
      }
      if (b === "DL") return (defTotalsByRole[defTeam]["DL"] || 0);
      if (b === "LB") return (defTotalsByRole[defTeam]["LB"] || 0);
      if (b === "DB") return (defTotalsByRole[defTeam]["DB"] || 0);
      return 0;
    };

    // Build role ranks + derived metrics with enhanced stats
    var roleRanks = {}; // role -> defTeam -> {ppg,last4,vol,g,rankMost,rankLeast,ceilRate,floorRate,top10Rate,share,matchScore, + detailed stats}
    var roleDetailedStats = {}; // role -> defTeam -> aggregated detailed stats
    
    rolesList.forEach(function(role) {
      roleRanks[role] = {};
      roleDetailedStats[role] = {};
      var rows = [];
      
      defTeams.forEach(function(defTeam) {
        var vals = roleTeamVals[role][defTeam] || [];
        var g = vals.length;
        if (!g) return;

        var total = 0;
        for (var i4 = 0; i4 < vals.length; i4++) total += vals[i4];
        var ppg = total / g;

        var last4 = 0;
        if (vals.length) {
          var s = 0;
          var start = Math.max(0, vals.length - 4);
          var slice = vals.slice(start);
          for (var j = 0; j < slice.length; j++) s += slice[j];
          last4 = s / slice.length;
        }

        var vol = stdev(vals);
        
        // Aggregate detailed stats from weeklyRoleStats
        var detailedAgg = {
          rec: 0, rec_tgt: 0, rec_yd: 0, rec_td: 0, rec_20p: 0,
          rush_att: 0, rush_yd: 0, rush_td: 0, rush_20p: 0,
          pass_att: 0, pass_cmp: 0, pass_yd: 0, pass_td: 0, pass_int: 0,
          tkl: 0, tkl_solo: 0, tkl_loss: 0, sack: 0, qb_hit: 0,
          int: 0, pass_def: 0, ff: 0, fr: 0, def_td: 0,
          fgm: 0, fga: 0, xpm: 0, xpa: 0,
          totalPlayers: 0, gamesWithData: 0
        };
        
        var defWeeklyStats = (weeklyRoleStats[role] && weeklyRoleStats[role][defTeam]) || {};
        for (var wk = 1; wk <= currentWeek; wk++) {
          var weekData = defWeeklyStats[wk] || [];
          if (weekData.length > 0) {
            detailedAgg.gamesWithData++;
            // Sum stats for top performers each week (use roleTopN)
            var sorted = weekData.slice().sort(function(a,b){ return b.pts - a.pts; });
            var take = Math.min(roleTopN(role), sorted.length);
            for (var t = 0; t < take; t++) {
              var ps = sorted[t];
              detailedAgg.rec += ps.rec || 0;
              detailedAgg.rec_tgt += ps.rec_tgt || 0;
              detailedAgg.rec_yd += ps.rec_yd || 0;
              detailedAgg.rec_td += ps.rec_td || 0;
              detailedAgg.rec_20p += ps.rec_20p || 0;
              detailedAgg.rush_att += ps.rush_att || 0;
              detailedAgg.rush_yd += ps.rush_yd || 0;
              detailedAgg.rush_td += ps.rush_td || 0;
              detailedAgg.rush_20p += ps.rush_20p || 0;
              detailedAgg.pass_att += ps.pass_att || 0;
              detailedAgg.pass_cmp += ps.pass_cmp || 0;
              detailedAgg.pass_yd += ps.pass_yd || 0;
              detailedAgg.pass_td += ps.pass_td || 0;
              detailedAgg.pass_int += ps.pass_int || 0;
              detailedAgg.tkl += ps.tkl || 0;
              detailedAgg.tkl_solo += ps.tkl_solo || 0;
              detailedAgg.tkl_loss += ps.tkl_loss || 0;
              detailedAgg.sack += ps.sack || 0;
              detailedAgg.qb_hit += ps.qb_hit || 0;
              detailedAgg.int += ps.int || 0;
              detailedAgg.pass_def += ps.pass_def || 0;
              detailedAgg.ff += ps.ff || 0;
              detailedAgg.fr += ps.fr || 0;
              detailedAgg.def_td += ps.def_td || 0;
              detailedAgg.fgm += ps.fgm || 0;
              detailedAgg.fga += ps.fga || 0;
              detailedAgg.xpm += ps.xpm || 0;
              detailedAgg.xpa += ps.xpa || 0;
              detailedAgg.totalPlayers++;
            }
          }
        }
        
        // Calculate per-game averages
        var gwd = detailedAgg.gamesWithData || 1;
        var detailed = {
          // Receiving stats (WR/TE/RB)
          tgtPerGame: detailedAgg.rec_tgt / gwd,
          recPerGame: detailedAgg.rec / gwd,
          recYdPerGame: detailedAgg.rec_yd / gwd,
          catchRate: detailedAgg.rec_tgt > 0 ? (detailedAgg.rec / detailedAgg.rec_tgt * 100) : 0,
          ypc: detailedAgg.rec > 0 ? (detailedAgg.rec_yd / detailedAgg.rec) : 0,
          recTdPerGame: detailedAgg.rec_td / gwd,
          bigPlayRecRate: detailedAgg.rec > 0 ? (detailedAgg.rec_20p / detailedAgg.rec * 100) : 0,
          // Rushing stats (RB/QB)
          rushAttPerGame: detailedAgg.rush_att / gwd,
          rushYdPerGame: detailedAgg.rush_yd / gwd,
          ypc_rush: detailedAgg.rush_att > 0 ? (detailedAgg.rush_yd / detailedAgg.rush_att) : 0,
          rushTdPerGame: detailedAgg.rush_td / gwd,
          bigPlayRushRate: detailedAgg.rush_att > 0 ? (detailedAgg.rush_20p / detailedAgg.rush_att * 100) : 0,
          // Passing stats (QB)
          passAttPerGame: detailedAgg.pass_att / gwd,
          passCmpPerGame: detailedAgg.pass_cmp / gwd,
          passYdPerGame: detailedAgg.pass_yd / gwd,
          cmpRate: detailedAgg.pass_att > 0 ? (detailedAgg.pass_cmp / detailedAgg.pass_att * 100) : 0,
          passTdPerGame: detailedAgg.pass_td / gwd,
          intPerGame: detailedAgg.pass_int / gwd,
          // IDP stats (DL/LB/DB)
          tklPerGame: detailedAgg.tkl / gwd,
          tklSoloPerGame: detailedAgg.tkl_solo / gwd,
          tflPerGame: detailedAgg.tkl_loss / gwd,
          sackPerGame: detailedAgg.sack / gwd,
          qbHitPerGame: detailedAgg.qb_hit / gwd,
          pressurePerGame: (detailedAgg.sack + detailedAgg.qb_hit) / gwd,
          intPerGameDef: detailedAgg.int / gwd,
          passDefPerGame: detailedAgg.pass_def / gwd,
          ffPerGame: detailedAgg.ff / gwd,
          frPerGame: detailedAgg.fr / gwd,
          defTdPerGame: detailedAgg.def_td / gwd,
          // Derived IDP metrics
          disruptionScore: ((detailedAgg.sack * 3) + (detailedAgg.tkl_loss * 2) + detailedAgg.qb_hit + detailedAgg.pass_def + (detailedAgg.ff * 2) + (detailedAgg.int * 3)) / gwd,
          bigPlayIdpRate: gwd > 0 ? ((detailedAgg.sack + detailedAgg.int + detailedAgg.ff + detailedAgg.fr + detailedAgg.def_td) / gwd) : 0,
          // Kicker stats
          fgmPerGame: detailedAgg.fgm / gwd,
          fgaPerGame: detailedAgg.fga / gwd,
          fgPct: detailedAgg.fga > 0 ? (detailedAgg.fgm / detailedAgg.fga * 100) : 0,
          xpmPerGame: detailedAgg.xpm / gwd,
          // TD rate
          tdRate: gwd > 0 ? ((detailedAgg.rec_td + detailedAgg.rush_td + detailedAgg.pass_td) / gwd) : 0
        };
        
        roleDetailedStats[role][defTeam] = detailed;

        roleRanks[role][defTeam] = { ppg: ppg, last4: last4, vol: vol, g: g };
        rows.push({ team: defTeam, ppg: ppg });
      });

      // Rank: most generous (higher ppg) is rankMost=1
      rows.slice().sort(function(a,b){ return b.ppg - a.ppg; }).forEach(function(row, idx) {
        roleRanks[role][row.team].rankMost = idx + 1;
      });
      // Rank: least generous (lower ppg) is rankLeast=1
      rows.slice().sort(function(a,b){ return a.ppg - b.ppg; }).forEach(function(row, idx) {
        roleRanks[role][row.team].rankLeast = idx + 1;
      });

      var thr = roleThresholds[role] || { p25: 0, p75: 0, iqr: 1 };
      var N = rows.length || 1;

      defTeams.forEach(function(defTeam) {
        var entry = roleRanks[role][defTeam];
        if (!entry || !entry.g) return;

        var vals = roleTeamVals[role][defTeam] || [];
        var ceilCnt = 0, floorCnt = 0;
        for (var i5 = 0; i5 < vals.length; i5++) {
          if (vals[i5] >= thr.p75) ceilCnt++;
          if (vals[i5] <= thr.p25) floorCnt++;
        }

        var top10 = top10Counts[role] ? (top10Counts[role][defTeam] || 0) : 0;
        var denom = denomForShare(defTeam, role);
        var totalRole = defTotalsByRole[defTeam] ? (defTotalsByRole[defTeam][role] || 0) : 0;

        entry.ceilRate = entry.g ? (ceilCnt / entry.g) : 0;
        entry.floorRate = entry.g ? (floorCnt / entry.g) : 0;
        entry.top10Rate = entry.g ? (top10 / entry.g) : 0;
        entry.share = (denom > 0) ? (totalRole / denom) : null;
        
        // Add detailed stats reference
        entry.detailed = roleDetailedStats[role][defTeam] || {};

        // ENHANCED Matchup Score (0-100) incorporating multiple factors
        var base = (N > 1 && entry.rankMost) ? (100 * ((N - entry.rankMost) / (N - 1))) : 50;
        var trend = (entry.last4 - entry.ppg) / (thr.iqr || 1); // + means getting more generous lately
        var ceilBonus = entry.ceilRate * 15; // Bonus for ceiling upside
        var floorPenalty = entry.floorRate * 10; // Penalty for floor risk
        var consistencyBonus = (1 - Math.min(entry.vol / (entry.ppg || 1), 1)) * 10; // Lower volatility = better
        var top10Bonus = entry.top10Rate * 20; // Bonus for being in weekly top 10
        
        var score = clamp(base + (trend * 10) + ceilBonus - floorPenalty + consistencyBonus + top10Bonus, 0, 100);
        entry.matchScore = Math.round(score * 10) / 10;
        
        // Also store component breakdown for transparency
        entry.matchScoreBreakdown = {
          base: Math.round(base * 10) / 10,
          trend: Math.round(trend * 10 * 10) / 10,
          ceilBonus: Math.round(ceilBonus * 10) / 10,
          floorPenalty: Math.round(floorPenalty * 10) / 10,
          consistencyBonus: Math.round(consistencyBonus * 10) / 10,
          top10Bonus: Math.round(top10Bonus * 10) / 10
        };
      });
    });

    this.data.defRoleMetrics = {
      maxWeek: currentWeek,
      defTeams: defTeams,
      defGames: defGames,
      roles: rolesList,
      weeklyRole: weeklyRole,
      weeklyRoleStats: weeklyRoleStats,
      roleRanks: roleRanks,
      roleTopN: roleTopN,
      roleDetailedStats: roleDetailedStats,
      roleThresholds: roleThresholds,
      top10Counts: top10Counts,
      defTotalsByRole: defTotalsByRole
    };

    return Promise.resolve();
  },

  getDefenseRoleInfo: function(oppTeam, roleKey) {
    var m = this.data.defRoleMetrics;
    if (!m || !m.roleRanks || !oppTeam || !roleKey) return null;
    var role = String(roleKey).toUpperCase();
    var team = String(oppTeam).toUpperCase();
    var info = (m.roleRanks[role] && m.roleRanks[role][team]) ? m.roleRanks[role][team] : null;
    return info || null;
  },

  primaryRoleKeyForPlayer: function(p) {
    // Returns the primary fantasy position category: QB, RB, WR, TE, K, DL, LB, DB
    if (!p) return null;
    var pos = (p.position || "").toString().trim().toUpperCase();
    var fpos = Array.isArray(p.fantasy_positions) ? p.fantasy_positions.map(function(x){return String(x||"").toUpperCase();}) : [];
    var depth = (p.depth_chart_position || p.depth_chart_pos || "").toString().trim().toUpperCase();

    // Offensive positions
    var off = ["QB","RB","WR","TE","K"];
    for (var i = 0; i < off.length; i++) {
      if (pos === off[i] || fpos.indexOf(off[i]) >= 0) return off[i];
    }
    
    // WR variants map to WR
    if (/WR|LWR|RWR|SWR/.test(depth)) return "WR";
    
    // DL - all defensive line variants
    if (pos === "DL" || fpos.indexOf("DL") >= 0 || /DE|DT|NT|LDE|RDE|EDGE|IDL/.test(depth)) return "DL";
    
    // LB - all linebacker variants
    if (pos === "LB" || fpos.indexOf("LB") >= 0 || /MLB|ILB|OLB|ROLB|LOLB/.test(depth)) return "LB";
    
    // DB - all defensive back variants
    if (pos === "DB" || fpos.indexOf("DB") >= 0 || /CB|FS|SS|^S$/.test(depth)) return "DB";

    return pos || null;
  },

  renderDefenseRoleEffectiveness: function() {
    if (!this.dom.defRoleSelect || !this.dom.defRoleTableBody) return;
    var m = this.data.defRoleMetrics;
    if (!m || !m.roles || !m.roles.length) {
      this.dom.defRoleTableBody.innerHTML = '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="13">Defense role metrics not ready yet.</td></tr>';
      return;
    }

    // Sort roles in a logical fantasy order
    var roleOrder = ['QB', 'RB', 'WR', 'TE', 'K', 'DL', 'LB', 'DB'];
    var sortedRoles = m.roles.slice().sort(function(a, b) {
      var ia = roleOrder.indexOf(a);
      var ib = roleOrder.indexOf(b);
      ia = ia === -1 ? 999 : ia;
      ib = ib === -1 ? 999 : ib;
      return ia - ib;
    });

    if (!this.ui.defRoleKey) this.ui.defRoleKey = (sortedRoles.indexOf("RB") >= 0) ? "RB" : sortedRoles[0];
    if (!this.ui.defRoleSort) this.ui.defRoleSort = "most";

    if (!this.dom.defRoleSelect._populated) {
      var sel = this.dom.defRoleSelect;
      sel.innerHTML = "";
      sortedRoles.forEach(function(role) {
        var opt = document.createElement("option");
        opt.value = role;
        opt.textContent = role;
        sel.appendChild(opt);
      });
      sel.value = this.ui.defRoleKey;
      this.dom.defRoleSelect._populated = true;
    } else {
      this.dom.defRoleSelect.value = this.ui.defRoleKey;
    }

    if (this.dom.defRoleModeMost && this.dom.defRoleModeLeast) {
      var mostActive = this.ui.defRoleSort === "most";
      this.dom.defRoleModeMost.className = mostActive
        ? "px-3 py-2 rounded-lg bg-gray-800 text-xs font-mono text-white border border-gray-700 hover:bg-gray-700"
        : "px-3 py-2 rounded-lg bg-gray-900 text-xs font-mono text-gray-300 border border-gray-800 hover:bg-gray-800 hover:text-white";
      this.dom.defRoleModeLeast.className = (!mostActive)
        ? "px-3 py-2 rounded-lg bg-gray-800 text-xs font-mono text-white border border-gray-700 hover:bg-gray-700"
        : "px-3 py-2 rounded-lg bg-gray-900 text-xs font-mono text-gray-300 border border-gray-800 hover:bg-gray-800 hover:text-white";
    }

    var roleKey = this.ui.defRoleKey;
    var weekly = (m.weeklyRole && m.weeklyRole[roleKey]) ? m.weeklyRole[roleKey] : {};
    var schedule = this.nflSchedule || {};
    var maxWeek = m.maxWeek;
    
    // Define position-specific stat columns
    var statCols = {
      QB: [
        { key: 'passYdPerGame', label: 'Pass Yd', fmt: function(v) { return v.toFixed(0); } },
        { key: 'passTdPerGame', label: 'Pass TD', fmt: function(v) { return v.toFixed(1); } },
        { key: 'intPerGame', label: 'INT', fmt: function(v) { return v.toFixed(1); } }
      ],
      RB: [
        { key: 'rushYdPerGame', label: 'Rush Yd', fmt: function(v) { return v.toFixed(0); } },
        { key: 'rushTdPerGame', label: 'Rush TD', fmt: function(v) { return v.toFixed(1); } },
        { key: 'tgtPerGame', label: 'Tgt/G', fmt: function(v) { return v.toFixed(1); } }
      ],
      WR: [
        { key: 'tgtPerGame', label: 'Tgt/G', fmt: function(v) { return v.toFixed(1); } },
        { key: 'recYdPerGame', label: 'Rec Yd', fmt: function(v) { return v.toFixed(0); } },
        { key: 'recTdPerGame', label: 'Rec TD', fmt: function(v) { return v.toFixed(1); } }
      ],
      TE: [
        { key: 'tgtPerGame', label: 'Tgt/G', fmt: function(v) { return v.toFixed(1); } },
        { key: 'recYdPerGame', label: 'Rec Yd', fmt: function(v) { return v.toFixed(0); } },
        { key: 'recTdPerGame', label: 'Rec TD', fmt: function(v) { return v.toFixed(1); } }
      ],
      K: [
        { key: 'fgmPerGame', label: 'FGM', fmt: function(v) { return v.toFixed(1); } },
        { key: 'fgPct', label: 'FG%', fmt: function(v) { return v.toFixed(0) + '%'; } },
        { key: 'xpmPerGame', label: 'XPM', fmt: function(v) { return v.toFixed(1); } }
      ],
      DL: [
        { key: 'sackPerGame', label: 'Sack', fmt: function(v) { return v.toFixed(2); } },
        { key: 'tklPerGame', label: 'Tkl', fmt: function(v) { return v.toFixed(1); } },
        { key: 'disruptionScore', label: 'Disrupt', fmt: function(v) { return v.toFixed(1); } }
      ],
      LB: [
        { key: 'tklPerGame', label: 'Tkl', fmt: function(v) { return v.toFixed(1); } },
        { key: 'sackPerGame', label: 'Sack', fmt: function(v) { return v.toFixed(2); } },
        { key: 'passDefPerGame', label: 'PD', fmt: function(v) { return v.toFixed(1); } }
      ],
      DB: [
        { key: 'intPerGameDef', label: 'INT', fmt: function(v) { return v.toFixed(2); } },
        { key: 'passDefPerGame', label: 'PD', fmt: function(v) { return v.toFixed(1); } },
        { key: 'tklPerGame', label: 'Tkl', fmt: function(v) { return v.toFixed(1); } }
      ]
    };
    
    var cols = statCols[roleKey] || statCols.RB;
    
    // Update column headers dynamically
    var col1 = document.getElementById('defRoleStatCol1');
    var col2 = document.getElementById('defRoleStatCol2');
    var col3 = document.getElementById('defRoleStatCol3');
    if (col1) col1.textContent = cols[0].label;
    if (col2) col2.textContent = cols[1].label;
    if (col3) col3.textContent = cols[2].label;

    var rows = [];
    for (var i = 0; i < m.defTeams.length; i++) {
      var defTeam = m.defTeams[i];
      var g = m.defGames[defTeam] || 0;
      if (!g) continue;

      var wmap = weekly[defTeam] || {};
      var total = 0;
      var gamePts = [];
      var gameWeeks = []; // Track which weeks have data
      var arr = schedule[defTeam] || [];
      for (var wk = 1; wk <= maxWeek; wk++) {
        if (arr[wk - 1] === "BYE") continue;
        var val = (wmap && (wmap[wk] != null)) ? wmap[wk] : null;
        if (val == null) continue;
        total += val;
        gamePts.push(val);
        gameWeeks.push(wk);
      }
      if (!gamePts.length) continue;
      var gUsed = gamePts.length;
      var ppg = total / gUsed;
      g = gUsed;

      var last4 = 0;
      var last4Vals = [];
      var last4Wks = [];
      if (gamePts.length) {
        var start = Math.max(0, gamePts.length - 4);
        var slice = gamePts.slice(start);
        last4Vals = slice.slice(); // Copy for tooltip
        last4Wks = gameWeeks.slice(start);
        var s = 0;
        for (var j = 0; j < slice.length; j++) s += slice[j];
        last4 = s / slice.length;
      }

      var vol = 0;
      if (gamePts.length >= 2) {
        var mean = ppg;
        var ss = 0;
        for (var k = 0; k < gamePts.length; k++) {
          var dx = gamePts[k] - mean;
          ss += dx * dx;
        }
        vol = Math.sqrt(ss / (gamePts.length - 1));
      }

      var rankInfo = this.getDefenseRoleInfo(defTeam, roleKey) || {};
      var rank = (this.ui.defRoleSort === "most") ? rankInfo.rankMost : rankInfo.rankLeast;
      var detailed = rankInfo.detailed || {};
      var matchScore = rankInfo.matchScore || 0;

      rows.push({ 
        team: defTeam, 
        games: g, 
        ppg: ppg, 
        last4: last4,
        last4Vals: last4Vals,
        last4Wks: last4Wks,
        vol: vol, 
        rank: rank || 0, 
        ceil: (rankInfo && isFinite(rankInfo.ceilRate) ? rankInfo.ceilRate : 0), 
        floor: (rankInfo && isFinite(rankInfo.floorRate) ? rankInfo.floorRate : 0), 
        top10: (rankInfo && isFinite(rankInfo.top10Rate) ? rankInfo.top10Rate : 0),
        detailed: detailed,
        matchScore: matchScore,
        breakdown: rankInfo.matchScoreBreakdown || {}
      });
    }

    if (this.ui.defRoleSort === "most") rows.sort(function(a,b){ return b.ppg - a.ppg; });
    else rows.sort(function(a,b){ return a.ppg - b.ppg; });

    var html = "";
    for (var r = 0; r < rows.length; r++) {
      var row = rows[r];
      var cls = (r < 5) ? "bg-gray-950/40" : "";
      
      // MU score color coding
      var muScore = row.matchScore || 0;
      var muCls = muScore >= 70 ? 'text-accent font-bold' : muScore >= 50 ? 'text-gray-300' : 'text-red-400';
      var muBg = muScore >= 70 ? 'bg-accent/10' : muScore >= 50 ? '' : 'bg-red-900/10';
      
      // Get detailed stats for this row
      var d = row.detailed || {};
      var stat1 = cols[0].fmt(d[cols[0].key] || 0);
      var stat2 = cols[1].fmt(d[cols[1].key] || 0);
      var stat3 = cols[2].fmt(d[cols[2].key] || 0);
      
      // Trend indicator
      var trendIcon = row.last4 > row.ppg ? '‚Üë' : row.last4 < row.ppg ? '‚Üì' : '‚Üí';
      var trendCls = row.last4 > row.ppg ? 'text-green-400' : row.last4 < row.ppg ? 'text-red-400' : 'text-gray-400';
      
      // Build L4 tooltip showing individual games
      var l4Tooltip = 'L4 Breakdown: ';
      for (var lt = 0; lt < row.last4Vals.length; lt++) {
        l4Tooltip += 'Wk' + row.last4Wks[lt] + ': ' + row.last4Vals[lt].toFixed(1);
        if (lt < row.last4Vals.length - 1) l4Tooltip += ', ';
      }
      l4Tooltip += ' | Avg: ' + row.last4.toFixed(2);
      
      html += '<tr class="border-b border-gray-800 hover:bg-gray-800/30 ' + cls + '">' +
        '<td class="px-3 py-2 font-mono text-gray-200 text-xs font-bold">' + row.team + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-gray-400 text-xs">' + row.games + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-white text-xs font-semibold">' + row.ppg.toFixed(1) + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-xs ' + trendCls + ' cursor-help" title="' + l4Tooltip + '">' + row.last4.toFixed(1) + ' ' + trendIcon + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-gray-400 text-xs">' + row.vol.toFixed(1) + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-gray-300 text-xs">#' + (row.rank || (r+1)) + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-green-400 text-xs">' + (row.ceil ? (row.ceil*100).toFixed(0) + '%' : '0%') + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-red-400 text-xs">' + (row.floor ? (row.floor*100).toFixed(0) + '%' : '0%') + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-yellow-400 text-xs">' + (row.top10 ? (row.top10*100).toFixed(0) + '%' : '0%') + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-gray-300 text-xs">' + stat1 + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-gray-300 text-xs">' + stat2 + '</td>' +
        '<td class="px-2 py-2 text-right font-mono text-gray-300 text-xs">' + stat3 + '</td>' +
        '<td class="px-3 py-2 text-right font-mono text-xs ' + muCls + ' ' + muBg + ' rounded" title="Base: ' + (row.breakdown.base || 0) + ', Trend: ' + (row.breakdown.trend || 0) + ', Ceil: +' + (row.breakdown.ceilBonus || 0) + ', Floor: -' + (row.breakdown.floorPenalty || 0) + '">' + muScore.toFixed(0) + '</td>' +
      '</tr>';
    }
    this.dom.defRoleTableBody.innerHTML = html || '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="13">No data.</td></tr>';
  },

  bindDefenseRoleUI: function() {
    var self = this;
    if (this.dom.defRoleSelect && !this.dom.defRoleSelect._bound) {
      this.dom.defRoleSelect.onchange = function() {
        self.ui.defRoleKey = this.value;
        self.renderDefenseRoleEffectiveness();
      };
      this.dom.defRoleSelect._bound = true;
    }
    if (this.dom.defRoleModeMost && !this.dom.defRoleModeMost._bound) {
      this.dom.defRoleModeMost.onclick = function() {
        self.ui.defRoleSort = "most";
        self.renderDefenseRoleEffectiveness();
      };
      this.dom.defRoleModeMost._bound = true;
    }
    if (this.dom.defRoleModeLeast && !this.dom.defRoleModeLeast._bound) {
      this.dom.defRoleModeLeast.onclick = function() {
        self.ui.defRoleSort = "least";
        self.renderDefenseRoleEffectiveness();
      };
      this.dom.defRoleModeLeast._bound = true;
    }
  },

  rosterColor: function(rosterId) {
    // Keep chart colors consistent across League Analysis visuals
    var colors = ['#10b981', '#22c55e', '#3b82f6', '#a855f7', '#ec4899', '#f97316', '#06b6d4', '#84cc16', '#6366f1', '#14b8a6'];
    var rid = String(rosterId);
    var idx = 0;
    var rosters = this.data.rosters || [];
    for (var i = 0; i < rosters.length; i++) {
      if (String(rosters[i].roster_id) === rid) { idx = i; break; }
    }
    return colors[idx % colors.length];
  },

  getOpponent: function(statsObj, projObj, playerObj, week) {
    // Try to get opponent from stats or projections data first
    var cand = function(obj) {
      if (!obj) return null;
      // Check common field names for opponent
      var opp = obj.opponent || obj.opp || obj.opp_team || obj.opponent_team || obj.opponentTeam || obj.team_opp || obj.oppTeam;
      // Also check inside game or metadata objects
      if (!opp && obj.game) opp = obj.game.opponent || obj.game.opp;
      if (!opp && obj.player) opp = obj.player.opponent || obj.player.opp;
      return opp;
    };
    
    var opp = cand(statsObj) || cand(projObj);
    
    // Check metadata
    if (!opp && projObj) {
      opp = (projObj.meta && projObj.meta.opponent) || (projObj.metadata && projObj.metadata.opponent) || null;
    }
    if (!opp && statsObj) {
      opp = (statsObj.meta && statsObj.meta.opponent) || (statsObj.metadata && statsObj.metadata.opponent) || null;
    }
    
    // Fallback to schedule lookup if we have it
    if (!opp && playerObj && playerObj.team && week && this.nflSchedule) {
      var teamSchedule = this.nflSchedule[playerObj.team];
      if (teamSchedule && teamSchedule[week - 1]) {
        opp = teamSchedule[week - 1];
      }
    }
    
    if (typeof opp !== "string") return null;
    opp = opp.trim().toUpperCase();
    return (!opp || opp === "NA" || opp === "N/A" || opp === "BYE") ? null : opp;
  },

  startersHybridTotal: function(roster, weekNum, startersOverride) {
    var wk = String((weekNum !== null && weekNum !== undefined) ? weekNum : this.ui.selectedWeek);
    var statsMap = this.data.weekStats[wk] || {};
    var projMap = this.data.weekProj[wk] || {};
    var starters = Array.isArray(startersOverride) ? startersOverride : ((roster && Array.isArray(roster.starters)) ? roster.starters : []);
    var sum = 0;
    var self = this;
    starters.forEach(function(pid) {
      var id = String(pid);
      if (!id || id === "null" || id === "undefined") return;
      var statsObj = statsMap[id] || {};
      var projObj = projMap[id] || {};
      var hasPlayed = Object.keys(statsObj).length > 0;
      sum += hasPlayed ? self.scoreFromStats(statsObj, id) : self.scoreFromStats(projObj, id);
    });
    return Math.round(sum * 100) / 100;
  },

  buildMatchupPairs: function(weekNum, items) {
    var arr = Array.isArray(items) ? items : [];
    var hasMid = arr.some(function(m) { return m && m.matchup_id != null; });
    
    if (hasMid) {
      var by = new Map();
      arr.forEach(function(m) {
        var mid = m.matchup_id;
        if (mid == null) return;
        if (!by.has(mid)) by.set(mid, []);
        by.get(mid).push(m);
      });
      var pairs = [];
      var sorted = Array.from(by.entries()).sort(function(a, b) { return Number(a[0]) - Number(b[0]); });
      sorted.forEach(function(entry) {
        var mid = entry[0];
        var group = entry[1];
        if (!Array.isArray(group) || group.length !== 2) return;
        var two = group.slice().sort(function(x, y) { return Number(x.roster_id) - Number(y.roster_id); });
        pairs.push({
          label: String(mid),
          subLabel: "Week " + weekNum,
          aRosterId: two[0].roster_id,
          bRosterId: two[1].roster_id,
          aMatchup: two[0],
          bMatchup: two[1]
        });
      });
      return pairs;
    }
    return this.buildPlayoffPairs(weekNum);
  },

  buildPlayoffPairs: function(weekNum) {
    var s = (this.data.league && this.data.league.settings) || {};
    var start = Number(nvl(nvl(s.playoff_week_start, s.playoff_start_week), s.playoff_start));
    if (!start || !Number.isFinite(start) || weekNum < start) return [];
    var round = (weekNum - start) + 1;

    var out = [];
    var addFrom = function(arr, tag) {
      var list = Array.isArray(arr) ? arr : [];
      list.forEach(function(n) {
        if (!n || Number(n.r) !== round) return;
        var t1 = n.t1, t2 = n.t2;
        if (typeof t1 !== "number" || typeof t2 !== "number") return;
        out.push({
          label: tag + "R" + round + "-M" + nvl(n.m, "?"),
          subLabel: "Week " + weekNum + " ‚Ä¢ Playoffs (Round " + round + ")",
          aRosterId: t1,
          bRosterId: t2
        });
      });
    };
    addFrom(this.data.winnersBracket, "W");
    addFrom(this.data.losersBracket, "L");
    return out;
  },

  playerHeadshotUrl: function(pid) {
    var id = String(pid || "").trim();
    return id ? "https://sleepercdn.com/content/nfl/players/thumb/" + id + ".jpg" : "";
  },

  teamLogoUrl: function(team) {
    var t = (team || "").toString().trim().toLowerCase();
    return t ? "https://sleepercdn.com/images/team_logos/nfl/" + t + ".png" : "";
  },

  playerImg: function(pid, playerObj, sizeClass) {
    sizeClass = sizeClass || "w-10 h-10";
    var head = this.playerHeadshotUrl(pid);
    var team = this.teamLogoUrl(playerObj && playerObj.team);
    var fallback = team || "";
    var onerr = fallback
      ? "this.onerror=null;this.src='" + fallback + "';"
      : "this.onerror=null;this.style.display='none';";
    return '<img src="' + head + '" class="' + sizeClass + ' rounded-lg bg-gray-900 border border-gray-800 object-cover" onerror="' + onerr + '" loading="lazy" alt=""/>';
  },

  injuryTag: function(playerObj) {
    var raw = ((playerObj && (playerObj.injury_status || playerObj.status)) || "").toString().trim();
    if (!raw) return "";

    var up = raw.toUpperCase();
    var normMap = { Q: "QUESTIONABLE", O: "OUT", P: "PROBABLE", D: "DOUBTFUL", INJURED_RESERVE: "IR" };
    var norm = normMap[up] || up;
    
    var labels = { QUESTIONABLE: "Questionable", DOUBTFUL: "Doubtful", PROBABLE: "Probable", OUT: "Out", IR: "IR", DNR: "DNR" };
    var label = labels[norm] || (raw.length > 18 ? raw.slice(0, 18) + "‚Ä¶" : raw);

    var severe = ["OUT", "IR", "DNR", "SUSP", "SUSPENDED", "PUP", "NFI", "COVID", "INACTIVE"];
    var moderate = ["DOUBTFUL", "QUESTIONABLE"];
    var goodish = ["PROBABLE", "ACTIVE"];

    var cls = "bg-slate-700/30 text-slate-200 border-slate-500/30";
    if (severe.indexOf(norm) >= 0) cls = "bg-red-600/30 text-red-200 border-red-500/30";
    else if (moderate.indexOf(norm) >= 0) cls = "bg-amber-600/30 text-amber-200 border-amber-500/30";
    else if (goodish.indexOf(norm) >= 0) cls = "bg-green-600/20 text-green-200 border-green-500/30";

    return '<span class="ml-2 inline-flex items-center px-2 py-0.5 rounded-md border text-[10px] font-mono ' + cls + '">' + label + '</span>';
  },

  ensureWeeksLoadedUpTo: function(week) {
    var self = this;
    var target = Number(week);
    if (!isFinite(target) || target < 0) target = 0;

    var season = this.getSeason();

    if (!self.data.weekLoadPromises) self.data.weekLoadPromises = {};

    // Collect missing weeks (include week 0; if the endpoint returns empty, it becomes a harmless no-op).
    var missing = [];
    for (var w = 1; w <= target; w++) {
      var wk = String(w);
      var stData = self.data.weekStats[wk];
      var prData = self.data.weekProj[wk];
      var stOk = !!stData && !Array.isArray(stData);
      var prOk = !!prData && !Array.isArray(prData);
      if (!stOk || !prOk) missing.push(w);
    }
    if (!missing.length) return Promise.resolve();

    var safeFetch = function(url, fallback) {
      return self.fetchJson(url).catch(function(e) {
        console.warn("Week stats/projections unavailable:", url, (e && e.message) ? e.message : e);
        return fallback;
      });
    };

    var fetchOne = function(w) {
      var wk = String(w);
      if (self.data.weekLoadPromises[wk]) return self.data.weekLoadPromises[wk];

      var p = (function(){
            var posQ = "&position[]=QB&position[]=RB&position[]=WR&position[]=TE&position[]=K&position[]=DEF&position[]=DL&position[]=LB&position[]=DB";
            var seasonType = (self.cfg && self.cfg.seasonType) ? self.cfg.seasonType : "regular";
            var stA = "https://api.sleeper.app/stats/nfl/" + season + "/" + w + "?season_type=" + seasonType + posQ;
            var stB = "https://api.sleeper.com/stats/nfl/" + season + "/" + w + "?season_type=" + seasonType + posQ;
            var prA = "https://api.sleeper.app/projections/nfl/" + season + "/" + w + "?season_type=" + seasonType + posQ;
            var prB = "https://api.sleeper.com/projections/nfl/" + season + "/" + w + "?season_type=" + seasonType + posQ;

            var statsP = self.fetchJson(stA).catch(function(){ return self.fetchJson(stB); }).catch(function(){ return {}; });
            var projP  = self.fetchJson(prA).catch(function(){ return self.fetchJson(prB); }).catch(function(){ return {}; });

            return Promise.all([statsP, projP]);
          })().then(function(res) {
        self.data.weekStats[wk] = self.arrToMap(res[0]);
        self.data.weekProj[wk] = self.arrToMap(res[1]);
      }).finally(function() {
        try { delete self.data.weekLoadPromises[wk]; } catch(e) {}
      });

      self.data.weekLoadPromises[wk] = p;
      return p;
    };

    // Load collectively with a small concurrency cap to avoid rate limiting.
    var CONCURRENCY = 6;
    var idx = 0;
    var worker = function() {
      if (idx >= missing.length) return Promise.resolve();
      var w = missing[idx++];
      return fetchOne(w).then(worker);
    };

    var workers = [];
    for (var i = 0; i < Math.min(CONCURRENCY, missing.length); i++) workers.push(worker());
    return Promise.all(workers).then(function() {});
  },

  ensureMatchupsLoadedUpTo: function(week) {
    var self = this;
    var loadNext = function(w) {
      if (w > week) return Promise.resolve();
      var wk = String(w);
      if (!self.data.weekMatchups[wk]) {
        return self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/matchups/" + w)
          .then(function(arr) { self.data.weekMatchups[wk] = arr || []; })
          .catch(function() { self.data.weekMatchups[wk] = []; })
          .then(function() { return loadNext(w + 1); });
      }
      return loadNext(w + 1);
    };
    return loadNext(1);
  },

  getMatchupForRoster: function(weekNum, rosterId) {
    var wk = String(weekNum);
    var arr = (this.data.weekMatchups && this.data.weekMatchups[wk]) || [];
    for (var i = 0; i < arr.length; i++) {
      var m = arr[i];
      if (m && String(m.roster_id) === String(rosterId)) return m;
    }
    return null;
  },

  buildLeagueMetrics: function() {
    var self = this;
    var maxWeek = Math.min(18, Number(this.getMaxWeek()) || 18);

    return Promise.all([self.ensureMatchupsLoadedUpTo(maxWeek), self.ensureWeeksLoadedUpTo(maxWeek)]).then(function() {
      var rosters = self.data.rosters || [];
      var teamCount = rosters.length || 0;
      if (!teamCount) {
        self.data.leagueMetrics = { maxWeek: maxWeek, teams: {} };
        return;
      }

      // Build name map
      var nameForRoster = function(rid) {
        var roster = rosters.find(function(r) { return String(r.roster_id) === String(rid); });
        var u = roster ? self.data.usersById[roster.owner_id] : null;
        return (u && u.display_name) ? u.display_name : ("Team " + rid);
      };

      var rosterIds = rosters.map(function(r) { return String(r.roster_id); });
      var teams = {};
      rosterIds.forEach(function(rid) {
        teams[rid] = {
          roster_id: rid,
          name: nameForRoster(rid),
          pf: 0,
          pa: 0,
          w: 0,
          l: 0,
          t: 0,
          allPlayW: 0,
          allPlayG: 0,
          expW: 0,
          luck: 0,
          sos: 0,
          scores: [], optPf: 0, benchPf: 0, regret: 0
        };
      });

      
      // Roster lookup for fallbacks
      var rosterById = {};
      rosters.forEach(function(r) { rosterById[String(r.roster_id)] = r; });

      // Starter slots (exclude bench/IR/taxi/reserve if present in roster_positions)
      var rosterPositions = (self.data.league && Array.isArray(self.data.league.roster_positions)) ? self.data.league.roster_positions : [];
      var isBenchSlot = function(s) {
        return !s || s === "BN" || s === "IR" || s === "RES" || s === "TAXI" || s === "SUSP" || s === "NA";
      };
      var starterSlotsBase = rosterPositions.filter(function(s) { return !isBenchSlot(s); });

      // Aggregate starter scoring by position for baselines
      var posAgg = {};
      // Track 8 main fantasy position categories
      var BASELINE_POS = { QB:1, RB:1, WR:1, TE:1, K:1, DL:1, LB:1, DB:1 };

      // Slot eligibility for flex types
      var slotEligible = function(slot, pos) {
        if (!slot || !pos) return false;
        if (slot === pos) return true;
        // normalize common DST naming
        if (slot === "DEF" && (pos === "DST" || pos === "DEF")) return true;

        var map = {
          "FLEX": ["RB","WR","TE"],
          "SUPER_FLEX": ["QB","RB","WR","TE"],
          "WRRB_FLEX": ["WR","RB"],
          "RBWR_FLEX": ["RB","WR"],
          "REC_FLEX": ["WR","TE"],
          "WRTE_FLEX": ["WR","TE"],
          "IDP_FLEX": ["DL","LB","DB"],
          "DP": ["DL","LB","DB"],
          "OP": ["QB","RB","WR","TE"]
        };
        if (map[slot]) return map[slot].indexOf(pos) !== -1;
        // fallback aliases
        if (slot === "RBWRTE") return ["RB","WR","TE"].indexOf(pos) !== -1;
        return false;
      };

      var percentile = function(arr, p) {
        if (!arr || !arr.length) return 0;
        var idx = (arr.length - 1) * p;
        var lo = Math.floor(idx);
        var hi = Math.ceil(idx);
        if (lo === hi) return arr[lo];
        var frac = idx - lo;
        return arr[lo] + (arr[hi] - arr[lo]) * frac;
      };

      var computeOptimalFromPool = function(players, ptsById, starterSlots) {
        if (!Array.isArray(players) || !players.length) return 0;
        var pool = [];
        for (var i = 0; i < players.length; i++) {
          var pid = String(players[i]);
          if (!pid) continue;
          var pObj = self.data.playersById[pid] || {};
          var pos = (pObj.fantasy_positions && pObj.fantasy_positions[0]) || pObj.position || pObj.fantasy_pos || pObj.pos;
          if (!pos) continue;
          var pts = ptsById[pid];
          if (pts == null) pts = 0;
          pool.push({ id: pid, pos: pos, pts: pts });
        }
        pool.sort(function(a,b){ return b.pts - a.pts; });

        var used = {};
        var total = 0;

        var takeBest = function(slot) {
          for (var j = 0; j < pool.length; j++) {
            var it = pool[j];
            if (used[it.id]) continue;
            if (!slotEligible(slot, it.pos)) continue;
            used[it.id] = true;
            total += it.pts;
            return true;
          }
          return false;
        };

        // Count slots
        var counts = {};
        for (var k = 0; k < starterSlots.length; k++) {
          var s = starterSlots[k];
          counts[s] = (counts[s] || 0) + 1;
        }

        // Fill fixed slots first
        var fixed = ["QB","RB","WR","TE","K","DEF","DL","LB","DB"];
        for (var f = 0; f < fixed.length; f++) {
          var slot = fixed[f];
          var c = counts[slot] || 0;
          for (var n = 0; n < c; n++) takeBest(slot);
        }

        // Fill flex-like slots
        var flexOrder = ["SUPER_FLEX","OP","FLEX","WRRB_FLEX","RBWR_FLEX","REC_FLEX","WRTE_FLEX","RBWRTE","IDP_FLEX","DP"];
        for (var fo = 0; fo < flexOrder.length; fo++) {
          var fs = flexOrder[fo];
          var fc = counts[fs] || 0;
          for (var nn = 0; nn < fc; nn++) takeBest(fs);
        }

        return Math.round(total * 100) / 100;
      };

      var weekScores = {};
      for (var w = 1; w <= maxWeek; w++) {
        var wk = String(w);
        var matchArr = self.data.weekMatchups[wk] || [];
        var byRoster = {};
        matchArr.forEach(function(m) { if (m && m.roster_id != null) byRoster[String(m.roster_id)] = m; });

        var scoresThisWeek = {};
        // points are hybrid: actual stats if available, otherwise projections
        var statsMap = self.data.weekStats[wk] || {};
        var projMap = self.data.weekProj[wk] || {};
        var hybridPts = function(pid) {
          var id = String(pid);
          if (!id || id === "null" || id === "undefined") return 0;
          var st = statsMap[id] || {};
          var pr = projMap[id] || {};
          var hasPlayed = Object.keys(st).length > 0;
          var pts = hasPlayed ? self.scoreFromStats(st, id) : self.scoreFromStats(pr, id);
          return (Math.round(pts * 100) / 100);
        };

        rosterIds.forEach(function(rid) {
          var mu = byRoster[rid];
          var rosterObj = rosterById[rid] || {};
          var starters = (mu && Array.isArray(mu.starters)) ? mu.starters : (rosterObj.starters || []);
          var players = (mu && Array.isArray(mu.players)) ? mu.players : (rosterObj.players || []);

          // Starter total
          var starterTotal = self.startersHybridTotal(null, w, starters);
          scoresThisWeek[rid] = starterTotal;
          teams[rid].pf += starterTotal;
          teams[rid].scores.push(starterTotal);

          // Build points map for roster pool
          var ptsById = {};
          for (var i = 0; i < players.length; i++) {
            var pid = String(players[i]);
            ptsById[pid] = hybridPts(pid);
          }

          // Bench points
          var starterSet = {};
          for (var s = 0; s < starters.length; s++) starterSet[String(starters[s])] = true;

          var benchSum = 0;
          for (var j = 0; j < players.length; j++) {
            var pid2 = String(players[j]);
            if (!starterSet[pid2]) benchSum += (ptsById[pid2] || 0);
          }
          benchSum = Math.round(benchSum * 100) / 100;

          // Optimal lineup (use starter slots count as guard if mismatch)
          var starterSlots = starterSlotsBase.slice();
          if (Array.isArray(starters) && starters.length && starterSlots.length && starterSlots.length !== starters.length) {
            starterSlots = starterSlots.slice(0, starters.length);
          }
          var opt = computeOptimalFromPool(players, ptsById, starterSlots);

          // Regret / efficiency tracking
          var regret = opt - starterTotal;
          if (regret < 0) regret = 0;
          teams[rid].optPf += opt;
          teams[rid].benchPf += benchSum;
          teams[rid].regret += regret;

          // Positional aggregation (starters only) - hybrid stats/projections
          for (var ss = 0; ss < starters.length; ss++) {
            var pid3 = String(starters[ss]);
            var pObj = self.data.playersById[pid3] || {};
            var pos = (pObj.fantasy_positions && pObj.fantasy_positions[0]) || pObj.position || pObj.fantasy_pos || pObj.pos;
            if (!pos) continue;
            pos = String(pos).toUpperCase();
            if (pos === 'DST') pos = 'DEF';
            if (!BASELINE_POS[pos]) continue;
            // Baselines should ignore weeks where the player did not play.
// NOTE: Do NOT filter by projections here; projections can be missing/0 for real games.
            var stB = statsMap[pid3] || {};
            var hasPlayedB = Object.keys(stB).length > 0;
            if (!hasPlayedB) continue;        // "Not played"
            var posPts = self.scoreFromStats(stB, pid3);
if (!isFinite(posPts)) continue;

            posAgg[pos] = posAgg[pos] || [];
            posAgg[pos].push(posPts);
        }
        });

        weekScores[wk] = scoresThisWeek;

        // All-play
        rosterIds.forEach(function(rid) {
          var score = scoresThisWeek[rid];
          var wins = 0;
          var games = 0;
          rosterIds.forEach(function(other) {
            if (other === rid) return;
            games++;
            if (score > scoresThisWeek[other]) wins += 1;
            else if (score === scoresThisWeek[other]) wins += 0.5;
          });
          teams[rid].allPlayW += wins;
          teams[rid].allPlayG += games;
          teams[rid].expW += (games ? (wins / games) : 0);
        });

        // H2H results + PA and SoS
        var pairs = self.buildMatchupPairs(w, matchArr);
        pairs.forEach(function(p) {
          var aRid = String(p.aRosterId);
          var bRid = String(p.bRosterId);
          var aScore = scoresThisWeek[aRid] || 0;
          var bScore = scoresThisWeek[bRid] || 0;

          teams[aRid].pa += bScore;
          teams[bRid].pa += aScore;

          // SoS proxy: average opponent score
          teams[aRid].sos += bScore;
          teams[bRid].sos += aScore;

          if (aScore > bScore) { teams[aRid].w++; teams[bRid].l++; }
          else if (bScore > aScore) { teams[bRid].w++; teams[aRid].l++; }
          else {
              // If both are zero, this matchup likely hasn't been played yet (pre-week / early week).
              // Avoid counting phantom ties like 0-0 that would incorrectly show records like 0-0-1.
              if (!(aScore === 0 && bScore === 0)) { teams[aRid].t++; teams[bRid].t++; }
            }
        });
      }

      // Finalize
      rosterIds.forEach(function(rid) {
        var tm = teams[rid];
        tm.pf = Math.round(tm.pf * 100) / 100;
        tm.pa = Math.round(tm.pa * 100) / 100;
        tm.allPlayPct = tm.allPlayG ? (tm.allPlayW / tm.allPlayG) : 0;
        tm.expW = Math.round(tm.expW * 100) / 100;

        var actualW = tm.w + (tm.t * 0.5);
        tm.luck = Math.round((actualW - tm.expW) * 100) / 100;

        var n = tm.scores.length;
        var mean = n ? (tm.scores.reduce(function(a,b){return a+b;},0) / n) : 0;
        var variance = n ? (tm.scores.reduce(function(a,b){return a + Math.pow(b-mean,2);},0) / n) : 0;
        tm.stddev = Math.sqrt(variance);
        tm.stddev = Math.round(tm.stddev * 100) / 100;

        tm.sos = n ? (tm.sos / n) : 0;
        tm.sos = Math.round(tm.sos * 100) / 100;
      });

      // Finalize lineup metrics + build positional baselines
      Object.values(teams).forEach(function(tm) {
        tm.optPf = Math.round((tm.optPf || 0) * 100) / 100;
        tm.benchPf = Math.round((tm.benchPf || 0) * 100) / 100;
        tm.regret = Math.round((tm.regret || 0) * 100) / 100;
        tm.eff = (tm.optPf > 0) ? Math.round(((tm.pf / tm.optPf) * 1000)) / 1000 : 0;
      });

      var baselines = {};
      Object.keys(posAgg).forEach(function(pos) {
        var arr = posAgg[pos] || [];
        if (!arr.length) return;
        arr.sort(function(a,b){ return a - b; });
        var sum = 0;
        for (var i = 0; i < arr.length; i++) sum += arr[i];
        baselines[pos] = {
          n: arr.length,
          median: Math.round(percentile(arr, 0.50) * 100) / 100,
          p25: Math.round(percentile(arr, 0.25) * 100) / 100,
          p75: Math.round(percentile(arr, 0.75) * 100) / 100,
          avg: Math.round((sum / arr.length) * 100) / 100
        };
      });

      self.data.teamWeekScores = weekScores;
      self.data.leagueMetrics = { maxWeek: maxWeek, teams: teams, baselines: baselines };
    });
  },

  // Load NFL schedule dynamically from Sleeper API (undocumented endpoint)
  // Endpoint: GET https://api.sleeper.com/schedule/nfl/regular/{year}
  loadNFLSchedule: function() {
    var self = this;
    var season = "2025";
    // Use api.sleeper.com (NOT api.sleeper.app) for undocumented endpoints
    var url = "https://api.sleeper.com/schedule/nfl/regular/" + season;
    
    return this.fetchJson(url).then(function(scheduleData) {
      var scheduleByTeam = {};
      // Keep the raw schedule payload so we can derive *actual* points allowed/for later
      self.nflScheduleGamesRaw = scheduleData;

      
      if (Array.isArray(scheduleData)) {
        scheduleData.forEach(function(game) {
          var week = game.week;
          var homeTeam = game.home;
          var awayTeam = game.away;
          
          if (homeTeam && awayTeam && week) {
            if (!scheduleByTeam[homeTeam]) scheduleByTeam[homeTeam] = [];
            if (!scheduleByTeam[awayTeam]) scheduleByTeam[awayTeam] = [];
            
            while (scheduleByTeam[homeTeam].length < week) scheduleByTeam[homeTeam].push("BYE");
            while (scheduleByTeam[awayTeam].length < week) scheduleByTeam[awayTeam].push("BYE");
            
            scheduleByTeam[homeTeam][week - 1] = awayTeam;
            scheduleByTeam[awayTeam][week - 1] = homeTeam;
          }
        });
      }
      
      if (Object.keys(scheduleByTeam).length > 0) {
        self.nflSchedule = scheduleByTeam;
        console.log("Loaded " + season + " NFL schedule for", Object.keys(scheduleByTeam).length, "teams");
      } else {
        console.warn("Schedule data empty, will use opponent data from projections");
        self.nflSchedule = {};
      }
    }).catch(function(err) {
      console.warn("Could not load NFL schedule:", err.message);
      self.nflSchedule = {};
    });
  },

  // Load defense stats - now using real NFL.com 2025 season data
  loadDefenseStats: function() {
    var self = this;
    var season = String(this.getSeason());
    var currentWeek = parseInt(this.getMaxWeek(), 10) || 1;

    // We pull *actual* team defensive season totals from NFL.com (passing + rushing)
    // via r.jina.ai (CORS-friendly mirror), then compute per-game values using games played to date.
    // This avoids Pro-Football-Reference blocks and keeps the source "official NFL stats".
    var cacheKey = "nflcom_def_stats_" + season;
    var cacheTTLms = 12 * 60 * 60 * 1000; // 12 hours

    // Default to "estimated" until we successfully parse real pass/rush splits
    this.data.hasRealPassRushData = false;

    // If DOMParser is unavailable (very old browsers), fall back to baked snapshot
    if (typeof DOMParser === "undefined") {
      this._loadDefenseStatsFallback();
      return Promise.resolve();
    }

    // Fast path: localStorage cache
    try {
      var cachedRaw = localStorage.getItem(cacheKey);
      if (cachedRaw) {
        var cached = JSON.parse(cachedRaw);
        if (cached && cached.t && cached.v && (Date.now() - cached.t) < cacheTTLms) {
          self.data.pfrDefenseStats = cached.v;
          self.data.hasRealPassRushData = true;
          self.setProgress("Loaded NFL defense stats (NFL.com cache)", 86);
          self.loadSleeperDefenseStats(cached.v);
          return Promise.resolve();
        }
      }
    } catch (e) { /* ignore cache errors */ }

    var passUrl = "https://r.jina.ai/https://www.nfl.com/stats/team-stats/defense/passing/" + season + "/reg/all";
    var rushUrl = "https://r.jina.ai/https://www.nfl.com/stats/team-stats/defense/rushing/" + season + "/reg/all";

    // Full team name -> abbreviation mapping (NFL.com tables use full names)
    var NAME_TO_ABBR = {
      "49ers":"SF","Bears":"CHI","Bengals":"CIN","Bills":"BUF","Broncos":"DEN","Browns":"CLE","Buccaneers":"TB",
      "Cardinals":"ARI","Chargers":"LAC","Chiefs":"KC","Colts":"IND","Commanders":"WAS","Cowboys":"DAL",
      "Dolphins":"MIA","Eagles":"PHI","Falcons":"ATL","Giants":"NYG","Jaguars":"JAX","Jets":"NYJ","Lions":"DET",
      "Packers":"GB","Panthers":"CAR","Patriots":"NE","Raiders":"LV","Rams":"LAR","Ravens":"BAL","Saints":"NO",
      "Seahawks":"SEA","Steelers":"PIT","Texans":"HOU","Titans":"TEN","Vikings":"MIN"
    };

    var getGamesPlayedToDate = function(teamAbbr) {
      try {
        // self.nflSchedule[TEAM] is a week-indexed array of opponent abbreviations or "BYE"
        var sched = self.nflSchedule && self.nflSchedule[teamAbbr];
        if (!Array.isArray(sched) || !sched.length) return 17;

        var playedThrough = Math.max(0, currentWeek - 1);
        var weeksToCount = Math.min(playedThrough, sched.length);

        var cnt = 0;
        for (var i = 0; i < weeksToCount; i++) {
          var opp = sched[i];
          if (opp && opp !== "BYE") cnt++;
        }

        // If week isn't reliable (or it's offseason), fall back to full-season scheduled games (non-BYE entries)
        if (cnt <= 0) {
          var full = 0;
          for (var j = 0; j < sched.length; j++) {
            if (sched[j] && sched[j] !== "BYE") full++;
          }
          cnt = full || 17;
        }

        return cnt;
      } catch (e) {
        return 17;
      }
    };

    var toPlainTextLines = function(htmlText) {
      var doc = new DOMParser().parseFromString(htmlText, "text/html");
      var txt = (doc && doc.body) ? (doc.body.innerText || doc.body.textContent || "") : (htmlText || "");
      txt = String(txt || "").replace(/\r/g, "\n");
      var lines = txt.split("\n").map(function(s){ return (s || "").trim(); }).filter(function(s){ return !!s; });
      return lines;
    };

    var parseDefensePassing = function(htmlText) {
      // Expected numeric order on NFL.com "Defense > Passing":
      // Att, Cmp, Cmp %, Yds/Att, Pass Yds, TD, INT, Rate, 1st, 1st%, 20+, 40+, Lng, Sck, SckY
      var lines = toPlainTextLines(htmlText);
      var hdrIdx = -1;
      for (var i = 0; i < lines.length; i++) {
        var L = lines[i];
        if (L.indexOf("Team") === 0 && L.indexOf("Pass Yds") !== -1 && L.indexOf("Sck") !== -1) { hdrIdx = i; break; }
      }
      if (hdrIdx === -1) return {};

      var out = {};
      var curTeam = null;

      var isNumericLine = function(s) { return /^\d/.test(s); };
      var parseNum = function(s) {
        if (s === null || s === undefined) return null;
        var t = String(s).trim().replace(/,/g, "").replace(/[^\d\.\-]/g, "");
        if (!t) return null;
        var n = parseFloat(t);
        return isNaN(n) ? null : n;
      };

      for (var j = hdrIdx + 1; j < lines.length; j++) {
        var line = lines[j];
        if (!line || line === "Image" || line === "Advertising") continue;

        if (NAME_TO_ABBR[line]) {
          curTeam = line;
          continue;
        }

        if (curTeam && isNumericLine(line)) {
          var parts = line.split(/\s+/);
          if (parts.length < 10) continue;

          var abbr = NAME_TO_ABBR[curTeam];
          var g = getGamesPlayedToDate(abbr);

          var passYds = parseNum(parts[4]);
          var passTD = parseNum(parts[5]);
          var ints = parseNum(parts[6]);
          var sacks = parseNum(parts[13]);

          out[abbr] = {
            team: abbr,
            games: g,
            totalPassYds: nvl(passYds, 0),
            passYdsPerGame: (g > 0 ? (nvl(passYds, 0) / g).toFixed(1) : "N/A"),
            passTD: nvl(passTD, 0),
            interceptions: nvl(ints, 0),
            sacks: nvl(sacks, 0)
          };

          // Reset until we see the next team name (NFL.com repeats team names; this prevents double-picking)
          curTeam = null;
        }
      }

      return out;
    };

    var parseDefenseRushing = function(htmlText) {
      // Expected numeric order on NFL.com "Defense > Rushing":
      // Att, Rush Yds, YPC, TD, 20+, 40+, Lng, Rush 1st, 1st%, Rush FUM
      var lines = toPlainTextLines(htmlText);
      var hdrIdx = -1;
      for (var i = 0; i < lines.length; i++) {
        var L = lines[i];
        if (L.indexOf("Team") === 0 && L.indexOf("Rush Yds") !== -1 && L.indexOf("YPC") !== -1) { hdrIdx = i; break; }
      }
      if (hdrIdx === -1) return {};

      var out = {};
      var curTeam = null;

      var isNumericLine = function(s) { return /^\d/.test(s); };
      var parseNum = function(s) {
        if (s === null || s === undefined) return null;
        var t = String(s).trim().replace(/,/g, "").replace(/[^\d\.\-]/g, "");
        if (!t) return null;
        var n = parseFloat(t);
        return isNaN(n) ? null : n;
      };

      for (var j = hdrIdx + 1; j < lines.length; j++) {
        var line = lines[j];
        if (!line || line === "Image" || line === "Advertising") continue;

        if (NAME_TO_ABBR[line]) {
          curTeam = line;
          continue;
        }

        if (curTeam && isNumericLine(line)) {
          var parts = line.split(/\s+/);
          if (parts.length < 4) continue;

          var abbr = NAME_TO_ABBR[curTeam];
          var g = getGamesPlayedToDate(abbr);

          var rushYds = parseNum(parts[1]);
          var rushTD = parseNum(parts[3]);

          out[abbr] = {
            team: abbr,
            games: g,
            totalRushYds: nvl(rushYds, 0),
            rushYdsPerGame: (g > 0 ? (nvl(rushYds, 0) / g).toFixed(1) : "N/A"),
            rushTD: nvl(rushTD, 0)
          };

          curTeam = null;
        }
      }

      return out;
    };

    var computePointsAllowedFromSchedule = function(teamAbbr) {
      // Uses Sleeper schedule payload if present (home/away scores).
      // This is "actual points allowed", not an estimate.
      var games = self.nflScheduleGamesRaw;
      if (!Array.isArray(games) || !games.length) return { games: 0, pts: 0 };

      var pts = 0;
      var g = 0;

      var num = function(v) {
        if (v === null || v === undefined) return null;
        var n = parseFloat(String(v).replace(/[^\d\.\-]/g, ""));
        return isNaN(n) ? null : n;
      };

      for (var i = 0; i < games.length; i++) {
        var game = games[i];
        if (!game) continue;

        var home = game.home;
        var away = game.away;
        if (home !== teamAbbr && away !== teamAbbr) continue;

        // Sleeper schedule payloads commonly use home_score/away_score (but be defensive)
        var hs = num(game.home_score);
        var as = num(game.away_score);
        if (hs === null || as === null) continue; // unplayed or missing

        if (home === teamAbbr) pts += as;
        else pts += hs;

        g += 1;
      }

      return { games: g, pts: pts };
    };


    this.setProgress("Loading NFL defense stats (NFL.com)...", 76);

    return Promise.all([this.fetchText(passUrl), this.fetchText(rushUrl)]).then(function(resps) {
      var passParsed = parseDefensePassing(resps[0] || "");
      var rushParsed = parseDefenseRushing(resps[1] || "");

      var combined = {};
      // Seed with passing
      Object.keys(passParsed).forEach(function(abbr) {
        combined[abbr] = passParsed[abbr];
      });
      // Merge rushing
      Object.keys(rushParsed).forEach(function(abbr) {
        if (!combined[abbr]) combined[abbr] = { team: abbr, games: rushParsed[abbr].games || 17 };
        combined[abbr].games = nvl(combined[abbr].games, rushParsed[abbr].games || 17);
        combined[abbr].totalRushYds = rushParsed[abbr].totalRushYds || 0;
        combined[abbr].rushYdsPerGame = rushParsed[abbr].rushYdsPerGame || "0.0";
        combined[abbr].rushTD = rushParsed[abbr].rushTD || 0;
      });

      // Finalize + sanity
      Object.keys(combined).forEach(function(abbr) {
        var d = combined[abbr] || {};
        d.team = abbr;
        d.games = nvl(d.games, 17);
        d.totalPassYds = nvl(d.totalPassYds, 0);
        d.totalRushYds = nvl(d.totalRushYds, 0);
        d.passYdsPerGame = nvl(d.passYdsPerGame, (d.games > 0 ? (d.totalPassYds / d.games).toFixed(1) : "N/A"));
        d.rushYdsPerGame = nvl(d.rushYdsPerGame, (d.games > 0 ? (d.totalRushYds / d.games).toFixed(1) : "N/A"));
        d.passTD = nvl(d.passTD, 0);
        d.rushTD = nvl(d.rushTD, 0);
        d.interceptions = nvl(d.interceptions, 0);
        d.sacks = nvl(d.sacks, 0);

        // Keep compatibility with downstream UI/insights
        var pa = computePointsAllowedFromSchedule(abbr);
        if (pa && pa.games > 0) {
          d.totalPts = pa.pts;
          d.ptsPerGame = (pa.pts / pa.games).toFixed(1);
          // prefer points-derived games when available
          d.games = pa.games;
        } else {
          d.totalPts = 0;
          d.ptsPerGame = "N/A";
        }
        d.yardsEstimated = false;
        d.hasRealPassRushData = true;

        combined[abbr] = d;
      });

      // Require at least a handful of teams to avoid partial/blocked parses
      if (Object.keys(combined).length < 16) throw new Error("NFL.com parse returned too few teams (" + Object.keys(combined).length + ")");

      self.data.pfrDefenseStats = combined;
      self.data.hasRealPassRushData = true;

      // Cache
      try {
        localStorage.setItem(cacheKey, JSON.stringify({ t: Date.now(), v: combined }));
      } catch (e) { /* ignore */ }

      self.setProgress("Loaded NFL defense stats (NFL.com)", 86);
      self.loadSleeperDefenseStats(combined);
    }).catch(function(err) {
      console.warn("NFL.com defense stats load failed; using built-in snapshot.", err && err.message ? err.message : err);
      self._loadDefenseStatsFallback();
    });
  },


  _loadDefenseStatsFallback: function() {
    var self = this;
    var season = this.getSeason();
    var currentWeek = this.getMaxWeek() || 1;
    
    // NFL team abbreviations
    var nflTeams = ["ARI","ATL","BAL","BUF","CAR","CHI","CIN","CLE","DAL","DEN","DET","GB","HOU","IND","JAX","KC","LAC","LAR","LV","MIA","MIN","NE","NO","NYG","NYJ","PHI","PIT","SEA","SF","TB","TEN","WAS"];
    
    // Real 2025 NFL defensive stats from NFL.com (through Week 17)
    // Pass Yds = passing yards allowed, Rush Yds = rushing yards allowed
    var nflDefenseStats2025 = {
      ARI: { passYds: 3540, rushYds: 1895, passTD: 25, rushTD: 16, int: 10, sacks: 26, games: 17 },
      ATL: { passYds: 3245, rushYds: 1923, passTD: 24, rushTD: 11, int: 12, sacks: 50, games: 17 },
      BAL: { passYds: 3813, rushYds: 1634, passTD: 21, rushTD: 14, int: 10, sacks: 26, games: 17 },
      BUF: { passYds: 2724, rushYds: 2164, passTD: 17, rushTD: 24, int: 13, sacks: 34, games: 17 },
      CAR: { passYds: 3307, rushYds: 1793, passTD: 18, rushTD: 18, int: 13, sacks: 25, games: 17 },
      CHI: { passYds: 3433, rushYds: 1965, passTD: 28, rushTD: 12, int: 21, sacks: 31, games: 17 },
      CIN: { passYds: 3852, rushYds: 2340, passTD: 31, rushTD: 18, int: 13, sacks: 25, games: 17 },
      CLE: { passYds: 2816, rushYds: 1706, passTD: 22, rushTD: 14, int: 10, sacks: 49, games: 17 },
      DAL: { passYds: 4291, rushYds: 1972, passTD: 33, rushTD: 23, int: 6, sacks: 31, games: 17 },
      DEN: { passYds: 3470, rushYds: 1435, passTD: 18, rushTD: 11, int: 9, sacks: 64, games: 17 },
      DET: { passYds: 3815, rushYds: 1882, passTD: 29, rushTD: 16, int: 12, sacks: 48, games: 17 },
      GB:  { passYds: 3170, rushYds: 1557, passTD: 23, rushTD: 10, int: 7, sacks: 33, games: 17 },
      HOU: { passYds: 2964, rushYds: 1443, passTD: 17, rushTD: 11, int: 17, sacks: 41, games: 17 },
      IND: { passYds: 3994, rushYds: 1477, passTD: 23, rushTD: 13, int: 13, sacks: 37, games: 17 },
      JAX: { passYds: 3662, rushYds: 1309, passTD: 24, rushTD: 11, int: 19, sacks: 29, games: 17 },
      KC:  { passYds: 3382, rushYds: 1679, passTD: 18, rushTD: 14, int: 9, sacks: 32, games: 17 },
      LAC: { passYds: 2929, rushYds: 1557, passTD: 14, rushTD: 16, int: 17, sacks: 41, games: 17 },
      LAR: { passYds: 3591, rushYds: 1586, passTD: 23, rushTD: 7, int: 15, sacks: 41, games: 17 },
      LV:  { passYds: 3291, rushYds: 1747, passTD: 23, rushTD: 19, int: 8, sacks: 27, games: 17 },
      MIA: { passYds: 3360, rushYds: 1955, passTD: 26, rushTD: 14, int: 7, sacks: 36, games: 17 },
      MIN: { passYds: 2987, rushYds: 1982, passTD: 15, rushTD: 13, int: 8, sacks: 45, games: 17 },
      NE:  { passYds: 3220, rushYds: 1502, passTD: 24, rushTD: 10, int: 8, sacks: 30, games: 17 },
      NO:  { passYds: 2905, rushYds: 1893, passTD: 22, rushTD: 12, int: 9, sacks: 37, games: 17 },
      NYG: { passYds: 3573, rushYds: 2264, passTD: 24, rushTD: 19, int: 6, sacks: 35, games: 17 },
      NYJ: { passYds: 3304, rushYds: 2005, passTD: 27, rushTD: 18, int: 0, sacks: 25, games: 17 },
      PHI: { passYds: 3083, rushYds: 1852, passTD: 13, rushTD: 16, int: 11, sacks: 37, games: 17 },
      PIT: { passYds: 4013, rushYds: 1707, passTD: 26, rushTD: 10, int: 12, sacks: 43, games: 17 },
      SEA: { passYds: 3438, rushYds: 1411, passTD: 20, rushTD: 8, int: 16, sacks: 42, games: 17 },
      SF:  { passYds: 3582, rushYds: 1543, passTD: 27, rushTD: 10, int: 6, sacks: 18, games: 17 },
      TB:  { passYds: 3894, rushYds: 1520, passTD: 26, rushTD: 16, int: 12, sacks: 35, games: 17 },
      TEN: { passYds: 3617, rushYds: 1781, passTD: 25, rushTD: 19, int: 6, sacks: 38, games: 17 },
      WAS: { passYds: 4130, rushYds: 2331, passTD: 32, rushTD: 17, int: 7, sacks: 39, games: 17 }
    };
    
    // Initialize stats for all teams using real data
    var processedStats = {};
    nflTeams.forEach(function(team) {
      var stats = nflDefenseStats2025[team];
      if (stats) {
        var g = stats.games || 17;
        processedStats[team] = {
          team: team,
          games: g,
          totalPts: Math.round((stats.passTD + stats.rushTD) * 7 / 1.2), // Estimate pts from TDs
          totalPassYds: stats.passYds,
          totalRushYds: stats.rushYds,
          passYdsPerGame: (stats.passYds / g).toFixed(1),
          rushYdsPerGame: (stats.rushYds / g).toFixed(1),
          ptsPerGame: ((stats.passTD + stats.rushTD) * 7 / g / 1.2).toFixed(1),
          hasRealPassRushData: true,
          sacks: stats.sacks,
          interceptions: stats.int,
          passTD: stats.passTD,
          rushTD: stats.rushTD
        };
      } else {
        processedStats[team] = {
          team: team,
          games: 0,
          totalPts: 0,
          totalPassYds: 0,
          totalRushYds: 0,
          passYdsPerGame: "N/A",
          rushYdsPerGame: "N/A", 
          ptsPerGame: "0.0",
          hasRealPassRushData: false
        };
      }
    });
    
    self.data.pfrDefenseStats = processedStats;
    self.data.hasRealPassRushData = true; // We now have real data
    
    console.log("Loaded 2025 NFL defensive stats from NFL.com for all 32 teams");
    
    // Also try to get additional live data from Sleeper API (for current week updates)
    this.loadSleeperDefenseStats(processedStats);
  },
  
  // Secondary loader to merge any Sleeper API updates
  loadSleeperDefenseStats: function(baseStats) {
    var self = this;
    var season = this.getSeason();
    var currentWeek = this.getMaxWeek() || 1;
    
    // Try to get points allowed from Sleeper for more accurate scoring
    var url = "https://api.sleeper.com/stats/nfl/" + season + "/" + currentWeek + "?season_type=regular&position[]=DEF";
    
    this.fetchJson(url).then(function(weekData) {
      if (!Array.isArray(weekData)) return;
      
      weekData.forEach(function(d) {
        if (!d) return;
        var teamId = d.player_id || d.player || d.team;
        if (!teamId || !baseStats[teamId]) return;
        
        var stats = d.stats || d;
        // Update points allowed if available for current week
        if (stats.pts_allow !== undefined) {
          // We have live data for this team
          console.log("Got live Sleeper data for", teamId);
        }
      });
    }).catch(function(err) {
      console.log("Sleeper API supplement not available:", err.message);
    });
  },

  renderLeagueInsights: function() {
    var tbody = this.dom.leagueInsights;
    if (!tbody) return;
    var metrics = this.data.leagueMetrics;
    if (!metrics || !metrics.teams) {
      tbody.innerHTML = '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="9">League metrics not ready yet.</td></tr>';
      return;
    }

    var teamsArr = Object.values(metrics.teams);
    teamsArr.sort(function(a, b) {
      // Sort by expected wins then PF
      if (b.expW !== a.expW) return b.expW - a.expW;
      return b.pf - a.pf;
    });

    var rows = '';
    for (var i = 0; i < teamsArr.length; i++) {
      var t = teamsArr[i];
      rows += '<tr class="border-t border-gray-800 hover:bg-gray-900/40">' +
        '<td class="px-4 py-2 text-white font-bold">' + '<span class="inline-block w-2.5 h-2.5 rounded-full mr-2" style="background:' + this.rosterColor(t.roster_id) + '"></span>' + this.escapeHtml(t.name) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.w + '-' + t.l + (t.t ? ('-' + t.t) : '') + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.pf.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.pa.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + (t.allPlayPct * 100).toFixed(1) + '%</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.expW.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right font-mono ' + (t.luck >= 0 ? 'text-green-400' : 'text-red-400') + '">' + (t.luck >= 0 ? '+' : '') + t.luck.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.stddev.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.sos.toFixed(2) + '</td>' +
      '</tr>';
    }
    tbody.innerHTML = rows || '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="9">No teams.</td></tr>';
  },

renderLineupInsights: function() {
    var tbody = this.dom.leagueLineupInsights;
    if (!tbody) return;
    var metrics = this.data.leagueMetrics;
    if (!metrics || !metrics.teams) {
      tbody.innerHTML = '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="6">League metrics not ready yet.</td></tr>';
      return;
    }

    var teamsArr = Object.values(metrics.teams).map(function(t) {
      var opt = (t.optPf != null) ? t.optPf : 0;
      var bench = (t.benchPf != null) ? t.benchPf : 0;
      var regret = (t.regret != null) ? t.regret : Math.max(0, opt - (t.pf || 0));
      var eff = opt > 0 ? ( (t.pf || 0) / opt ) : 0;
      return {
        roster_id: t.roster_id,
        name: t.name || ("Team " + t.roster_id),
        pf: (t.pf || 0),
        optPf: opt,
        benchPf: bench,
        regret: regret,
        eff: eff
      };
    });

    // Default sort: efficiency desc, then regret asc, then PF desc
    teamsArr.sort(function(a, b) {
      if (b.eff !== a.eff) return b.eff - a.eff;
      if (a.regret !== b.regret) return a.regret - b.regret;
      return b.pf - a.pf;
    });

    var rows = "";
    for (var i = 0; i < teamsArr.length; i++) {
      var t = teamsArr[i];
      var effPct = (t.eff * 100);
      rows += '<tr class="border-t border-gray-800 hover:bg-gray-900/40">' +
        '<td class="px-4 py-2 text-white font-bold">' + this.escapeHtml(t.name) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.pf.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.optPf.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + t.benchPf.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right font-mono ' + (t.regret <= 0.01 ? 'text-green-400' : 'text-red-400') + '">' + t.regret.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + effPct.toFixed(1) + '%</td>' +
      '</tr>';
    }
    tbody.innerHTML = rows || '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="6">No teams.</td></tr>';

    // Top lists
    var bestBox = this.dom.insightsBestEfficiency;
    var regretBox = this.dom.insightsMostRegret;
    var benchBox = this.dom.insightsBenchLeaders;

    var topEff = teamsArr.slice().sort(function(a,b){ return b.eff - a.eff; }).slice(0, 3);
    var topRegret = teamsArr.slice().sort(function(a,b){ return b.regret - a.regret; }).slice(0, 3);
    var topBench = teamsArr.slice().sort(function(a,b){ return b.benchPf - a.benchPf; }).slice(0, 3);

    var renderMini = function(arr, valueFn, valueFmt, valueClsFn) {
      var out = "";
      for (var j = 0; j < arr.length; j++) {
        var x = arr[j];
        var val = valueFn(x);
        var cls = valueClsFn ? valueClsFn(x, val) : "text-gray-200";
        out += '<div class="flex items-center justify-between border border-gray-800 rounded-xl px-3 py-2 bg-gray-950/20">' +
          '<div class="text-sm text-white font-semibold truncate pr-3">' + APP.escapeHtml(x.name) + '</div>' +
          '<div class="text-sm font-mono ' + cls + '">' + valueFmt(val) + '</div>' +
        '</div>';
      }
      return out || '<div class="text-gray-400 text-sm">No data.</div>';
    };

    if (bestBox) bestBox.innerHTML = renderMini(topEff, function(x){ return x.eff * 100; }, function(v){ return v.toFixed(1) + '%'; }, function(){ return 'text-green-400'; });
    if (regretBox) regretBox.innerHTML = renderMini(topRegret, function(x){ return x.regret; }, function(v){ return v.toFixed(2); }, function(){ return 'text-red-400'; });
    if (benchBox) benchBox.innerHTML = renderMini(topBench, function(x){ return x.benchPf; }, function(v){ return v.toFixed(2); }, function(){ return 'text-gray-200'; });
  },

  renderPosBaselines: function() {
    var tbody = this.dom.posBaselineTable;
    if (!tbody) return;
    var metrics = this.data.leagueMetrics;
    var baselines = metrics && metrics.baselines ? metrics.baselines : null;
    if (!baselines) {
      tbody.innerHTML = '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="6">Baselines not ready yet.</td></tr>';
      return;
    }

    var order = ['QB','RB','WR','TE','K','DL','LB','DB'];
    var keys = Object.keys(baselines);
    keys.sort(function(a,b){
      var ia = order.indexOf(a);
      var ib = order.indexOf(b);
      ia = ia === -1 ? 999 : ia;
      ib = ib === -1 ? 999 : ib;
      if (ia !== ib) return ia - ib;
      return a.localeCompare(b);
    });

    var rows = "";
    for (var i = 0; i < keys.length; i++) {
      var pos = keys[i];
      var b = baselines[pos];
      if (!b || !b.n) continue;
      rows += '<tr class="border-t border-gray-800 hover:bg-gray-900/40">' +
        '<td class="px-4 py-2 text-white font-bold">' + this.escapeHtml(pos) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + b.median.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + b.p25.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + b.p75.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + b.avg.toFixed(2) + '</td>' +
        '<td class="px-4 py-2 text-right text-gray-200 font-mono">' + b.n + '</td>' +
      '</tr>';
    }
    tbody.innerHTML = rows || '<tr><td class="px-4 py-3 text-gray-400 text-sm" colspan="6">No baseline data.</td></tr>';
  },


  
  refreshTransactions: function(week) {
    var self = this;
    var w = Number(week);
    var primary = [w, 0, 18, 1, 17, 19].filter(function(x, idx, arr){ return x >= 0 && arr.indexOf(x) === idx; });
    var fetchOne = function(ww) {
      var url = "https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/transactions/" + ww + "?t=" + Date.now();
      return self.fetchJson(url).catch(function() { return []; });
    };
    return Promise.all(primary.map(fetchOne)).then(function(all) {
      // Merge unique by transaction_id
      var seen = new Set();
      var merged = [];
      all.forEach(function(arr) {
        (arr || []).forEach(function(tx) {
          var id = tx && (tx.transaction_id || tx.transaction_id === 0) ? String(tx.transaction_id) : JSON.stringify(tx);
          if (seen.has(id)) return;
          seen.add(id);
          merged.push(tx);
        });
      });
      self.data.weekTrans[String(w)] = merged;
      return merged;
    });
  },

  renderTrades: function() {
    var self = this;
    var content = this.dom.tradeContent;
    if (!content) return;

    var week = Number(this.ui.selectedWeek || 1);
    if (this.dom.tradeWeekLabel) this.dom.tradeWeekLabel.textContent = "Week " + week;

    var query = (this.dom.tradeSearch && this.dom.tradeSearch.value ? this.dom.tradeSearch.value : "").toLowerCase().trim();
    var type = (this.dom.tradeType && this.dom.tradeType.value) ? this.dom.tradeType.value : "all";

    var tx = (this.data.weekTrans && this.data.weekTrans[String(week)]) || [];

    // If empty, attempt an automatic refresh once.
    if (!tx.length) {
      if (!this.data._txAutoTried) this.data._txAutoTried = {};
      if (!this.data._txAutoTried[String(week)]) {
        this.data._txAutoTried[String(week)] = true;
        content.innerHTML = '<div class="text-gray-400 text-sm">Loading transactions‚Ä¶</div>';
        this.refreshTransactions(week).then(function() { self.renderTrades(); });
        return;
      }
    }

    var matchesType = function(t) {
      if (!t) return false;
      var tt = t.type || "";
      if (type === "all") return true;
      if (type === "add_drop") return (tt === "free_agent" || tt === "waiver");
      return tt === type;
    };

    var items = (tx || []).filter(matchesType).filter(function(t) {
      if (!query) return true;
      var blob = JSON.stringify(t).toLowerCase();
      return blob.indexOf(query) !== -1;
    });

    items.sort(function(a,b){
      var ta = Number(a.created || a.created_at || 0);
      var tb = Number(b.created || b.created_at || 0);
      return tb - ta;
    });

    if (!items.length) {
      content.innerHTML = '<div class="text-gray-400 text-sm">No transactions found for Week ' + week + '.</div>';
      return;
    }

    var rosterName = function(rid) {
      var r = (self.data.rosters || []).find(function(x){ return String(x.roster_id) === String(rid); });
      var u = r ? self.data.usersById[r.owner_id] : null;
      return (u && u.display_name) ? u.display_name : ("Team " + rid);
    };

    var playerLabel = function(pid) {
      var p = self.data.playersById[String(pid)] || {};
      var disp = self.playerDisplay(p);
      var seasonTotal = (self.data.seasonTotals && self.data.seasonTotals[pid]) || 0;
      return (disp.name || ("Player " + pid)) + (disp.pos ? (" (" + disp.pos + ")") : "");
    };

    var pointsFor = function(pid) {
      var v = self.data.seasonTotals ? self.data.seasonTotals[String(pid)] : null;
      return (v !== null && v !== undefined) ? Number(v) : 0;
    };

    var txTitle = function(t) {
      var tt = t.type || "transaction";
      if (tt === "trade") return "Trade";
      if (tt === "free_agent") return "Free Agent Add";
      if (tt === "waiver") return "Waiver";
      return tt.replace(/_/g, " ").replace(/\b\w/g, function(c){ return c.toUpperCase(); });
    };

    var txMeta = function(t) {
      var parts = [];
      if (t.status) parts.push(String(t.status));
      var created = t.created || t.created_at || null;
      if (created) parts.push(new Date(created).toLocaleString());
      // Bid / FAAB info if present
      var st = t.settings || {};
      var bid = (st.waiver_bid != null) ? st.waiver_bid : ((st.faab_bid != null) ? st.faab_bid : null);
      if (bid != null && bid !== "") parts.push("Bid: " + bid);
      return parts.join(" ‚Ä¢ ");
    };

    var html = '<div class="space-y-3">';

    items.forEach(function(t) {
      var rosterIds = (t.roster_ids || []).map(function(x){ return String(x); });
      var adds = t.adds || {};
      var drops = t.drops || {};
      var picks = t.draft_picks || [];

      // Some non-trade transactions may omit roster_ids; infer from adds/drops.
      var inferredSet = new Set(rosterIds);
      Object.keys(adds).forEach(function(pid){ inferredSet.add(String(adds[pid])); });
      Object.keys(drops).forEach(function(pid){ inferredSet.add(String(drops[pid])); });
      rosterIds = Array.from(inferredSet).filter(function(x){ return x && x !== "null" && x !== "undefined"; });

      var perRoster = {};
      rosterIds.forEach(function(rid) {
        perRoster[rid] = { recv: [], recvPts: 0, picks: [], adds: [], drops: [] };
      });

      // Players received (trade or add). We keep both `recv` (trade semantics) and `adds` (explicit add).
      Object.keys(adds).forEach(function(pid) {
        var toRid = String(adds[pid]);
        if (!perRoster[toRid]) perRoster[toRid] = { recv: [], recvPts: 0, picks: [], adds: [], drops: [] };
        perRoster[toRid].recv.push(String(pid));
        perRoster[toRid].adds.push(String(pid));
        perRoster[toRid].recvPts += pointsFor(pid);
      });

      // Drops (free agent / waiver)
      Object.keys(drops).forEach(function(pid) {
        var fromRid = String(drops[pid]);
        if (!perRoster[fromRid]) perRoster[fromRid] = { recv: [], recvPts: 0, picks: [], adds: [], drops: [] };
        perRoster[fromRid].drops.push(String(pid));
      });

      // Draft picks (trades)
      picks.forEach(function(pk) {
        var toRid = String(pk.roster_id);
        if (!perRoster[toRid]) perRoster[toRid] = { recv: [], recvPts: 0, picks: [], adds: [], drops: [] };
        var fromRid = pk.previous_owner_id != null ? String(pk.previous_owner_id) : null;
        var label = (pk.season ? pk.season : '') + ' R' + (pk.round != null ? pk.round : '?') +
          (pk.order != null ? (' #' + pk.order) : '') +
          (fromRid ? (' (from ' + self.escapeHtml(rosterName(fromRid)) + ')') : '');
        perRoster[toRid].picks.push(label);
      });

      // If exactly 2 rosters, infer "sent" lists as the opposite of receives (best effort).
      var inferredSent = {};
      if (rosterIds.length === 2 && (t.type === "trade")) {
        var a = rosterIds[0], b = rosterIds[1];
        inferredSent[a] = (perRoster[b] ? perRoster[b].recv.slice() : []);
        inferredSent[b] = (perRoster[a] ? perRoster[a].recv.slice() : []);
      }

      var title = txTitle(t);
      var meta = txMeta(t);

      html += '<div class="bg-gray-950/40 border border-gray-800 rounded-2xl p-4">' +
        '<div class="flex items-start justify-between gap-3">' +
          '<div>' +
            '<div class="text-white font-bold">' + self.escapeHtml(title) + '</div>' +
            '<div class="text-xs text-gray-400 font-mono">' + self.escapeHtml(meta || "‚Äî") + '</div>' +
          '</div>' +
          '<div class="text-xs text-gray-500 font-mono">Week ' + week + '</div>' +
        '</div>';

      if (!rosterIds.length) {
        html += '<div class="mt-3 text-sm text-gray-400">No roster details available for this transaction.</div></div>';
        return;
      }

      html += '<div class="mt-3 grid grid-cols-1 lg:grid-cols-' + Math.min(2, rosterIds.length) + ' gap-3">';

      rosterIds.forEach(function(rid) {
        var recv = (perRoster[rid] && perRoster[rid].recv) ? perRoster[rid].recv : [];
        var addsList = (perRoster[rid] && perRoster[rid].adds) ? perRoster[rid].adds : [];
        var dropsList = (perRoster[rid] && perRoster[rid].drops) ? perRoster[rid].drops : [];
        var picksLbl = (perRoster[rid] && perRoster[rid].picks) ? perRoster[rid].picks : [];

        var sent = (inferredSent[rid] || []);
        var net = (t.type === "trade") ? ((perRoster[rid] ? perRoster[rid].recvPts : 0) - sent.reduce(function(acc, pid){ return acc + pointsFor(pid); }, 0)) : 0;

        var hasAddDrop = (addsList.length || dropsList.length) && (t.type !== "trade");
        var header = self.escapeHtml(rosterName(rid));

        html += '<div class="bg-gray-950 border border-gray-800 rounded-xl p-3">' +
          '<div class="text-gray-200 font-bold truncate">' + header + '</div>';

        if (t.type === "trade") {
          html +=
            '<div class="mt-2">' +
              '<div class="text-xs text-gray-400 font-mono">Receives</div>' +
              '<div class="mt-1 text-sm text-gray-100">' +
                (recv.length ? recv.map(function(pid){ return self.escapeHtml(playerLabel(pid)); }).join(', ') : '<span class="text-gray-500">‚Äî</span>') +
              '</div>' +
            '</div>' +
            (picksLbl.length ? (
              '<div class="mt-2">' +
                '<div class="text-xs text-gray-400 font-mono">Picks</div>' +
                '<div class="mt-1 text-sm text-gray-100">' + picksLbl.map(function(x){ return self.escapeHtml(x); }).join(', ') + '</div>' +
              '</div>'
            ) : '') +
            '<div class="mt-2">' +
              '<div class="text-xs text-gray-400 font-mono">Sends (best-effort)</div>' +
              '<div class="mt-1 text-sm text-gray-100">' +
                (sent.length ? sent.map(function(pid){ return self.escapeHtml(playerLabel(pid)); }).join(', ') : '<span class="text-gray-500">‚Äî</span>') +
              '</div>' +
            '</div>' +
            '<div class="mt-2 text-xs font-mono ' + (net >= 0 ? 'text-green-400' : 'text-red-400') + '">Net (season pts only): ' + (net >= 0 ? '+' : '') + net.toFixed(2) + '</div>';
        } else if (hasAddDrop) {
          html +=
            '<div class="mt-2">' +
              '<div class="text-xs text-gray-400 font-mono">Adds</div>' +
              '<div class="mt-1 text-sm text-gray-100">' +
                (addsList.length ? addsList.map(function(pid){ return self.escapeHtml(playerLabel(pid)); }).join(', ') : '<span class="text-gray-500">‚Äî</span>') +
              '</div>' +
            '</div>' +
            '<div class="mt-2">' +
              '<div class="text-xs text-gray-400 font-mono">Drops</div>' +
              '<div class="mt-1 text-sm text-gray-100">' +
                (dropsList.length ? dropsList.map(function(pid){ return self.escapeHtml(playerLabel(pid)); }).join(', ') : '<span class="text-gray-500">‚Äî</span>') +
              '</div>' +
            '</div>';
        } else {
          // Fallback summary
          html += '<div class="mt-2 text-sm text-gray-400">No add/drop details found.</div>';
        }

        html += '</div>';
      });

      html += '</div></div>';
    });

    html += '</div>';
    content.innerHTML = html;
  },


  buildSeasonTotals: function() {
    var self = this;
    var currentWeek = this.getMaxWeek();
    return this.ensureWeeksLoadedUpTo(currentWeek).then(function() {
      var totals = {};
      for (var w = 1; w <= currentWeek; w++) {
        var statsMap = self.data.weekStats[String(w)] || {};
        var entries = Object.entries(statsMap);
        for (var i = 0; i < entries.length; i++) {
          var pid = entries[i][0];
          var s = entries[i][1];
          if (!s || Object.keys(s).length === 0) continue;
          totals[pid] = (totals[pid] || 0) + self.scoreFromStats(s, pid);
        }
      }
      Object.keys(totals).forEach(function(pid) {
        totals[pid] = Math.round(totals[pid] * 100) / 100;
      });
      self.data.seasonTotals = totals;
    });
  },

  // ---------- Player Value (0-1000) ----------
  // Builds a season-to-date per-player value score using: PPG, last-4, boom/bust, snap%, consistency, age, and over/under expectation.
  buildPlayerValueIndex: function() {
    var self = this;
    var currentWeek = Number(this.getMaxWeek());

    // Aggregate per-player season metrics in one pass across week stats (fast).
    var agg = {}; // pid -> metrics

    var initAgg = function() {
      return {
        total: 0, games: 0, ppgSum: 0, ppgGames: 0,
        lastActs: [],
        boom: 0, bust: 0, within: 0, bbN: 0,
        deltaSum: 0, deltaN: 0,
        snapSum: 0, snapN: 0,
        // Welford for variance
        mean: 0, m2: 0
      };
    };

    for (var w = 1; w <= currentWeek; w++) {
      var wk = String(w);
      var statsMap = self.data.weekStats[wk] || {};
      var projMap  = self.data.weekProj[wk] || {};
      var pids = Object.keys(statsMap);
      for (var i = 0; i < pids.length; i++) {
        var pid = String(pids[i]);
        var s = statsMap[pid];
        if (!s || Object.keys(s).length === 0) continue;

        var a = agg[pid] || (agg[pid] = initAgg());
        var act = self.scoreFromStats(s, pid);
        a.total += act;
        a.games += 1;

        // Keep last-4 played games
        a.lastActs.push(act);
        if (a.lastActs.length > 4) a.lastActs.shift();

        // Consistency (variance)
        var delta = act - a.mean;
        a.mean += delta / a.games;
        a.m2 += delta * (act - a.mean);

        // Boom/Bust + Delta vs projections (only when projections exist)
        var projStats = projMap[pid] || {};
        var proj = self.scoreFromStats(projStats, pid);
        if (proj > 0) {
          a.ppgSum += act;
          a.ppgGames += 1;
          a.bbN += 1;
          a.deltaSum += (act - proj);
          a.deltaN += 1;
          if (act >= proj * self.cfg.boomPct) a.boom += 1;
          else if (act <= proj * self.cfg.bustPct) a.bust += 1;
          else a.within += 1;
        }

        // Snap % (best-effort ‚Äî keys vary by data source)
        var sp = self.extractSnapPct(s);
        if (sp !== null && isFinite(sp)) {
          a.snapSum += sp;
          a.snapN += 1;
        }
      }
    }

    // Compute per-player derived metrics
    var byGroup = {}; // group -> array of pids
    var metrics = {}; // pid -> computed

    var allPids = Object.keys(agg);
    for (var j = 0; j < allPids.length; j++) {
      var pid2 = String(allPids[j]);
      var a2 = agg[pid2];
      if (!a2 || !a2.games) continue;

      var p = self.data.playersById[pid2] || {};
      var group = self.positionGroupForPlayer(p);
      if (!group) continue;

      var ppg = (a2.ppgGames ? (a2.ppgSum / a2.ppgGames) : (a2.games ? (a2.total / a2.games) : 0));
      var l4 = a2.lastActs.length ? (a2.lastActs.reduce(function(x,y){return x+y;},0) / a2.lastActs.length) : ppg;

      var stdev = (a2.games > 1) ? Math.sqrt(a2.m2 / (a2.games - 1)) : 0;
      var cv = (ppg > 0) ? (stdev / (ppg + 1e-6)) : 0;
      var consistency = self.clamp01(1 - (cv / 1.0)); // cv>=1 -> 0

      var boomRate = (a2.bbN > 0) ? (a2.boom / a2.bbN) : 0;
      var bustRate = (a2.bbN > 0) ? (a2.bust / a2.bbN) : 0;
      var bbAdj = (a2.bbN > 0) ? self.clamp01((boomRate - bustRate + 1) / 2) : 0.5;

      var snap = (a2.snapN > 0) ? (a2.snapSum / a2.snapN) : null; // percent (0..100)
      var snapAdj = (snap === null) ? 0.5 : self.clamp01(snap / 100);

      var deltaAvg = (a2.deltaN > 0) ? (a2.deltaSum / a2.deltaN) : 0;

      var age = self.playerAge(p);
      var ageAdj = self.ageAdjForGroup(group, age);

      metrics[pid2] = {
        pid: pid2, group: group,
        games: a2.games,
        ppgGames: a2.ppgGames || 0,
        total: a2.total,
        ppg: ppg,
        l4: l4,
        boomRate: boomRate,
        bustRate: bustRate,
        consistency: consistency,
        snap: snap,
        snapAdj: snapAdj,
        deltaAvg: deltaAvg,
        deltaN: a2.deltaN || 0,
        bbAdj: bbAdj,
        age: age,
        ageAdj: ageAdj,
        value: 0
      };

      (byGroup[group] || (byGroup[group] = [])).push(pid2);
    }


// Build PPG ranks within major position group (PPG = season points / games played).
// Uses only weeks where the player has a stats payload (i.e., ignores missed games).
// Minimum games played required to receive a PPG rank (helps avoid tiny-sample noise).
var MIN_GAMES_PPG_RANK = 6;

var ppgRanks = {};
Object.keys(byGroup).forEach(function(group) {
  // Only rank players with enough games played
  var eligible = (byGroup[group] || []).filter(function(pid) {
    var m = metrics[pid];
    return !!m && isFinite(m.ppg) && (m.ppgGames >= MIN_GAMES_PPG_RANK);
  });

  eligible.sort(function(a, b) {
    var pa = metrics[a].ppg;
    var pb = metrics[b].ppg;
    return pb - pa;
  });

  for (var r = 0; r < eligible.length; r++) {
    var pidR = eligible[r];
    var mR = metrics[pidR];
    if (!mR) continue;
    ppgRanks[pidR] = { pos: group, rank: r + 1, ppg: mR.ppg, games: mR.ppgGames };
  }
});
self.data.playerPpgRanks = ppgRanks;


// Build AVG DELTA PPG ranks within major groups (delta = actual - projection; ignores weeks with no projection).
var MIN_GAMES_DELTA_RANK = 6;
var deltaRanks = {};
var groupsD = { QB:[], RB:[], WR:[], TE:[], K:[], DEF:[], DL:[], LB:[], DB:[] };
Object.keys(metrics).forEach(function(pidD) {
  var mD = metrics[pidD];
  if (!mD) return;
  var gD = mD.group;
  if (!groupsD[gD]) return;
  if (mD.deltaN >= MIN_GAMES_DELTA_RANK) groupsD[gD].push({ pid: pidD, delta: mD.deltaAvg, games: mD.deltaN });
});
Object.keys(groupsD).forEach(function(groupD) {
  var arrD = groupsD[groupD] || [];
  arrD.sort(function(a,b){ return b.delta - a.delta; });
  for (var iD = 0; iD < arrD.length; iD++) {
    var rowD = arrD[iD];
    deltaRanks[rowD.pid] = { pos: groupD, rank: iD + 1, delta: rowD.delta, games: rowD.games };
  }
});
self.data.playerDeltaRanks = deltaRanks;



    // Percentile helper
    var buildPercentiles = function(pids, accessor) {
      var arr = pids
        .map(function(pid){ return { pid: pid, v: accessor(metrics[pid]) }; })
        .filter(function(x){ return isFinite(x.v); })
        .sort(function(a,b){ return a.v - b.v; }); // ascending
      var n = arr.length;
      var out = {};
      if (n <= 1) {
        if (n === 1) out[arr[0].pid] = 1;
        return out;
      }
      for (var k = 0; k < n; k++) out[arr[k].pid] = k / (n - 1);
      return out;
    };

    // Position scarcity multipliers (TE/QB more valuable due to fewer elite options)
    var positionScarcity = {
      "TE": 1.12,
      "QB": 1.08,
      "RB": 1.04,
      "WR": 1.00,
      "K": 1.00,
      "DEF": 1.00,
      "DL": 1.00,
      "LB": 1.00,
      "DB": 1.00
    };

    var values = {}; // pid -> {score, breakdown}
    Object.keys(byGroup).forEach(function(group) {
      var pids = byGroup[group];

      var pctPPG   = buildPercentiles(pids, function(m){ return m.ppg; });
      var pctTotal = buildPercentiles(pids, function(m){ return m.total; });
      var pctL4    = buildPercentiles(pids, function(m){ return m.l4; });
      var pctDlt   = buildPercentiles(pids, function(m){ return m.deltaAvg; });

      var scarcityMult = positionScarcity[group] || 1.00;

      for (var i2 = 0; i2 < pids.length; i2++) {
        var pid = pids[i2];
        var m3 = metrics[pid];
        if (!m3) continue;

        var ppgP   = (pctPPG[pid] !== undefined) ? pctPPG[pid] : 0.5;
        var totalP = (pctTotal[pid] !== undefined) ? pctTotal[pid] : 0.5;
        var l4P    = (pctL4[pid]  !== undefined) ? pctL4[pid]  : 0.5;
        var dltP   = (pctDlt[pid] !== undefined) ? pctDlt[pid] : 0.5;

        // Weighted season value (0..1)
        // Emphasizes: consistency, PPG, total points, boom/bust, delta, snap share
        // De-emphasizes: recent games (L4)
        var raw =
          0.28 * ppgP +
          0.15 * totalP +
          0.16 * m3.consistency +
          0.12 * m3.bbAdj +
          0.10 * dltP +
          0.08 * m3.snapAdj +
          0.05 * l4P +
          0.03 * m3.ageAdj +
          0.03 * (scarcityMult - 1.0) * 5; // scarcity bonus (0..0.03 range for TE)

        raw = self.clamp01(raw);
        var score = Math.round(raw * 1000);

        m3.value = score;
        values[pid] = {
          score: score,
          breakdown: {
            group: group,
            games: m3.games,
            ppg: m3.ppg,
            total: m3.total,
            l4: m3.l4,
            boom: m3.boomRate,
            bust: m3.bustRate,
            snap: m3.snap,
            deltaAvg: m3.deltaAvg,
            consistency: m3.consistency,
            age: m3.age,
            scarcity: scarcityMult
          }
        };
      }
    });

    this.data.playerValues = values;
    this.data.playerValueMetrics = metrics;
  },

  // Map a Sleeper player.position to a stable group used for ranks and value.
  positionGroupForPlayer: function(p) {
    if (!p || !p.position) return null;
    var pos = String(p.position || "").toUpperCase();
    var groups = {
      "QB": ["QB"],
      "RB": ["RB"],
      "WR": ["WR"],
      "TE": ["TE"],
      "K":  ["K"],
      "DEF":["DEF"],
      "DL": ["DL", "DE", "DT", "NT"],
      "LB": ["LB", "ILB", "OLB", "MLB"],
      "DB": ["DB", "CB", "S", "SS", "FS"]
    };
    var g = null;
    Object.keys(groups).forEach(function(key) {
      if (groups[key].indexOf(pos) >= 0) g = key;
    });
    return g;
  },

  // Best-effort snap% extraction from Sleeper stat payloads. Returns number 0..100 or null.
  extractSnapPct: function(statObj) {
    if (!statObj) return null;
    var keys = [
      "snap_pct", "snap_percent", "snap_percentage",
      "off_snp_pct", "def_snp_pct", "snp_pct",
      "snap_pct_off", "snap_pct_def"
    ];
    for (var i = 0; i < keys.length; i++) {
      if (statObj[keys[i]] !== undefined && statObj[keys[i]] !== null) {
        var v = parseFloat(statObj[keys[i]]);
        if (!isFinite(v)) continue;
        if (v <= 1) return this.clamp01(v) * 100;
        if (v > 1 && v <= 100) return v;
      }
    }
    return null;
  },

  // Age adjustment by position group (0..1). Small influence only.
  ageAdjForGroup: function(group, ageYears) {
    if (!isFinite(ageYears)) return 0.5;
    var peak = { QB: 33, RB: 27, WR: 29, TE: 31, K: 33, DEF: 99, DL: 30, LB: 30, DB: 29 };
    var span = { QB: 10, RB: 6,  WR: 7,  TE: 8,  K: 8,  DEF: 1,  DL: 7,  LB: 7,  DB: 7 };
    var p = peak[group];
    if (!p || p === 99) return 0.5; // DEF: neutral
    var s = span[group] || 7;
    if (ageYears <= p) return 1;
    return this.clamp01(1 - ((ageYears - p) / s));
  },

  clamp01: function(x) {
    x = Number(x);
    if (!isFinite(x)) return 0;
    if (x < 0) return 0;
    if (x > 1) return 1;
    return x;
  },

  // Value lookup (returns {score, breakdown} or null)
  getPlayerValue: function(pid) {
    pid = String(pid);
    return (this.data.playerValues && this.data.playerValues[pid]) ? this.data.playerValues[pid] : null;
  },


// PPG rank lookup within major position group (PPG = season points / games played; ignores missed games).
getPlayerPpgRank: function(pid) {
  pid = String(pid);
  return (this.data.playerPpgRanks && this.data.playerPpgRanks[pid]) ? this.data.playerPpgRanks[pid] : null;
},


// Avg delta PPG rank lookup within major position group (delta = actual - projection; ignores weeks with no projection).
getPlayerDeltaRank: function(pid) {
  pid = String(pid);
  return (this.data.playerDeltaRanks && this.data.playerDeltaRanks[pid]) ? this.data.playerDeltaRanks[pid] : null;
},

  // HTML badge for value score (2K MyTeam style, 0-1000 scale).
  valueBadgeHtml: function(score) {
    if (!isFinite(score)) return "";
    var s = Math.round(score);
    var tier, cls;
    
    if (s >= 950) {
      tier = "GOAT";
      cls = "myteam-badge-goat";
    } else if (s >= 900) {
      tier = "DM";
      cls = "myteam-badge-darkmatter";
    } else if (s >= 850) {
      tier = "PD";
      cls = "myteam-badge-pinkdiamond";
    } else if (s >= 780) {
      tier = "üíé";
      cls = "myteam-badge-diamond";
    } else if (s >= 700) {
      tier = "AMY";
      cls = "myteam-badge-amethyst";
    } else if (s >= 600) {
      tier = "RBY";
      cls = "myteam-badge-ruby";
    } else if (s >= 500) {
      tier = "SPH";
      cls = "myteam-badge-sapphire";
    } else if (s >= 400) {
      tier = "GLD";
      cls = "myteam-badge-gold";
    } else if (s >= 280) {
      tier = "SLV";
      cls = "myteam-badge-silver";
    } else {
      tier = "BRZ";
      cls = "myteam-badge-bronze";
    }
    
    return '<span class="myteam-badge ' + cls + '">' + s + ' <span class="myteam-tier">' + tier + '</span></span>';
  },

  // Get tier info for a score (2K MyTeam style, 0-1000 scale)
  getTierInfo: function(score) {
    if (!isFinite(score)) return { tier: "BRZ", name: "Bronze", color: "#CD7F32" };
    var s = Math.round(score);
    
    if (s >= 950) return { tier: "GOAT", name: "G.O.A.T", color: "#FFD700", glow: "rainbow" };
    if (s >= 900) return { tier: "DM", name: "Dark Matter", color: "#1a0033", glow: "#9400D3" };
    if (s >= 850) return { tier: "PD", name: "Pink Diamond", color: "#FF69B4", glow: "#FF1493" };
    if (s >= 780) return { tier: "DIA", name: "Diamond", color: "#B9F2FF", glow: "#00BFFF" };
    if (s >= 700) return { tier: "AMY", name: "Amethyst", color: "#9966CC", glow: "#8B008B" };
    if (s >= 600) return { tier: "RBY", name: "Ruby", color: "#E0115F", glow: "#DC143C" };
    if (s >= 500) return { tier: "SPH", name: "Sapphire", color: "#0F52BA", glow: "#1E90FF" };
    if (s >= 400) return { tier: "GLD", name: "Gold", color: "#FFD700", glow: "#FFA500" };
    if (s >= 280) return { tier: "SLV", name: "Silver", color: "#C0C0C0", glow: "#A9A9A9" };
    return { tier: "BRZ", name: "Bronze", color: "#CD7F32", glow: "#8B4513" };
  },

  openMatchupModal: function(matchupIdLabel, rosterAId, rosterBId) {
    var self = this;
    var week = String(this.ui.selectedWeek);
    var statsMap = this.data.weekStats[week] || {};
    var projMap = this.data.weekProj[week] || {};
    var rosterA = this.data.rosters.find(function(r) { return String(r.roster_id) === String(rosterAId); });
    var rosterB = this.data.rosters.find(function(r) { return String(r.roster_id) === String(rosterBId); });
    if (!rosterA || !rosterB) return;

    var userA = this.data.usersById[rosterA.owner_id];
    var userB = this.data.usersById[rosterB.owner_id];
    var teamAName = (userA && userA.display_name) || ("Team " + rosterA.roster_id);
    var teamBName = (userB && userB.display_name) || ("Team " + rosterB.roster_id);

    var hybridForPid = function(pid) {
      pid = String(pid);
      var s = statsMap[pid] || {};
      var p = projMap[pid] || {};
      var hasPlayed = Object.keys(s).length > 0;
      var act = hasPlayed ? self.scoreFromStats(s, pid) : null;
      var proj = self.scoreFromStats(p, pid);
      return { hasPlayed: hasPlayed, act: act, proj: proj, show: hasPlayed ? act : proj };
    };

    var buildList = function(roster) {
      var slots = (self.data.league && self.data.league.roster_positions) || [];
      var out = [];
      var mu = self.getMatchupForRoster(Number(week), roster.roster_id);
      var starters = (mu && Array.isArray(mu.starters)) ? mu.starters : (roster.starters || []);
      for (var i = 0; i < starters.length; i++) {
        var pid = starters[i];
        var p = self.data.playersById[String(pid)] || {};
        var disp = self.playerDisplay(p);
        var scores = hybridForPid(pid);
        var opp = self.getOpponent(statsMap[String(pid)] || {}, projMap[String(pid)] || {}, p, Number(week));
        out.push({
          pid: String(pid), slot: slots[i] || "ST", name: disp.name, pos: disp.pos,
          team: disp.team, opp: opp || "‚Äî", inj: self.injuryTag(p),
          hasPlayed: scores.hasPlayed, act: scores.act, proj: scores.proj, show: scores.show
        });
      }
      var total = Math.round(out.reduce(function(a, r) { return a + (r.show || 0); }, 0) * 100) / 100;
      return { rows: out, total: total };
    };

    var A = buildList(rosterA);
    var B = buildList(rosterB);

    if (this.dom.mmTitle) this.dom.mmTitle.textContent = "Week " + this.ui.selectedWeek + " ‚Ä¢ Matchup " + (matchupIdLabel || "‚Äî");
    if (this.dom.mmTeamA) this.dom.mmTeamA.textContent = teamAName;
    if (this.dom.mmTeamB) this.dom.mmTeamB.textContent = teamBName;
    if (this.dom.mmTotalA) this.dom.mmTotalA.textContent = A.total.toFixed(2);
    if (this.dom.mmTotalB) this.dom.mmTotalB.textContent = B.total.toFixed(2);

    var renderSide = function(rows, container) {
      if (!container) return;
      container.innerHTML = "";
      rows.forEach(function(r) {
        var row = document.createElement("div");
        row.className = "grid grid-cols-12 gap-2 items-center px-3 py-2 border-b border-gray-800 last:border-b-0 hover:bg-gray-900/30 cursor-pointer";
        var scoreCls = r.hasPlayed ? self.scoreColor(r.proj, r.act, true) : "text-gray-200";
        row.innerHTML = 
          '<div class="col-span-2 text-xs font-mono text-gray-400">' + r.slot + '</div>' +
          '<div class="col-span-7 min-w-0">' +
            '<div class="flex items-center gap-2 min-w-0">' +
              self.playerImg(r.pid, self.data.playersById[r.pid], "w-8 h-8") +
              '<div class="min-w-0"><div class="font-bold text-white truncate">' + r.name + r.inj + '</div></div>' +
            '</div>' +
            '<div class="text-[11px] text-gray-500 font-mono truncate">' + r.pos + ' ‚Ä¢ ' + r.team + ' ‚Ä¢ vs ' + r.opp + '</div>' +
          '</div>' +
          '<div class="col-span-3 text-right">' +
            '<div class="text-sm font-black ' + scoreCls + '">' + (r.show || 0).toFixed(2) + '</div>' +
            '<div class="text-[10px] text-gray-500 font-mono">P ' + r.proj.toFixed(2) + (r.hasPlayed ? ' ‚Ä¢ A ' + r.act.toFixed(2) : '') + '</div>' +
          '</div>';
        row.onclick = function() { self.openPlayerModal(r.pid); };
        container.appendChild(row);
      });
    };

    renderSide(A.rows, this.dom.mmListA);
    renderSide(B.rows, this.dom.mmListB);

    this.dom.matchupModal.classList.remove("hidden");
    this.dom.matchupModal.classList.add("flex");
  },

  closeMatchupModal: function() {
    if (this.dom.matchupModal) {
      this.dom.matchupModal.classList.add("hidden");
      this.dom.matchupModal.classList.remove("flex");
    }
  },

  positionRank: function(playerId) {
    var p = this.data.playersById[playerId];
    if (!p || !p.position) return null;
    var self = this;
    var totals = this.data.seasonTotals || {};

    // Map specific positions to general categories for ranking
    var positionGroups = {
      "QB": ["QB"],
      "RB": ["RB"],
      "WR": ["WR"],
      "TE": ["TE"],
      "K": ["K"],
      "DEF": ["DEF"],
      "DL": ["DL", "DE", "DT", "NT"],
      "LB": ["LB", "ILB", "OLB", "MLB"],
      "DB": ["DB", "CB", "S", "SS", "FS"]
    };

    // Find which group this player belongs to
    var playerGroup = null;
    var groupName = null;
    Object.keys(positionGroups).forEach(function(group) {
      if (positionGroups[group].indexOf(p.position) >= 0) {
        playerGroup = positionGroups[group];
        groupName = group;
      }
    });

    if (!playerGroup) return null;

    // Get all players in this position group with season totals, sorted by custom score
    var pool = Object.values(this.data.playersById)
      .filter(function(x) { 
        if (!x || !x.position) return false;
        var inGroup = playerGroup.indexOf(x.position) >= 0;
        var hasStats = totals[String(x.player_id)] > 0;
        return inGroup && hasStats;
      })
      .sort(function(a, b) { 
        var ta = totals[String(a.player_id)] || 0;
        var tb = totals[String(b.player_id)] || 0;
        return tb - ta; // Higher score = better rank
      });

    var idx = pool.findIndex(function(x) { return String(x.player_id) === String(playerId); });
    return idx < 0 ? null : { pos: groupName, rank: idx + 1 };
  },

  // Switch to a different season/league without page reload (Google Apps Script compatible)
  switchSeason: function(year) {
    var self = this;
    year = String(year);
    
    if (!this.cfg.seasonLeagues || !this.cfg.seasonLeagues[year]) {
      console.error("Invalid season year:", year);
      return;
    }
    
    // Show loading state
    this.setProgress("Switching to " + year + " season‚Ä¶", 5);
    
    // Destroy any existing charts
    try {
      if (this.ui.chart) { this.ui.chart.destroy(); this.ui.chart = null; }
      if (this.ui.pfChart) { this.ui.pfChart.destroy(); this.ui.pfChart = null; }
      if (this.ui.luckChart) { this.ui.luckChart.destroy(); this.ui.luckChart = null; }
      if (this.ui.trendsChart) { this.ui.trendsChart.destroy(); this.ui.trendsChart = null; }
    } catch(e) { console.warn("Chart cleanup error:", e); }
    
    // Update config
    this.cfg.selectedSeasonChoice = year;
    this.cfg.leagueId = this.cfg.seasonLeagues[year];
    
    // Reset all data to initial state
    this.data = {
      nflState: null,
      league: null,
      appSeason: null,
      maxWeek: null,
      usersById: {},
      rosters: [],
      matchups: [],
      weekMatchups: {},
      weekTrans: {},
      teamWeekScores: {},
      leagueMetrics: null,
      playersById: {},
      weekStats: {},
      weekProj: {},
      weekLoadPromises: {},
      winnersBracket: [],
      losersBracket: [],
      seasonTotals: null,
      pfrDefenseStats: null,
      nflSchedule: null,
      playerDeltaRanks: {},
      defRoleMetrics: null,
      playerValueIndex: null
    };
    
    // Reset NFL schedule
    this.nflSchedule = {};
    this.nflScheduleGamesRaw = null;
    
    // Reset UI state (keep currentView)
    var currentView = this.ui.currentView;
    this.ui = {
      currentView: currentView,
      selectedRosterId: null,
      selectedWeek: null,
      selectedFA: "QB",
      selectedConference: "AFC",
      chart: null,
      pfChart: null,
      luckChart: null,
      trendsChart: null,
      historySelectedWeek: null,
      historySelectedRosterId: null,
      historyMatchups: null,
      faConfig: [],
      defRoleKey: null,
      defRoleSort: null,
      optSettingsOpen: false,
      optWeights: null
    };
    
    // Clear DOM elements that might have stale content
    try {
      if (this.dom.rosterList) this.dom.rosterList.innerHTML = '<div class="text-gray-500 text-sm">Loading...</div>';
      if (this.dom.faList) this.dom.faList.innerHTML = '';
      if (this.dom.teamTabs) this.dom.teamTabs.innerHTML = '';
      if (this.dom.matchupCards) this.dom.matchupCards.innerHTML = '';
      if (this.dom.defenseGrid) this.dom.defenseGrid.innerHTML = '';
      if (this.dom.tradeContent) this.dom.tradeContent.innerHTML = '';
      if (this.dom.weekSelect) this.dom.weekSelect.innerHTML = '';
      if (this.dom.matchupsWeekSelect) this.dom.matchupsWeekSelect.innerHTML = '';
      if (this.dom.historyWeekSelect) this.dom.historyWeekSelect.innerHTML = '';
      if (this.dom.defRoleSelect) { this.dom.defRoleSelect.innerHTML = ''; this.dom.defRoleSelect._populated = false; }
    } catch(e) { console.warn("DOM cleanup error:", e); }
    
    // Update season selector to show new value
    if (this.dom.seasonSelect) {
      try { this.dom.seasonSelect.value = year; } catch(e) {}
    }
    
    // Re-run initialization
    this.init();
  },

  init: function() {
    var self = this;

    // Apply saved settings (if any)
    try { if (self.loadAppSettings) self.loadAppSettings(); } catch(e) {}
    try {
      self.cfg.seasonType = "regular";
      if (self.cfg && self.cfg.manual) self.cfg.manual.seasonType = "regular";
    } catch(e) {}
    try { if (self.resolveLeagueId) self.cfg.leagueId = self.resolveLeagueId(); } catch(e) {}
    this.cacheDom();
    
    this.setProgress("Loading NFL state‚Ä¶", 8);
    this.fetchJson("https://api.sleeper.app/v1/state/nfl")
      .then(function(nflState) {
        self.data.nflState = nflState || {};

        var liveSeason = String((nflState && nflState.season) || "");
        var liveWeek = Number((nflState && (nflState.leg != null ? nflState.leg : nflState.week)) || 1);
        if (!isFinite(liveWeek) || liveWeek < 1) liveWeek = 1;

        // Default to live NFL state; league metadata + settings can override below.
        var currentWeek = liveWeek;
        var season = liveSeason || String(self.getSeason ? self.getSeason() : "") || "2025";
        self.ui.selectedWeek = currentWeek;

        self.setProgress("Loading league‚Ä¶", 18);
        return self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId)
          .catch(function(e) {
            console.error("League fetch failed:", e);
            throw new Error("League not found or not accessible.");
          })
          .then(function(league) {
            if (!league) throw new Error("League data is empty.");
            self.data.league = league;

            // Prefer the league's season (important in offseason when /state/nfl may reset to week 1).
            var leagueSeason = String((league && league.season) || season);

            // Season used for stats/projections
            var statsSeason = leagueSeason;
            if (self.cfg && self.cfg.autoSetup === false && self.cfg.manual && self.cfg.manual.season) {
              statsSeason = String(self.cfg.manual.season);
            }
            self.data.appSeason = statsSeason;

            // Determine current/max week
            var lastScored = self.getLastScoredWeek(league);
            var maxWeek = 18;
            var effWeek = currentWeek;
            var weekMode = String(self.cfg.weekSelectionMode || "max_week");

            if (self.cfg && self.cfg.autoSetup === false) {
              var mw = Number(self.cfg.manual && self.cfg.manual.maxWeek) || lastScored || 18;
              var cw = Number(self.cfg.manual && self.cfg.manual.currentWeek) || mw;
              maxWeek = Math.max(1, mw);
              effWeek = Math.min(Math.max(1, cw), maxWeek);
            } else {
              var sameSeason = !liveSeason || !leagueSeason || liveSeason === leagueSeason;
              // If league is complete but NFL state is ahead for the same season, honor the live week.
              if ((league && league.status === "complete") && sameSeason && currentWeek > (lastScored || 0)) {
                maxWeek = Math.max(currentWeek, lastScored || 0);
                effWeek = Math.min(Math.max(1, currentWeek), maxWeek);
              } else if ((league && league.status === "complete") || (liveSeason && liveSeason !== leagueSeason)) {
                // If league is complete or live season differs, lock to last scored week
                maxWeek = lastScored || Math.max(1, currentWeek);
                effWeek = maxWeek;
              } else {
                maxWeek = Math.max(Math.max(1, currentWeek), lastScored || 0);
                effWeek = Math.min(Math.max(1, currentWeek), maxWeek);
              }

              if (weekMode === "last_scored" && lastScored) {
                effWeek = Math.min(Math.max(1, lastScored), maxWeek);
              } else if (weekMode === "max_week") {
                effWeek = maxWeek;
              }
            }

            self.data.maxWeek = maxWeek;
            self.ui.selectedWeek = effWeek;

            if (self.dom.hdrLeague) self.dom.hdrLeague.textContent = (league && league.name) || "Sleeper League";
            if (self.dom.hdrMeta) self.dom.hdrMeta.textContent = "Season " + leagueSeason + " | Week " + effWeek;

            self.setProgress("Loading users/rosters‚Ä¶", 28);
            return Promise.all([
              self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/users").catch(function() { return []; }),
              self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/rosters").catch(function() { return []; }),
              self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/matchups/" + effWeek).catch(function() { return []; }),
              self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/transactions/" + effWeek).catch(function() { return []; }),
              self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/winners_bracket").catch(function() { return []; }),
              self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/losers_bracket").catch(function() { return []; })
            ]);
          });
      })
      .then(function(results) {
        var users = results[0];
        var rosters = results[1];
        
        self.data.usersById = {};
        (users || []).forEach(function(u) { self.data.usersById[u.user_id] = u; });
        self.data.rosters = rosters || [];

        return Promise.all([
          self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/winners_bracket").catch(function() { return []; }),
          self.fetchJson("https://api.sleeper.app/v1/league/" + self.cfg.leagueId + "/losers_bracket").catch(function() { return []; })
        ]);
      })
      .then(function(brackets) {
        self.data.winnersBracket = brackets[0] || [];
        self.data.losersBracket = brackets[1] || [];

        self.ui.selectedRosterId = (self.data.rosters[0] && self.data.rosters[0].roster_id) || null;

        self.setProgress("Downloading player database‚Ä¶", 40);
        return self.fetchJson("https://api.sleeper.app/v1/players/nfl");
      })
      .then(function(players) {
        self.data.playersById = players;
        self.buildWeekSelect(self.getMaxWeek());

        self.setProgress("Loading matchups‚Ä¶", 50);
        try {
          var p = self.loadWeek(self.ui.selectedWeek);
          return (p && typeof p.catch === 'function') ? p.catch(function(e) {
            console.warn("Week load failed (non-critical):", e);
          }) : Promise.resolve();
        } catch(e) {
          console.warn("Week load failed (non-critical):", e);
          return Promise.resolve();
        }
      })
      .then(function() {
        self.setProgress("Building season totals‚Ä¶", 60);
        try {
          var p = self.buildSeasonTotals();
          return (p && typeof p.catch === 'function') ? p.catch(function(e) {
            console.warn("Season totals build failed (non-critical):", e);
            self.data.seasonTotals = {};
          }) : Promise.resolve();
        } catch(e) {
          console.warn("Season totals build failed (non-critical):", e);
          self.data.seasonTotals = {};
          return Promise.resolve();
        }
      })
      .then(function() {
        self.setProgress("Building player values‚Ä¶", 65);
        try { self.buildPlayerValueIndex(); } catch(e) { console.warn("Value index build failed", e); }
      })
      .then(function() {
        self.setProgress("Building league insights‚Ä¶", 70);
        try {
          var p = self.buildLeagueMetrics();
          return (p && typeof p.catch === 'function') ? p.catch(function(e) {
            console.warn("League metrics build failed (non-critical):", e);
          }) : Promise.resolve();
        } catch(e) {
          console.warn("League metrics build failed (non-critical):", e);
          return Promise.resolve();
        }
      })
      .then(function() {
        self.setProgress("Loading NFL schedule‚Ä¶", 75);
        try {
          var p = self.loadNFLSchedule();
          return (p && typeof p.catch === 'function') ? p.catch(function(e) {
            console.warn("NFL schedule load failed (non-critical):", e);
          }) : Promise.resolve();
        } catch(e) {
          console.warn("NFL schedule load failed (non-critical):", e);
          return Promise.resolve();
        }
      })
      .then(function() {
        self.setProgress("Loading defense stats‚Ä¶", 78);
        try {
          var p = self.loadDefenseStats();
          return (p && typeof p.catch === 'function') ? p.catch(function(e) {
            console.warn("Defense stats load failed (non-critical):", e);
          }) : Promise.resolve();
        } catch(e) {
          console.warn("Defense stats load failed (non-critical):", e);
          return Promise.resolve();
        }
    }).then(function() {
      self.setProgress("Building defense role metrics‚Ä¶", 80);
      try {
        var p = self.buildDefenseRoleMetrics();
        return (p && typeof p.catch === 'function') ? p.catch(function(e) {
          console.warn("Defense role metrics build failed (non-critical):", e);
        }) : Promise.resolve();
      } catch(e) {
        console.warn("Defense role metrics build failed (non-critical):", e);
        return Promise.resolve();
      }
      })
      .then(function() {
        self.setProgress("Building UI‚Ä¶", 80);
        self.bindNav();
        try {
          self.renderAll();
        } catch (renderErr) {
          console.error("Render error:", renderErr);
        }
        self.setProgress("Ready", 100);
      })
      .catch(function(err) {
        console.error("Init error:", err);
        self.setProgress("Error: " + (err.message || "Unknown error"), 100);
        
        // Show error UI with option to switch season
        var errorHtml = '<div class="flex items-center justify-center h-full">' +
          '<div class="bg-red-900/20 border border-red-800 rounded-xl p-6 max-w-md text-center">' +
          '<div class="text-red-400 text-lg font-bold mb-2">Failed to Load League</div>' +
          '<div class="text-gray-400 text-sm mb-4">' + (err.message || "The selected league could not be loaded.") + '</div>' +
          '<div class="text-gray-500 text-xs mb-4">League ID: ' + self.cfg.leagueId + '</div>' +
          '<div class="flex gap-2 justify-center">' +
          '<button onclick="APP.switchSeason(\'2025\')" class="px-4 py-2 bg-accent text-black rounded-lg hover:bg-emerald-400 font-semibold">Switch to 2025</button>' +
          '<button onclick="APP.switchSeason(\'2024\')" class="px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600">Switch to 2024</button>' +
          '</div></div></div>';
        
        if (self.dom.rosterList) self.dom.rosterList.innerHTML = errorHtml;
        if (self.dom.viewTeams) self.dom.viewTeams.classList.remove('hidden');
      });
  },

  buildWeekSelect: function(currentWeek) {
    var self = this;
    var sel = this.dom.weekSelect; // legacy
    var selMatch = this.dom.matchupsWeekSelect;

    // Persist selected week
    this.ui.selectedWeek = Number(currentWeek) || 1;

    var maxWeek = Number(currentWeek) || 1;
    if (!isFinite(maxWeek) || maxWeek < 1) maxWeek = 1;
    if (maxWeek > 18) maxWeek = 18;

    var updateLabels = function(wk) {
      if (self.dom.currentWeekLabel) self.dom.currentWeekLabel.textContent = "Week " + wk;
      if (self.dom.hdrMeta) self.dom.hdrMeta.textContent = "Season " + self.getSeason() + " | Week " + wk;
    };

    updateLabels(this.ui.selectedWeek);

    var populate = function(selectEl) {
      if (!selectEl) return;
      selectEl.innerHTML = "";
      for (var w = 1; w <= maxWeek; w++) {
        var opt = document.createElement("option");
        opt.value = String(w);
        opt.textContent = "Week " + w;
        if (w === self.ui.selectedWeek) opt.selected = true;
        selectEl.appendChild(opt);
      }
    };

    populate(sel);
    populate(selMatch);

    var onChange = function(wk) {
      wk = Number(wk) || 1;
      if (wk < 1) wk = 1;
      if (wk > maxWeek) wk = maxWeek;

      self.ui.selectedWeek = wk;
      updateLabels(wk);

      // Keep both selects in sync (if both exist)
      try { if (sel && Number(sel.value) !== wk) sel.value = String(wk); } catch(e) {}
      try { if (selMatch && Number(selMatch.value) !== wk) selMatch.value = String(wk); } catch(e) {}

      self.setProgress("Loading week " + wk + "‚Ä¶", 60);
      self.loadWeek(wk).then(function() {
        self.renderAll();
        self.setProgress("Ready", 100);
      });
    };

    if (sel) sel.onchange = function(e) { onChange(e && e.target ? e.target.value : null); };
    if (selMatch) selMatch.onchange = function(e) { onChange(e && e.target ? e.target.value : null); };
  },

  loadWeek: function(week) {
    var self = this;
    var season = this.getSeason();
    var st = this.cfg.seasonType || "regular";

    // NOTE: Sleeper endpoints return different shapes:
    // - matchups/transactions: arrays
    // - stats/projections: objects keyed by player_id (or sometimes arrays depending on endpoint/version)
    // Use typed fallbacks so downstream calculations don't silently break.
    var safeFetch = function(url, fallback) {
      return self.fetchJson(url).catch(function(e) {
        console.warn("Week data unavailable:", url, (e && e.message) ? e.message : e);
        return fallback;
      });
    };

    return Promise.all([
      safeFetch("https://api.sleeper.app/v1/league/" + this.cfg.leagueId + "/matchups/" + week, []),
      (function(_self){
        var posQ = "&position[]=QB&position[]=RB&position[]=WR&position[]=TE&position[]=K&position[]=DEF&position[]=DL&position[]=LB&position[]=DB";
        var seasonType = (_self.cfg && _self.cfg.seasonType) ? _self.cfg.seasonType : "regular";
        var stA = "https://api.sleeper.app/stats/nfl/" + season + "/" + week + "?season_type=" + seasonType + posQ;
        var stB = "https://api.sleeper.com/stats/nfl/" + season + "/" + week + "?season_type=" + seasonType + posQ;
        return _self.fetchJson(stA).catch(function(){ return _self.fetchJson(stB); }).catch(function(){ return {}; });
      })(this),
      (function(_self){
        var posQ = "&position[]=QB&position[]=RB&position[]=WR&position[]=TE&position[]=K&position[]=DEF&position[]=DL&position[]=LB&position[]=DB";
        var seasonType = (_self.cfg && _self.cfg.seasonType) ? _self.cfg.seasonType : "regular";
        var prA = "https://api.sleeper.app/projections/nfl/" + season + "/" + week + "?season_type=" + seasonType + posQ;
        var prB = "https://api.sleeper.com/projections/nfl/" + season + "/" + week + "?season_type=" + seasonType + posQ;
        return _self.fetchJson(prA).catch(function(){ return _self.fetchJson(prB); }).catch(function(){ return {}; });
      })(this),
      safeFetch("https://api.sleeper.app/v1/league/" + this.cfg.leagueId + "/transactions/" + week, [])
    ]).then(function(results) {
      // Store matchups by week to avoid overwriting current week's data
      self.data.weekMatchups[String(week)] = results[0] || [];
      // Also update main matchups if this is the selected week
      if (week === self.ui.selectedWeek) {
        self.data.matchups = results[0] || [];
      }
      self.data.weekStats[String(week)] = self.arrToMap(results[1]);
      self.data.weekProj[String(week)] = self.arrToMap(results[2]);
      self.data.weekTrans[String(week)] = results[3] || [];
    });
  },

  bindNav: function() {
    var self = this;
    if (this.dom.btnRosterRefresh) this.dom.btnRosterRefresh.onclick = function() { self.switchSeason(self.cfg.selectedSeasonChoice); };

    // Year selector (league swap). Switch season in-place without page reload (for Google Apps Script compatibility)
    if (this.dom.seasonSelect) {
      try { this.dom.seasonSelect.value = String(this.cfg.selectedSeasonChoice || this.getSeason() || "2025"); } catch(e) {}
      this.dom.seasonSelect.onchange = function() {
        var yr = String(self.dom.seasonSelect.value || "");
        if (self.cfg && self.cfg.autoSetup === false) {
          self.cfg.manual = self.cfg.manual || {};
          self.cfg.manual.season = yr;
          self.cfg.selectedSeasonChoice = yr;
          try { localStorage.setItem("sleeper_app_season_choice", yr); } catch(e) {}
          try { if (self.saveAppSettings) self.saveAppSettings(); } catch(e) {}
          // Prefer manual leagueId override; otherwise, use the mapping if available
          if (!(self.cfg.manual && self.cfg.manual.leagueId) && self.cfg.seasonLeagues && self.cfg.seasonLeagues[yr]) {
            self.cfg.leagueId = self.cfg.seasonLeagues[yr];
          }
          self.init();
          return;
        }

        if (self.cfg.seasonLeagues && self.cfg.seasonLeagues[yr]) {
          try { localStorage.setItem("sleeper_app_season_choice", yr); } catch(e) {}
          self.switchSeason(yr);
        }
      };    }

    var btns = [
      ["teams", this.dom.btnTabTeams],
      ["matchups", this.dom.btnTabMatchups],
      ["fa", this.dom.btnTabFA],
      ["def", this.dom.btnTabDef],
      ["trades", this.dom.btnTabTrades],
      ["insights", this.dom.btnTabInsights],
        ["settings", this.dom.btnTabSettings],
      ["history", this.dom.btnTabHistory],
      ["optimal", this.dom.btnTabOptimal]
    ];

    var setActiveBtn = function(view) {
      btns.forEach(function(pair) {
        var v = pair[0];
        var el = pair[1];
        if (!el) return;
        var baseSize = "text-[10px]";
        el.className = v === view
          ? "w-11 h-11 rounded-xl ui2k-navbtn nav-btn-active font-bold " + baseSize
          : "w-11 h-11 rounded-xl ui2k-navbtn bg-gray-800/60 text-gray-400 hover:bg-gray-700 hover:text-white font-bold " + baseSize;
      });
    };

    if (this.dom.btnTabTeams) this.dom.btnTabTeams.onclick = function() { self.ui.currentView = "teams"; self.renderAll(); setActiveBtn("teams"); };
    if (this.dom.btnTabMatchups) this.dom.btnTabMatchups.onclick = function() { self.ui.currentView = "matchups"; self.renderAll(); setActiveBtn("matchups"); };
    if (this.dom.btnTabFA) this.dom.btnTabFA.onclick = function() { self.ui.currentView = "fa"; self.renderAll(); setActiveBtn("fa"); };
    if (this.dom.btnTabDef) this.dom.btnTabDef.onclick = function() { self.ui.currentView = "def"; self.renderAll(); setActiveBtn("def"); };
    if (this.dom.btnTabTrades) this.dom.btnTabTrades.onclick = function() { self.ui.currentView = "trades"; self.renderAll(); setActiveBtn("trades"); };
    if (this.dom.btnTabInsights) this.dom.btnTabInsights.onclick = function() { self.ui.currentView = "insights"; self.renderAll(); setActiveBtn("insights"); };

      if (this.dom.btnTabSettings) this.dom.btnTabSettings.onclick = function() {
        self.ui.currentView = "settings";
        self.renderAll();
        setActiveBtn("settings");
        try { if (self.renderSettingsView) self.renderSettingsView(); } catch(e) {}
      };
    if (this.dom.btnTabHistory) this.dom.btnTabHistory.onclick = function() { self.ui.currentView = "history"; self.ui.historyMode = "roster"; self.renderAll(); setActiveBtn("history"); };
    if (this.dom.btnTabOptimal) this.dom.btnTabOptimal.onclick = function() { self.ui.currentView = "optimal"; self.ui.historyMode = "best"; self.renderAll(); setActiveBtn("optimal"); };

    setActiveBtn("teams");

    // History controls - auto-load on week change
    if (this.dom.historyWeekSelect) {
      this.buildHistoryWeekSelect();
      this.dom.historyWeekSelect.onchange = function() {
        self.ui.historySelectedWeek = Number(self.dom.historyWeekSelect.value);
        self.loadHistoricalWeek();
      };
    }

    // Trades controls
    if (this.dom.tradeSearch) {
      this.dom.tradeSearch.oninput = function() { if (self.ui.currentView === "trades") self.renderTrades(); };
    }
    if (this.dom.tradeType) {
      this.dom.tradeType.onchange = function() { if (self.ui.currentView === "trades") self.renderTrades(); };
    }
    if (this.dom.btnTradeRefresh) {
      this.dom.btnTradeRefresh.onclick = function() {
        var wk = self.ui.selectedWeek;
        if (self.dom.tradeContent) self.dom.tradeContent.innerHTML = '<div class="text-gray-400 text-sm">Refreshing transactions‚Ä¶</div>';
        self.refreshTransactions(wk).then(function() { self.renderTrades(); });
      };
    }

    // Defense conference tabs
    if (this.dom.defTabAFC) {
      this.dom.defTabAFC.onclick = function() { 
        self.ui.selectedConference = "AFC"; 
        if (self.dom.defTabAFC) self.dom.defTabAFC.className = "px-4 py-2 rounded-xl bg-accent text-black font-bold";
        if (self.dom.defTabNFC) self.dom.defTabNFC.className = "px-4 py-2 rounded-xl bg-gray-900 border border-gray-800 text-gray-300 hover:bg-gray-800 font-bold";
        self.renderDefenses(); 
      };
    }
    if (this.dom.defTabNFC) {
      this.dom.defTabNFC.onclick = function() { 
        self.ui.selectedConference = "NFC"; 
        if (self.dom.defTabNFC) self.dom.defTabNFC.className = "px-4 py-2 rounded-xl bg-accent text-black font-bold";
        if (self.dom.defTabAFC) self.dom.defTabAFC.className = "px-4 py-2 rounded-xl bg-gray-900 border border-gray-800 text-gray-300 hover:bg-gray-800 font-bold";
        self.renderDefenses(); 
      };
    }

    if (this.dom.pmClose) this.dom.pmClose.onclick = function() { self.closePlayerModal(); };
    if (this.dom.playerModal) this.dom.playerModal.onclick = function(e) { if (e.target === self.dom.playerModal) self.closePlayerModal(); };

    if (this.dom.mmClose) this.dom.mmClose.onclick = function() { self.closeMatchupModal(); };
    if (this.dom.matchupModal) this.dom.matchupModal.onclick = function(e) { if (e.target === self.dom.matchupModal) self.closeMatchupModal(); };
    
    if (this.dom.matchupGrid) {
      this.dom.matchupGrid.onclick = function(e) {
        var card = e.target.closest("[data-matchup-card]");
        if (card) self.openMatchupModal(card.dataset.label || "‚Äî", card.dataset.rosterA, card.dataset.rosterB);
      };
    }
  },

  renderAll: function() {
    // Safely toggle view visibility with null checks
    if (this.dom.viewTeams) this.dom.viewTeams.classList.toggle("hidden", this.ui.currentView !== "teams");
    if (this.dom.viewMatchups) this.dom.viewMatchups.classList.toggle("hidden", this.ui.currentView !== "matchups");
    if (this.dom.viewFA) this.dom.viewFA.classList.toggle("hidden", this.ui.currentView !== "fa");
    if (this.dom.viewDef) this.dom.viewDef.classList.toggle("hidden", this.ui.currentView !== "def");
    if (this.dom.viewTrades) this.dom.viewTrades.classList.toggle("hidden", this.ui.currentView !== "trades");
    if (this.dom.viewInsights) this.dom.viewInsights.classList.toggle("hidden", this.ui.currentView !== "insights");
    if (this.dom.viewSettings) this.dom.viewSettings.classList.toggle("hidden", this.ui.currentView !== "settings");
    if (this.dom.viewHistory) this.dom.viewHistory.classList.toggle("hidden", (this.ui.currentView !== "history" && this.ui.currentView !== "optimal"));

    // History header (H = actual roster, O = optimal lineup)
    if (this.dom.historyHeaderTitle) {
      if (this.ui.currentView === "optimal") {
        this.dom.historyHeaderTitle.textContent = "Optimal Lineups";
        if (this.dom.historyHeaderSubtitle) this.dom.historyHeaderSubtitle.textContent = "Weighted lineup suggestions by week";
        this.ui.historyMode = "best";
      } else if (this.ui.currentView === "history") {
        this.dom.historyHeaderTitle.textContent = "Historical Rosters";
        if (this.dom.historyHeaderSubtitle) this.dom.historyHeaderSubtitle.textContent = "Weekly lineup snapshots";
        this.ui.historyMode = "roster";
      }
    }

    if (this.dom.optSettingsToggle) {
      var showOptSettings = this.ui.currentView === "optimal";
      this.dom.optSettingsToggle.classList.toggle("hidden", !showOptSettings);
      this.dom.optSettingsToggle.textContent = this.ui.optSettingsOpen ? "Close" : "Settings";
    }
    if (this.dom.optSettingsPanel) {
      var showPanel = (this.ui.currentView === "optimal") && this.ui.optSettingsOpen;
      this.dom.optSettingsPanel.classList.toggle("hidden", !showPanel);
    }
    if (this.ui.currentView !== "optimal") {
      this.ui.optSettingsOpen = false;
    }
    if (this.ui.currentView === "optimal") {
      this.bindOptimalSettings();
      this.syncOptimalSliderUI();
    }

    // Update current week label
    if (this.dom.currentWeekLabel) {
      this.dom.currentWeekLabel.textContent = "Week " + (this.ui.selectedWeek || "‚Äî");
    }

    if (this.ui.currentView === "teams") {
      this.renderTeamTabs();
      this.renderRoster();
      this.renderComparison();
    } else if (this.ui.currentView === "matchups") {
      this.renderMatchups();
    } else if (this.ui.currentView === "fa") {
      this.renderFATabs();
      this.renderFA();
    } else if (this.ui.currentView === "def") {
      this.renderDefenses();
    } else if (this.ui.currentView === "trades") {
      this.renderTrades();
    } else if (this.ui.currentView === "insights") {
      this.renderLeagueInsights();
      this.renderLineupInsights();
      this.renderPosBaselines();
      this.renderDefenseRoleEffectiveness();
      this.renderInsightsCharts();
    } else if (this.ui.currentView === "history" || this.ui.currentView === "optimal") {
      // Auto-load if we have matchup data, otherwise trigger load
      if (this.ui.historyMatchups) {
        this.renderHistoryTeamTabs();
        this.renderHistoryRoster();
        this.renderHistoryComparison();
      } else if (this.ui.historySelectedWeek) {
        this.loadHistoricalWeek();
      }
    }

    // Defense-vs-role UI bindings
    this.bindDefenseRoleUI();

  },

  renderTeamTabs: function() {
    var self = this;
    var tabs = this.dom.teamTabs;
    if (!tabs) return;
    tabs.innerHTML = "";

    this.data.rosters.forEach(function(r) {
      var name = self.rosterLabel(r);
      var btn = document.createElement("button");
      var active = String(r.roster_id) === String(self.ui.selectedRosterId);
      btn.className = active
        ? "px-4 py-2 rounded-xl font-bold whitespace-nowrap madden-tab madden-tab-active"
        : "px-4 py-2 rounded-xl font-bold whitespace-nowrap madden-tab text-gray-300";
      btn.textContent = name;
      btn.onclick = function() {
        self.ui.selectedRosterId = r.roster_id;
        self.renderTeamTabs();
        self.renderRoster();
        self.renderComparison();
      };
      tabs.appendChild(btn);
    });
  },

  renderRoster: function() {
    var self = this;
    var roster = this.data.rosters.find(function(r) { return String(r.roster_id) === String(self.ui.selectedRosterId); });
    var week = String(this.ui.selectedWeek);
    var statsMap = this.data.weekStats[week] || {};
    var projMap = this.data.weekProj[week] || {};

    var u = this.data.usersById[roster && roster.owner_id];
    if (this.dom.teamTitle) {
      this.dom.teamTitle.textContent = roster ? this.rosterLabel(roster) : "Roster";
    }
    if (this.dom.teamSubtitle) {
      this.dom.teamSubtitle.textContent = "Week " + this.ui.selectedWeek + " | Custom scoring from league settings";
    }

    var list = this.dom.rosterList;
    if (!list) return;
    list.innerHTML = "";

    if (!roster) {
      list.innerHTML = '<div class="text-gray-500">No roster selected.</div>';
      return;
    }

    var slots = (this.data.league && this.data.league.roster_positions) || [];
    var starters = (roster.starters || []).map(function(pid, i) { return { pid: String(pid), slot: slots[i] || "ST", isStarter: true }; });
    var starterSet = new Set(starters.map(function(x) { return x.pid; }));
    // Bench / stash players: include standard bench plus taxi + reserve/IR (to avoid "missing" stashes)
// De-dupe by playerId (Sleeper sometimes repeats taxi/IR players inside `players`)
var benchByPid = {};
var prio = { "IR": 3, "TX": 2, "BN": 1 };
var addBench = function(pid, slot) {
  pid = String(pid);
  if (!pid) return;
  if (starterSet.has(pid)) return;
  var cur = benchByPid[pid];
  if (!cur || (prio[slot] || 0) > (prio[cur] || 0)) benchByPid[pid] = slot;
};

(roster.players || []).forEach(function(pid) { addBench(pid, "BN"); });
(roster.taxi || []).forEach(function(pid) { addBench(pid, "TX"); });
(roster.reserve || roster.ir || roster.injured_reserve || []).forEach(function(pid) { addBench(pid, "IR"); });

var benchPlayers = Object.keys(benchByPid).map(function(pid) {
  return { pid: pid, slot: benchByPid[pid], isStarter: false };
});


    // Helper to check if player is IR/Out
    var isInjuredOut = function(p) {
      var status = ((p && (p.injury_status || p.status)) || "").toString().trim().toUpperCase();
      var outStatuses = ["OUT", "IR", "PUP", "NFI", "SUSP", "SUSPENDED", "COVID", "INACTIVE", "DNR"];
      return outStatuses.indexOf(status) >= 0;
    };

    // Build enriched player data
    var enrichPlayer = function(item) {
      var pid = item.pid;
      var p = self.data.playersById[pid] || {};
      var disp = self.playerDisplay(p);
      var projStats = projMap[pid] || {};
      var actStats = statsMap[pid] || {};
      var proj = self.scoreFromStats(projStats, pid);
      var act = self.scoreFromStats(actStats, pid);
      var hasPlayed = Object.keys(actStats).length > 0;
      var opp = self.getOpponent(actStats, projStats, p, self.ui.selectedWeek);
      var enhancedMU = self.getEnhancedMatchupInfo(pid, opp);
      var status = self.boomBustStatus(proj, act, hasPlayed, (enhancedMU && enhancedMU.matchScore !== undefined) ? enhancedMU.matchScore : null);
      var scoreToShow = hasPlayed ? act : proj;
      var scoreCls = hasPlayed ? self.scoreColor(proj, act, hasPlayed) : "text-gray-200";
      var posRank = self.positionRank(pid);
      var ppgRank = self.getPlayerPpgRank(pid);
      var deltaRank = self.getPlayerDeltaRank(pid);
      var seasonTotal = 0;
      if (self.data.seasonTotals) {
        seasonTotal = self.data.seasonTotals[pid] || self.data.seasonTotals[String(pid)] || 0;
      }
      
      var valObj = self.getPlayerValue(pid);
      var valueScore = valObj ? valObj.score : null;
      
      // Get player efficiency metrics
      var effMetrics = self.getPlayerEfficiencyMetrics(pid, p);

      return {
        pid: pid,
        slot: item.slot,
        isStarter: item.isStarter,
        player: p,
        disp: disp,
        proj: proj,
        act: act,
        hasPlayed: hasPlayed,
        status: status,
        scoreToShow: scoreToShow,
        scoreCls: scoreCls,
        opp: opp,
        isOut: isInjuredOut(p),
        seasonTotal: seasonTotal,
        posRank: posRank,
        ppgRank: ppgRank,
      deltaRank: deltaRank,
        valueScore: valueScore,
        effMetrics: effMetrics,
        enhancedMU: enhancedMU
      };
    };

    var allStarters = starters.map(enrichPlayer);
    var allBench = benchPlayers.map(enrichPlayer);

    // Separate IR/Out from active bench
    var activeBench = allBench.filter(function(x) { return !x.isOut; });
    var irPlayers = allBench.filter(function(x) { return x.isOut; });

    // Group starters by position category
    var positionOrder = ["QB", "RB", "WR", "TE", "FLEX", "SUPER_FLEX", "REC_FLEX", "K", "DEF", "DL", "LB", "DB", "IDP_FLEX"];
    var positionLabels = {
      "QB": "Quarterbacks",
      "RB": "Running Backs", 
      "WR": "Wide Receivers",
      "TE": "Tight Ends",
      "FLEX": "Flex",
      "SUPER_FLEX": "SF",
      "REC_FLEX": "Rec Flex",
      "K": "Kickers",
      "DEF": "Defense",
      "DL": "Defensive Line",
      "LB": "Linebackers",
      "DB": "Defensive Backs",
      "IDP_FLEX": "IDP Flex"
    };

    // Group starters by slot type
    var startersBySlot = {};
    allStarters.forEach(function(s) {
      var slotKey = s.slot.toUpperCase();
      if (!startersBySlot[slotKey]) startersBySlot[slotKey] = [];
      startersBySlot[slotKey].push(s);
    });

    var renderPlayerCard = function(item, showSlot) {
      return self.buildPlayerCardElement(item, { showSlot: showSlot });
    };

    // Render section header
    var renderSectionHeader = function(title, subtitle, icon) {
      var header = document.createElement("div");
      header.className = "flex items-center gap-2 mb-3 mt-6 first:mt-0";
      header.innerHTML = 
        '<div class="w-8 h-8 rounded-lg bg-gradient-to-br from-accent/20 to-gray-800/20 border border-accent/30 flex items-center justify-center">' +
          '<span class="text-accent text-xs font-bold">' + icon + '</span>' +
        '</div>' +
        '<div>' +
          '<div class="text-sm font-bold text-white">' + title + '</div>' +
          (subtitle ? '<div class="text-[10px] text-gray-500 font-mono">' + subtitle + '</div>' : '') +
        '</div>';
      return header;
    };

    // Render starters grouped by position
    var startersSection = document.createElement("div");
    startersSection.className = "space-y-2";

    // Add main starters header
    var mainHeader = document.createElement("div");
    mainHeader.className = "flex items-center justify-between pb-2 border-b border-gray-800 mb-4";
    mainHeader.innerHTML = 
      '<div class="flex items-center gap-2">' +
        '<div class="w-2 h-2 rounded-full bg-accent"></div>' +
        '<span class="text-xs font-bold text-gray-300 uppercase tracking-wider">Active Starters</span>' +
      '</div>' +
      '<div class="text-[10px] text-gray-500 font-mono">Actual shown after play; projection otherwise</div>';
    startersSection.appendChild(mainHeader);

    // Render each position group
    positionOrder.forEach(function(slotKey) {
      var players = startersBySlot[slotKey];
      if (!players || players.length === 0) return;

      var posLabel = positionLabels[slotKey] || slotKey;

      // Status counts (includes Major Boom/Major Bust)
      var counts = { mboom: 0, boom: 0, within: 0, bust: 0, mbust: 0 };
      players.forEach(function(pp) {
        if (!pp || !pp.status || !pp.status.label) return;
        if (pp.status.label === "Major Boom") counts.mboom++;
        else if (pp.status.label === "Boom") counts.boom++;
        else if (pp.status.label === "In Range") counts.within++;
        else if (pp.status.label === "Bust") counts.bust++;
        else if (pp.status.label === "Major Bust") counts.mbust++;
      });

      var posHeader = document.createElement("div");
      posHeader.className = "text-[11px] font-bold text-gray-500 uppercase tracking-wider mt-4 mb-2 flex items-center justify-between gap-2";
      posHeader.innerHTML =
        '<div class="flex items-center gap-2 min-w-0">' +
          '<span class="w-1 h-3 rounded bg-accent/50"></span>' +
          '<span class="truncate">' + posLabel + '</span>' +
        '</div>';
      startersSection.appendChild(posHeader);

      var posGrid = document.createElement("div");
      posGrid.className = "ui2k-card-grid";
      players.forEach(function(p) {
        posGrid.appendChild(renderPlayerCard(p, true));
      });
      startersSection.appendChild(posGrid);
    });

    list.appendChild(startersSection);

    // Render bench section
    if (activeBench.length > 0) {
      var benchSection = document.createElement("div");
      benchSection.className = "mt-8";
      
      var benchHeader = document.createElement("div");
      benchHeader.className = "flex items-center justify-between pb-2 border-b border-gray-800 mb-4";
      benchHeader.innerHTML = 
        '<div class="flex items-center gap-2">' +
          '<div class="w-2 h-2 rounded-full bg-gray-500"></div>' +
          '<span class="text-xs font-bold text-gray-400 uppercase tracking-wider">Bench</span>' +
          '<span class="text-[10px] text-gray-600 font-mono">(' + activeBench.length + ' players)</span>' +
        '</div>';
      benchSection.appendChild(benchHeader);

      var benchGrid = document.createElement("div");
      benchGrid.className = "ui2k-card-grid";
      
      // Sort bench by position then score
      activeBench.sort(function(a, b) {
        var posOrder = ["QB", "RB", "WR", "TE", "K", "DEF", "DL", "LB", "DB"];
        var aIdx = posOrder.indexOf((a.disp && a.disp.posPrimary) ? a.disp.posPrimary : a.disp.pos);
        var bIdx = posOrder.indexOf((b.disp && b.disp.posPrimary) ? b.disp.posPrimary : b.disp.pos);
        if (aIdx === -1) aIdx = 99;
        if (bIdx === -1) bIdx = 99;
        if (aIdx !== bIdx) return aIdx - bIdx;
        return b.scoreToShow - a.scoreToShow;
      });

      activeBench.forEach(function(p) {
        benchGrid.appendChild(renderPlayerCard(p, false));
      });
      benchSection.appendChild(benchGrid);
      list.appendChild(benchSection);
    }

    // Render IR/Out section
    if (irPlayers.length > 0) {
      var irSection = document.createElement("div");
      irSection.className = "mt-8";
      
      var irHeader = document.createElement("div");
      irHeader.className = "flex items-center justify-between pb-2 border-b border-red-900/30 mb-4";
      irHeader.innerHTML = 
        '<div class="flex items-center gap-2">' +
          '<div class="w-2 h-2 rounded-full bg-red-500"></div>' +
          '<span class="text-xs font-bold text-red-400 uppercase tracking-wider">Injured Reserve / Out</span>' +
          '<span class="text-[10px] text-red-600/70 font-mono">(' + irPlayers.length + ' players)</span>' +
        '</div>';
      irSection.appendChild(irHeader);

      var irGrid = document.createElement("div");
      irGrid.className = "ui2k-card-grid opacity-60";
      irPlayers.forEach(function(p) {
        irGrid.appendChild(renderPlayerCard(p, false));
      });
      irSection.appendChild(irGrid);
      list.appendChild(irSection);
    }

    // Add Insights Section
    var insightsSection = document.createElement("div");
    insightsSection.className = "mt-8";
    
    var insightsHeader = document.createElement("div");
    insightsHeader.className = "flex items-center justify-between pb-2 border-b border-accent/30 mb-4";
    insightsHeader.innerHTML = 
      '<div class="flex items-center gap-2">' +
        '<div class="w-2 h-2 rounded-full bg-accent"></div>' +
        '<span class="text-xs font-bold text-accent uppercase tracking-wider">Smart Insights</span>' +
      '</div>';
    insightsSection.appendChild(insightsHeader);

    var insightsContent = document.createElement("div");
    insightsContent.className = "space-y-4";

    // Generate insights
    var insights = self.generateRosterInsights(allStarters, activeBench, week);
    
    if (insights.lineupAlerts.length > 0) {
      var alertsDiv = document.createElement("div");
      alertsDiv.className = "bg-yellow-900/20 border border-yellow-700/30 rounded-xl p-4";
      alertsDiv.innerHTML = '<div class="text-sm font-bold text-yellow-400 mb-2">‚ö†Ô∏è Lineup Alerts</div>';
      var alertsList = document.createElement("div");
      alertsList.className = "space-y-2";
      insights.lineupAlerts.forEach(function(alert) {
        var alertItem = document.createElement("div");
        alertItem.className = "text-xs text-yellow-200/80 font-mono flex items-start gap-2";
        alertItem.innerHTML = '<span class="text-yellow-500">‚Ä¢</span><span>' + alert + '</span>';
        alertsList.appendChild(alertItem);
      });
      alertsDiv.appendChild(alertsList);
      insightsContent.appendChild(alertsDiv);
    }

    if (insights.smashPlays.length > 0) {
      var smashDiv = document.createElement("div");
      smashDiv.className = "bg-green-900/20 border border-green-700/30 rounded-xl p-4";
      smashDiv.innerHTML = '<div class="text-sm font-bold text-green-400 mb-2">üî• Smash Plays (Favorable Matchups)</div>';
      var smashList = document.createElement("div");
      smashList.className = "space-y-2";
      insights.smashPlays.forEach(function(play) {
        var playItem = document.createElement("div");
        playItem.className = "text-xs text-green-200/80 font-mono flex items-start gap-2";
        playItem.innerHTML = '<span class="text-green-500">‚Ä¢</span><span>' + play + '</span>';
        smashList.appendChild(playItem);
      });
      smashDiv.appendChild(smashList);
      insightsContent.appendChild(smashDiv);
    }

    if (insights.sitCandidates.length > 0) {
      var sitDiv = document.createElement("div");
      sitDiv.className = "bg-red-900/20 border border-red-700/30 rounded-xl p-4";
      sitDiv.innerHTML = '<div class="text-sm font-bold text-red-400 mb-2">‚õî Tough Matchups (Consider Alternatives)</div>';
      var sitList = document.createElement("div");
      sitList.className = "space-y-2";
      insights.sitCandidates.forEach(function(sit) {
        var sitItem = document.createElement("div");
        sitItem.className = "text-xs text-red-200/80 font-mono flex items-start gap-2";
        sitItem.innerHTML = '<span class="text-red-500">‚Ä¢</span><span>' + sit + '</span>';
        sitList.appendChild(sitItem);
      });
      sitDiv.appendChild(sitList);
      insightsContent.appendChild(sitDiv);
    }

    if (insights.trending.length > 0) {
      var trendDiv = document.createElement("div");
      trendDiv.className = "bg-blue-900/20 border border-blue-700/30 rounded-xl p-4";
      trendDiv.innerHTML = '<div class="text-sm font-bold text-blue-400 mb-2">üìà Trending Players</div>';
      var trendList = document.createElement("div");
      trendList.className = "space-y-2";
      insights.trending.forEach(function(trend) {
        var trendItem = document.createElement("div");
        trendItem.className = "text-xs text-blue-200/80 font-mono flex items-start gap-2";
        trendItem.innerHTML = '<span class="text-blue-500">‚Ä¢</span><span>' + trend + '</span>';
        trendList.appendChild(trendItem);
      });
      trendDiv.appendChild(trendList);
      insightsContent.appendChild(trendDiv);
    }

    if (insightsContent.children.length === 0) {
      insightsContent.innerHTML = '<div class="text-xs text-gray-500 font-mono">No actionable insights for this week.</div>';
    }

    insightsSection.appendChild(insightsContent);
    list.appendChild(insightsSection);
  },

  generateRosterInsights: function(starters, bench, week) {
    var self = this;
    var insights = {
      lineupAlerts: [],
      smashPlays: [],
      sitCandidates: [],
      trending: []
    };

    var defStats = this.data.pfrDefenseStats || {};
    var weekNum = Number(week);

    // Helper: Get defense ranking info
    var getDefenseInfo = function(teamAbbr) {
      var def = defStats[teamAbbr];
      if (!def) return null;
      return {
        team: teamAbbr,
        passRank: def.passRank || 16,
        rushRank: def.rushRank || 16,
        ptsRank: def.overallRank || 16,
        passYds: def.passYdsPerGame || "0",
        rushYds: def.rushYdsPerGame || "0",
        yardsEstimated: def.yardsEstimated || false
      };
    };

    // Helper: Check if matchup is favorable
    var isFavorableMatchup = function(player, opp) {
      if (!opp || opp === "BYE") return null;
      var def = getDefenseInfo(opp);
      if (!def) return null;
      
      var pos = player.disp.pos;
      
      // If yards data is estimated, use overall rank for all positions
      if (def.yardsEstimated) {
        var totalYds = (parseFloat(def.passYds || 0) + parseFloat(def.rushYds || 0)).toFixed(1);
        if (def.ptsRank >= 24) return { type: "smash", reason: opp + " ranks #" + def.ptsRank + " overall (" + totalYds + " yds/gm)" };
        if (def.ptsRank <= 8) return { type: "sit", reason: opp + " ranks #" + def.ptsRank + " overall (tough)" };
        return null;
      }
      
      if (pos === "QB" || pos === "WR" || pos === "TE") {
        // Pass-catchers benefit from weak pass defense
        if (def.passRank >= 24) return { type: "smash", reason: opp + " ranks #" + def.passRank + " vs pass (" + def.passYds + " yds/gm)" };
        if (def.passRank <= 8) return { type: "sit", reason: opp + " ranks #" + def.passRank + " vs pass (tough)" };
      }
      if (pos === "RB") {
        // RBs benefit from weak rush defense
        if (def.rushRank >= 24) return { type: "smash", reason: opp + " ranks #" + def.rushRank + " vs rush (" + def.rushYds + " yds/gm)" };
        if (def.rushRank <= 8) return { type: "sit", reason: opp + " ranks #" + def.rushRank + " vs rush (tough)" };
      }
      return null;
    };

    // Helper: Calculate trend (requires season data)
    var calculateTrend = function(playerId) {
      var totals = self.data.seasonTotals || {};
      var recentTotal = 0;
      var recentGames = 0;
      var seasonTotal = totals[playerId] || 0;
      
      // Get last 3 weeks of data
      for (var w = Math.max(1, weekNum - 3); w < weekNum; w++) {
        var statsMap = self.data.weekStats[String(w)] || {};
        var stats = statsMap[playerId];
        if (stats && Object.keys(stats).length > 0) {
          recentTotal += self.scoreFromStats(stats, playerId);
          recentGames++;
        }
      }
      
      if (recentGames < 2) return null;
      
      var recentAvg = recentTotal / recentGames;
      var seasonGames = weekNum - 1;
      var seasonAvg = seasonGames > 0 ? seasonTotal / seasonGames : 0;
      
      if (seasonAvg === 0) return null;
      
      var trendPct = ((recentAvg - seasonAvg) / seasonAvg) * 100;
      return {
        recentAvg: recentAvg,
        seasonAvg: seasonAvg,
        trendPct: trendPct,
        trending: trendPct > 15 ? "up" : (trendPct < -15 ? "down" : "stable")
      };
    };

    // Analyze starters
    starters.forEach(function(player) {
      if (!player || !player.opp || player.opp === "‚Äî") return;
      
      var matchup = isFavorableMatchup(player, player.opp);
      if (matchup) {
        if (matchup.type === "smash") {
          insights.smashPlays.push(player.disp.name + " (" + player.disp.pos + ") vs " + matchup.reason);
        } else if (matchup.type === "sit") {
          insights.sitCandidates.push(player.disp.name + " (" + player.disp.pos + ") faces " + matchup.reason);
        }
      }

      // Check trends
      var trend = calculateTrend(player.pid);
      if (trend && trend.trending === "up" && trend.trendPct > 20) {
        insights.trending.push(player.disp.name + " üî• +" + trend.trendPct.toFixed(0) + "% (L3 avg: " + trend.recentAvg.toFixed(1) + " vs season: " + trend.seasonAvg.toFixed(1) + ")");
      }
    });

    // Check if bench players should start over starters
    var startersByPos = {};
    starters.forEach(function(s) {
      var pos = s.disp.pos;
      if (!startersByPos[pos]) startersByPos[pos] = [];
      startersByPos[pos].push(s);
    });

    bench.forEach(function(benchPlayer) {
      var pos = benchPlayer.disp.pos;
      var startersAtPos = startersByPos[pos] || [];
      
      startersAtPos.forEach(function(starter) {
        // If bench player has higher projection than starter
        if (benchPlayer.proj > starter.proj * 1.15 && benchPlayer.proj > 5) {
          insights.lineupAlerts.push(
            "Consider " + benchPlayer.disp.name + " (proj: " + benchPlayer.proj.toFixed(1) + ") over " + 
            starter.disp.name + " (proj: " + starter.proj.toFixed(1) + ")"
          );
        }
      });

      // Check if bench player has great matchup
      if (benchPlayer.opp && benchPlayer.opp !== "‚Äî") {
        var benchMatchup = isFavorableMatchup(benchPlayer, benchPlayer.opp);
        if (benchMatchup && benchMatchup.type === "smash") {
          var worstStarter = null;
          startersAtPos.forEach(function(s) {
            if (!worstStarter || s.proj < worstStarter.proj) worstStarter = s;
          });
          if (worstStarter && benchPlayer.proj >= worstStarter.proj * 0.9) {
            insights.lineupAlerts.push(
              benchPlayer.disp.name + " (bench) has smash matchup vs " + benchPlayer.opp + " - consider starting"
            );
          }
        }
      }

      // Check bench trends
      var benchTrend = calculateTrend(benchPlayer.pid);
      if (benchTrend && benchTrend.trending === "up" && benchTrend.trendPct > 25) {
        insights.trending.push(benchPlayer.disp.name + " (bench) üìà +" + benchTrend.trendPct.toFixed(0) + "% trending up");
      }
    });

    return insights;
  },

  getHeatmapColor: function(value, myValue, allValues, isTotal) {
    if (allValues.length === 0) return { bg: 'rgba(55, 65, 81, 0.3)', text: 'text-gray-300' };
    
    var max = Math.max.apply(null, allValues);
    var min = Math.min.apply(null, allValues);
    var range = max - min;
    
    if (range === 0) return { bg: 'rgba(55, 65, 81, 0.3)', text: 'text-gray-300' };
    
    var normalized = (value - min) / range;
    
    var r, g, b;
    if (normalized < 0.5) {
      var t = normalized * 2;
      r = 239;
      g = Math.round(68 + (200 - 68) * t);
      b = Math.round(68 + (50 - 68) * t);
    } else {
      var t2 = (normalized - 0.5) * 2;
      r = Math.round(239 - (239 - 34) * t2);
      g = Math.round(200 + (197 - 200) * t2);
      b = Math.round(50 + (94 - 50) * t2);
    }
    
    var isSelected = value === myValue;
    var alpha = isSelected ? 0.6 : 0.35;
    
    return {
      bg: "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")",
      text: normalized > 0.6 ? 'text-white' : (normalized < 0.3 ? 'text-white' : 'text-gray-100')
    };
  },

  renderComparison: function() {
    var self = this;
    var box = this.dom.compareBox;
    if (!box) return;
    box.innerHTML = "";

    var week = String(this.ui.selectedWeek);
    var projMap = this.data.weekProj[week] || {};
    var statsMap = this.data.weekStats[week] || {};
    var posList = ["QB", "RB", "WR", "TE", "K", "DL", "LB", "DB"];

    // Map specific positions to general categories
    var positionMap = {
      "QB": "QB", "RB": "RB", "WR": "WR", "TE": "TE", "K": "K",
      "DL": "DL", "DE": "DL", "DT": "DL", "NT": "DL",
      "LB": "LB", "ILB": "LB", "OLB": "LB", "MLB": "LB",
      "DB": "DB", "CB": "DB", "S": "DB", "SS": "DB", "FS": "DB",
      "DEF": "DL" // Team defense counts as DL for simplicity
    };

    var summarizePlayers = function(pids) {
      var posTotals = { QB: 0, RB: 0, WR: 0, TE: 0, K: 0, DL: 0, LB: 0, DB: 0 };
      (pids || []).forEach(function(pid) {
        var id = String(pid);
        var p = self.data.playersById[id];
        if (!p) return;
        var mappedPos = positionMap[p.position];
        if (!mappedPos || !posTotals.hasOwnProperty(mappedPos)) return;
        posTotals[mappedPos] += self.scoreFromStats(projMap[id] || {}, id);
      });
      Object.keys(posTotals).forEach(function(k) { posTotals[k] = Math.round(posTotals[k] * 100) / 100; });
      var total = Math.round(posList.reduce(function(acc, k) { return acc + (posTotals[k] || 0); }, 0) * 100) / 100;
      return { posTotals: posTotals, total: total };
    };

    var summarizeActualPlayers = function(pids) {
      var posTotals = { QB: 0, RB: 0, WR: 0, TE: 0, K: 0, DL: 0, LB: 0, DB: 0 };
      (pids || []).forEach(function(pid) {
        var id = String(pid);
        var p = self.data.playersById[id];
        if (!p) return;
        var mappedPos = positionMap[p.position];
        if (!mappedPos || !posTotals.hasOwnProperty(mappedPos)) return;
        posTotals[mappedPos] += self.scoreFromStats(statsMap[id] || {}, id);
      });
      Object.keys(posTotals).forEach(function(k) { posTotals[k] = Math.round(posTotals[k] * 100) / 100; });
      var total = Math.round(posList.reduce(function(acc, k) { return acc + (posTotals[k] || 0); }, 0) * 100) / 100;
      return { posTotals: posTotals, total: total };
    };


    var selected = this.data.rosters.find(function(r) { return String(r.roster_id) === String(self.ui.selectedRosterId); });
    if (!selected) return;

    var mkHeatmapTable = function(opts) {
      var title = opts.title;
      var subtitle = opts.subtitle;
      var selectorFn = opts.selectorFn;
      
      var selectedS = selectorFn(selected);
      var selUser = self.data.usersById[selected.owner_id];
      var selName = (selUser && selUser.display_name) || ("Team " + selected.roster_id);

      var allTeams = self.data.rosters.map(function(r) {
        var u = self.data.usersById[r.owner_id];
        return { 
          roster: r, 
          name: (u && u.display_name) || ("Team " + r.roster_id), 
          s: selectorFn(r), 
          isSelected: String(r.roster_id) === String(selected.roster_id) 
        };
      });

      // Normalize selector results so missing data doesn't crash the heatmaps
      var normalizeSummary = function(s) {
        s = s || {};
        if (!s.posTotals) s.posTotals = {};
        posList.forEach(function(pos) {
          var v = s.posTotals[pos];
          if (v == null || Number.isNaN(v)) s.posTotals[pos] = 0;
        });
        if (s.total == null || Number.isNaN(s.total)) s.total = 0;
        return s;
      };

      selectedS = normalizeSummary(selectedS);
      allTeams.forEach(function(t) { t.s = normalizeSummary(t.s); });

      var posValues = {};
      var totalValues = [];
      posList.forEach(function(pos) { posValues[pos] = []; });

      allTeams.forEach(function(t) {
        posList.forEach(function(pos) { posValues[pos].push(t.s.posTotals[pos] || 0); });
        totalValues.push(t.s.total || 0);
      });
var wrap = document.createElement("div");
      wrap.className = "mb-6";

      var headerCells = posList.map(function(p) { return '<th class="text-center px-1 py-1.5 w-[7%] bg-gray-950">' + p + '</th>'; }).join("");
      
      wrap.innerHTML = 
        '<div class="text-sm font-bold text-white">' + title + '</div>' +
        '<div class="mt-1 text-xs text-gray-500 font-mono">' + subtitle + '</div>' +
        '<div class="mt-3 max-h-[250px] overflow-y-auto border border-gray-800 rounded-lg">' +
          '<table class="w-full text-[12px] table-fixed tabular-nums">' +
            '<thead class="text-[11px] uppercase text-gray-400 sticky top-0 z-10">' +
              '<tr class="bg-gray-950">' +
                '<th class="text-left px-2 py-1.5 w-[33%] bg-gray-950">Team</th>' +
                headerCells +
                '<th class="text-center px-2 py-1.5 w-[11%] hidden md:table-cell bg-gray-950">TOT</th>' +
              '</tr>' +
            '</thead>' +
            '<tbody class="divide-y divide-gray-800/50"></tbody>' +
          '</table>' +
        '</div>';

      var body = wrap.querySelector("tbody");

      var sorted = allTeams.slice().sort(function(a, b) {
        if (a.isSelected) return -1;
        if (b.isSelected) return 1;
        return (b.s.total || 0) - (a.s.total || 0);
      });

      sorted.forEach(function(team) {
        var tr = document.createElement("tr");
        tr.className = team.isSelected ? "bg-gray-800/30" : "";
        
        var html = '<td class="px-2 py-1.5 ' + (team.isSelected ? 'font-bold text-white' : 'text-gray-200') + ' truncate">' + (team.isSelected ? '‚Üí ' : '') + team.name + '</td>';
        
        posList.forEach(function(pos) {
          var val = team.s.posTotals[pos] || 0;
          var color = self.getHeatmapColor(val, selectedS.posTotals[pos], posValues[pos]);
          html += '<td class="px-1 py-1.5 text-center font-mono ' + color.text + '" style="background:' + color.bg + '">' + val.toFixed(0) + '</td>';
        });
        
        var totalColor = self.getHeatmapColor(team.s.total || 0, selectedS.total, totalValues, true);
        html += '<td class="px-2 py-1.5 text-center font-mono font-bold ' + totalColor.text + ' hidden md:table-cell" style="background:' + totalColor.bg + '">' + (team.s.total || 0).toFixed(0) + '</td>';
        
        tr.innerHTML = html;
        body.appendChild(tr);
      });

      return wrap;
    };

    box.appendChild(mkHeatmapTable({
      title: "Team Score Projected",
      subtitle: "",
      selectorFn: function(roster) { return summarizePlayers((roster && roster.players) || []); }
    }));

    box.appendChild(mkHeatmapTable({
      title: "Team Score Actual",
      subtitle: "Totals are sum of custom-scored actual points for the selected week (0 for players who have not played).",
      selectorFn: function(roster) { return summarizeActualPlayers((roster && roster.players) || []); }
    }));

    box.appendChild(mkHeatmapTable({
      title: "Starters Score Projected",
      subtitle: "Totals include only players currently in starting slots.",
      selectorFn: function(roster) { return summarizePlayers((roster && roster.starters) || []); }
    }));


    box.appendChild(mkHeatmapTable({
      title: "Starters Scores Actual",
      subtitle: "Actual points for starters only this week.",
      selectorFn: function(roster) { return summarizeActualPlayers((roster && roster.starters) || []); }
    }));

  },

  renderMatchups: function() {
    var self = this;
    var grid = this.dom.matchupGrid;
    if (!grid) return;
    grid.innerHTML = "";

    var weekNum = Number(this.ui.selectedWeek);
    // Use week-specific matchups, falling back to main matchups array
    var matchupsData = this.data.weekMatchups[String(weekNum)] || this.data.matchups || [];
    var pairs = this.buildMatchupPairs(weekNum, matchupsData);

    if (!pairs.length) {
      grid.innerHTML = '<div class="text-gray-400 text-sm">No matchup data available for Week ' + this.ui.selectedWeek + '.</div>';
      return;
    }

    pairs.forEach(function(p) {
      var rosterA = self.data.rosters.find(function(r) { return String(r.roster_id) === String(p.aRosterId); });
      var rosterB = self.data.rosters.find(function(r) { return String(r.roster_id) === String(p.bRosterId); });
      if (!rosterA || !rosterB) return;

      var userA = self.data.usersById[rosterA.owner_id];
      var userB = self.data.usersById[rosterB.owner_id];
      var teamAName = (userA && userA.display_name) || ("Team " + rosterA.roster_id);
      var teamBName = (userB && userB.display_name) || ("Team " + rosterB.roster_id);

      var aStarters = (p.aMatchup && Array.isArray(p.aMatchup.starters)) ? p.aMatchup.starters : (rosterA && rosterA.starters);
      var bStarters = (p.bMatchup && Array.isArray(p.bMatchup.starters)) ? p.bMatchup.starters : (rosterB && rosterB.starters);
      var A = self.startersHybridTotal(rosterA, weekNum, aStarters);
      var B = self.startersHybridTotal(rosterB, weekNum, bStarters);

      var sumFromMap = function(pids, map) {
        var total = 0;
        (pids || []).forEach(function(pid) {
          if (!pid || pid === "0") return;
          total += self.scoreFromStats(map[String(pid)] || {}, String(pid));
        });
        return Math.round(total * 100) / 100;
      };

      // Boom/Bust summary (includes Major Boom/Major Bust) for this specific week
      var statsMapW = self.data.weekStats[String(weekNum)] || {};
      var projMapW  = self.data.weekProj[String(weekNum)] || {};
      var countsA = self.countStatusesForPids(aStarters, statsMapW, projMapW, weekNum);
      var countsB = self.countStatusesForPids(bStarters, statsMapW, projMapW, weekNum);
      var projA = sumFromMap(aStarters, projMapW);
      var projB = sumFromMap(bStarters, projMapW);
      var actA = sumFromMap(aStarters, statsMapW);
      var actB = sumFromMap(bStarters, statsMapW);
      var pillsA = self.statusPillsFromCounts(countsA);
      var pillsB = self.statusPillsFromCounts(countsB);

      var card = document.createElement("div");
      card.className = "bg-gray-900 border border-gray-800 rounded-2xl p-4 hover:bg-gray-850 cursor-pointer";
      card.setAttribute("data-matchup-card", "1");
      card.dataset.label = p.label;
      card.dataset.rosterA = String(rosterA.roster_id);
      card.dataset.rosterB = String(rosterB.roster_id);

      card.innerHTML = 
        '<div class="flex items-start justify-between gap-3">' +
          '<div class="min-w-0">' +
            '<div class="text-[11px] text-gray-500 font-mono">' + self.escapeHtml(p.subLabel || ("Week " + weekNum)) + '</div>' +
            '<div class="text-white font-bold text-lg truncate">' + self.escapeHtml(teamAName) + ' <span class="text-gray-500 font-normal">vs</span> ' + self.escapeHtml(teamBName) + '</div>' +
          '</div>' +
          '<div class="text-xs text-gray-400 font-mono whitespace-nowrap">' + self.escapeHtml(p.label) + '</div>' +
        '</div>' +
        '<div class="mt-3 grid grid-cols-2 gap-3">' +
          '<div class="bg-gray-950 border border-gray-800 rounded-xl p-3">' +
            '<div class="flex items-center justify-between gap-2">' +
              '<div class="text-gray-300 text-sm truncate">' + self.escapeHtml(teamAName) + '</div>' +
              '<div class="text-accent font-black font-mono">' + A.toFixed(2) + '</div>' +
            '</div>' +
            '<div class="text-[11px] text-gray-500 font-mono">Proj ' + projA.toFixed(2) + ' ‚Ä¢ Act ' + actA.toFixed(2) + '</div>' +
          (pillsA ? '<div class=\"mt-2\">' + pillsA + '</div>' : '') +
            '</div>' +
          '<div class="bg-gray-950 border border-gray-800 rounded-xl p-3">' +
            '<div class="flex items-center justify-between gap-2">' +
              '<div class="text-gray-300 text-sm truncate">' + self.escapeHtml(teamBName) + '</div>' +
              '<div class="text-accent font-black font-mono">' + B.toFixed(2) + '</div>' +
            '</div>' +
            '<div class="text-[11px] text-gray-500 font-mono">Proj ' + projB.toFixed(2) + ' ‚Ä¢ Act ' + actB.toFixed(2) + '</div>' +
          (pillsB ? '<div class=\"mt-2\">' + pillsB + '</div>' : '') +
            '</div>' +
        '</div>' +
        '<div class="mt-3 text-xs text-gray-500 font-mono">' +
          'Click to compare active starters (hybrid: actual if played, else projection).' +
        '</div>';
      grid.appendChild(card);
    });
  },

  renderFATabs: function() {
    var self = this;
    var tabs = [
      { id: "ALL", label: "Best Available", limit: 100, pos: null },
      { id: "QB", label: "QBs", limit: 30, pos: ["QB"] },
      { id: "RB", label: "RBs", limit: 50, pos: ["RB"] },
      { id: "WR", label: "WRs", limit: 50, pos: ["WR"] },
      { id: "TE", label: "TEs", limit: 30, pos: ["TE"] },
      { id: "K", label: "Ks", limit: 30, pos: ["K"] },
      { id: "DL", label: "DL", limit: 50, pos: ["DL", "DE", "DT", "NT"] },
      { id: "LB", label: "LB", limit: 50, pos: ["LB", "ILB", "OLB", "MLB"] },
      { id: "DB", label: "DB", limit: 50, pos: ["DB", "CB", "S", "SS", "FS"] }
    ];

    var bar = this.dom.faTabs;
    if (!bar) return;
    bar.innerHTML = "";
    
    tabs.forEach(function(t) {
      var active = t.id === self.ui.selectedFA;
      var btn = document.createElement("button");
      btn.className = active
        ? "px-4 py-2 rounded-xl font-bold whitespace-nowrap madden-tab madden-tab-active"
        : "px-4 py-2 rounded-xl font-bold whitespace-nowrap madden-tab text-gray-300";
      btn.textContent = t.label;
      btn.onclick = function() {
        self.ui.selectedFA = t.id;
        self.renderFATabs();
        self.renderFA();
      };
      bar.appendChild(btn);
    });

    this.ui.faConfig = tabs;
  },

renderFA: function() {
    var self = this;
    var cfg = this.ui.faConfig.find(function(x) { return x.id === self.ui.selectedFA; });
    var list = this.dom.faList;
    if (!list) return;
    list.innerHTML = "";
    if (!cfg) return;

    var doRender = function() {
      var totals = self.data.seasonTotals || {};
      var week = String(self.ui.selectedWeek);
      var statsMap = self.data.weekStats[week] || {};
      var projMap = self.data.weekProj[week] || {};
      
      // 1. Get ALL players (Rostered + FA)
      var allPlayers = Object.values(self.data.playersById);

      // 2. Sort ALL players by Season Total Points (Descending)
      allPlayers.sort(function(a, b) {
        var ta = totals[String(a.player_id)] || 0;
        var tb = totals[String(b.player_id)] || 0;
        return tb - ta;
      });

      // 3. Assign League-Wide Ranks
      var rankMap = {};
      var posCounters = {};

      allPlayers.forEach(function(p, index) {
        var pid = String(p.player_id);
        var pos = p.position || "UNK";
        if (!posCounters[pos]) posCounters[pos] = 0;
        posCounters[pos]++;
        rankMap[pid] = {
          overall: index + 1,
          posRank: posCounters[pos]
        };
      });

      // 4. Identify Rostered Players (hide them from the Free Agent list)
      var rostered = new Set();
      self.data.rosters.forEach(function(r) {
        var buckets = [];
        if (r.players) buckets.push(r.players);
        if (r.starters) buckets.push(r.starters);
        if (r.taxi) buckets.push(r.taxi);
        if (r.reserve) buckets.push(r.reserve);
        if (r.ir) buckets.push(r.ir);
        if (r.injured_reserve) buckets.push(r.injured_reserve);
        buckets.forEach(function(arr) {
          (arr || []).forEach(function(pid) { rostered.add(String(pid)); });
        });
      });

      // 5. Filter the SORTED list to show only Free Agents
      var candidates = allPlayers.filter(function(p) {
        if (!p) return false;
        var notRostered = !rostered.has(String(p.player_id));
        var posOk = cfg.pos ? cfg.pos.indexOf(p.position) >= 0 : true;
        var hasStats = totals[String(p.player_id)] > 0;
        var isMarkedActive = p.active === true || p.active === 1 || p.active === "true" || p.status === "Active";
        var includePlayer = hasStats || (isMarkedActive && (cfg.pos || nvl(p.search_rank, 999999) <= 5000));
        return notRostered && posOk && includePlayer;
      });

      // 6. Limit list size for performance
      var top = candidates.slice(0, cfg.limit);

      if (!top.length) {
        list.innerHTML = '<div class="p-6 text-gray-500 text-center">No available players found for ' + cfg.id + '.</div>';
        return;
      }

      // Create 2-column grid container
      var gridContainer = document.createElement("div");
      gridContainer.className = "ui2k-card-grid";

      // 7. Render as player cards
      top.forEach(function(p, index) {
        var pid = String(p.player_id);
        var disp = self.playerDisplay(p);
        var tot = totals[pid] || 0;
        
        // Get week stats for this player
        var projStats = projMap[pid] || {};
        var actStats = statsMap[pid] || {};
        var proj = self.scoreFromStats(projStats, pid);
        var act = self.scoreFromStats(actStats, pid);
        var hasPlayed = Object.keys(actStats).length > 0;
        var opp = self.getOpponent(actStats, projStats, p, self.ui.selectedWeek);
        var enhancedMU = self.getEnhancedMatchupInfo(pid, opp);
        var muScore = (enhancedMU && enhancedMU.matchScore !== undefined) ? enhancedMU.matchScore : null;
        var status = self.boomBustStatus(proj, act, hasPlayed, muScore);
        
        // Get the pre-calculated league-wide rank
        var ranks = rankMap[pid] || { overall: 999, posRank: 999 };
        var ppgRankFA = self.getPlayerPpgRank(pid);
        var deltaRankFA = self.getPlayerDeltaRank(pid);
        var valObjFA = self.getPlayerValue(pid);

        var item = {
          pid: pid,
          slot: "FA",
          isStarter: false,
          player: p,
          disp: disp,
          proj: proj,
          act: act,
          hasPlayed: hasPlayed,
          status: status,
          scoreToShow: hasPlayed ? act : proj,
          opp: opp,
          enhancedMU: enhancedMU,
          valueScore: valObjFA ? valObjFA.score : null,
          posRank: { rank: cfg.pos ? ranks.posRank : ranks.overall },
          ppgRank: ppgRankFA,
          deltaRank: deltaRankFA,
          seasonTotal: tot,
          isOut: false
        };

        var card = self.buildPlayerCardElement(item, { showSlot: false });
        gridContainer.appendChild(card);
      });

      list.appendChild(gridContainer);
    };

    if (!this.data.seasonTotals) {
      this.setProgress("Building season totals‚Ä¶", 75);
      this.buildSeasonTotals().then(function() {
        self.setProgress("Ready", 100);
        doRender();
      });
    } else {
      doRender();
    }
  },

  openPlayerModal: function(playerId) {
    var self = this;
    var pid = String(playerId);
    var p = this.data.playersById[pid] || {};
    var disp = this.playerDisplay(p);

    if (this.dom.pmName) this.dom.pmName.textContent = disp.name;
    if (this.dom.pmMeta) this.dom.pmMeta.textContent = disp.pos + " ‚Ä¢ " + disp.team + (disp.age ? (" ‚Ä¢ Age " + disp.age) : "") + " ‚Ä¢ Sleeper ID " + pid;

    var rank = this.positionRank(pid);
    var ppgRank = this.getPlayerPpgRank(pid);
    var deltaRank = this.getPlayerDeltaRank(pid);
    if (this.dom.pmRank) {
      var s = rank ? ("Rank: #" + rank.rank + " " + rank.pos) : "Rank: ‚Äî";
      if (ppgRank && isFinite(ppgRank.rank)) s += (" | PPG Rank: #" + ppgRank.rank + " " + ppgRank.pos);
      if (deltaRank && isFinite(deltaRank.rank)) s += (" | Œî Rank: #" + deltaRank.rank + " " + deltaRank.pos);
      this.dom.pmRank.textContent = s;
    }
    
    // Populate efficiency metrics section
    if (this.dom.pmEfficiencyGrid) {
      var eff = this.getPlayerEfficiencyMetrics(pid, p);
      var effHtml = '';
      
      if (eff && eff.games > 0) {
        var role = eff.role || 'Unknown';
        
        // Common metrics card
        effHtml += '<div class="bg-gray-900 rounded-lg p-3 border border-gray-800">' +
          '<div class="text-[10px] text-gray-500 uppercase">Games</div>' +
          '<div class="text-lg font-bold text-white">' + eff.games + '</div>' +
        '</div>';
        
        // Position-specific metrics
        if (role === 'QB') {
          effHtml += this.effMetricCard('Cmp%', eff.cmpRate.toFixed(0) + '%', 'text-accent');
          effHtml += this.effMetricCard('Pass Yd/G', eff.passYdPerGame.toFixed(0), 'text-white');
          effHtml += this.effMetricCard('Pass TD/G', eff.passTdPerGame.toFixed(1), 'text-green-400');
          effHtml += this.effMetricCard('INT/G', eff.intPerGame.toFixed(1), 'text-red-400');
          effHtml += this.effMetricCard('Rush Yd/G', eff.rushYdPerGame.toFixed(0), 'text-gray-300');
        } else if (role === 'RB') {
          effHtml += this.effMetricCard('YPC', eff.ypc.toFixed(1), 'text-accent');
          effHtml += this.effMetricCard('Rush Yd/G', eff.rushYdPerGame.toFixed(0), 'text-white');
          effHtml += this.effMetricCard('Rush TD/G', eff.rushTdPerGame.toFixed(1), 'text-green-400');
          effHtml += this.effMetricCard('Tgt/G', eff.tgtPerGame.toFixed(1), 'text-yellow-400');
          effHtml += this.effMetricCard('Catch%', eff.catchRate.toFixed(0) + '%', 'text-gray-300');
        } else if (role === 'WR' || role === 'TE') {
          effHtml += this.effMetricCard('Tgt/G', eff.tgtPerGame.toFixed(1), 'text-accent');
          effHtml += this.effMetricCard('Catch%', eff.catchRate.toFixed(0) + '%', 'text-white');
          effHtml += this.effMetricCard('YPR', eff.ypr.toFixed(1), 'text-yellow-400');
          effHtml += this.effMetricCard('Rec Yd/G', eff.recYdPerGame.toFixed(0), 'text-gray-300');
          effHtml += this.effMetricCard('TD/G', eff.tdRate.toFixed(1), 'text-green-400');
        } else if (role === 'K') {
          effHtml += this.effMetricCard('FGM/G', eff.fgmPerGame.toFixed(1), 'text-accent');
          effHtml += this.effMetricCard('FG%', eff.fgPct.toFixed(0) + '%', 'text-white');
          effHtml += this.effMetricCard('XPM/G', eff.xpmPerGame.toFixed(1), 'text-green-400');
        } else if (role === 'DL') {
          effHtml += this.effMetricCard('Sack/G', eff.sackPerGame.toFixed(2), 'text-accent');
          effHtml += this.effMetricCard('QBHit/G', eff.qbHitPerGame.toFixed(1), 'text-white');
          effHtml += this.effMetricCard('TFL/G', eff.tflPerGame.toFixed(1), 'text-yellow-400');
          effHtml += this.effMetricCard('Tkl/G', eff.tklPerGame.toFixed(1), 'text-gray-300');
          effHtml += this.effMetricCard('Disrupt', eff.disruptionScore.toFixed(1), 'text-red-400 font-bold');
        } else if (role === 'LB') {
          effHtml += this.effMetricCard('Tkl/G', eff.tklPerGame.toFixed(1), 'text-accent');
          effHtml += this.effMetricCard('Solo/G', eff.tklSoloPerGame.toFixed(1), 'text-white');
          effHtml += this.effMetricCard('TFL/G', eff.tflPerGame.toFixed(1), 'text-yellow-400');
          effHtml += this.effMetricCard('Sack/G', eff.sackPerGame.toFixed(2), 'text-gray-300');
          effHtml += this.effMetricCard('BigPlay/G', eff.bigPlayRate.toFixed(1), 'text-red-400 font-bold');
        } else if (role === 'DB') {
          effHtml += this.effMetricCard('INT/G', eff.intPerGame.toFixed(2), 'text-accent');
          effHtml += this.effMetricCard('PD/G', eff.passDefPerGame.toFixed(1), 'text-white');
          effHtml += this.effMetricCard('Tkl/G', eff.tklPerGame.toFixed(1), 'text-yellow-400');
          effHtml += this.effMetricCard('FF/G', eff.ffPerGame.toFixed(2), 'text-gray-300');
          effHtml += this.effMetricCard('BigPlay/G', eff.bigPlayRate.toFixed(1), 'text-red-400 font-bold');
        }
      } else {
        effHtml = '<div class="col-span-full text-gray-500 text-sm">No efficiency data available</div>';
      }
      
      this.dom.pmEfficiencyGrid.innerHTML = effHtml;
    }
    
    // Populate matchup analysis section
    if (this.dom.pmMatchupGrid) {
      var currentWeek = this.getMaxWeek();
      var opp = this.getOpponent({}, {}, p, currentWeek);
      var muHtml = '';
      
      if (opp) {
        var enhMU = this.getEnhancedMatchupInfo(pid, opp);
        if (enhMU) {
          // Left side - MU Score breakdown
          var muCls = enhMU.matchScore >= 70 ? 'text-accent' : enhMU.matchScore >= 50 ? 'text-gray-300' : 'text-red-400';
          var muBg = enhMU.matchScore >= 70 ? 'bg-accent/10 border-accent/30' : enhMU.matchScore >= 50 ? 'bg-gray-800 border-gray-700' : 'bg-red-900/10 border-red-900/30';
          
          muHtml += '<div class="' + muBg + ' border rounded-lg p-4">' +
            '<div class="text-xs text-gray-500 uppercase mb-2">vs ' + opp + ' - MU Score</div>' +
            '<div class="text-4xl font-black ' + muCls + '">' + Math.round(enhMU.matchScore) + '</div>' +
            '<div class="text-xs text-gray-400 mt-2">' + (enhMU.statLine || '') + '</div>' +
            '<div class="mt-3 grid grid-cols-2 gap-2 text-xs">' +
              '<div><span class="text-gray-500">PPG Allow:</span> <span class="text-white font-mono">' + (enhMU.ppg || 0).toFixed(1) + '</span></div>' +
              '<div><span class="text-gray-500">Last 4:</span> <span class="text-white font-mono">' + (enhMU.last4 || 0).toFixed(1) + '</span></div>' +
              '<div><span class="text-gray-500">Rank:</span> <span class="text-white font-mono">#' + (enhMU.rank || '?') + '</span></div>' +
              '<div><span class="text-gray-500">Ceil%:</span> <span class="text-green-400 font-mono">' + ((enhMU.ceilRate || 0) * 100).toFixed(0) + '%</span></div>' +
            '</div>' +
          '</div>';
          
          // Right side - Score breakdown
          if (enhMU.breakdown) {
            var bd = enhMU.breakdown;
            muHtml += '<div class="bg-gray-800 border border-gray-700 rounded-lg p-4">' +
              '<div class="text-xs text-gray-500 uppercase mb-2">Score Breakdown</div>' +
              '<div class="space-y-2 text-sm font-mono">' +
                '<div class="flex justify-between"><span class="text-gray-400">Base (Rank)</span><span class="text-white">' + (bd.base || 0).toFixed(0) + '</span></div>' +
                '<div class="flex justify-between"><span class="text-gray-400">Trend</span><span class="' + ((bd.trend || 0) >= 0 ? 'text-green-400' : 'text-red-400') + '">' + ((bd.trend || 0) >= 0 ? '+' : '') + (bd.trend || 0).toFixed(0) + '</span></div>' +
                '<div class="flex justify-between"><span class="text-gray-400">Ceiling Bonus</span><span class="text-green-400">+' + (bd.ceilBonus || 0).toFixed(0) + '</span></div>' +
                '<div class="flex justify-between"><span class="text-gray-400">Floor Penalty</span><span class="text-red-400">-' + (bd.floorPenalty || 0).toFixed(0) + '</span></div>' +
                '<div class="flex justify-between"><span class="text-gray-400">Consistency</span><span class="text-gray-300">+' + (bd.consistencyBonus || 0).toFixed(0) + '</span></div>' +
                '<div class="flex justify-between"><span class="text-gray-400">Top-10 Rate</span><span class="text-yellow-400">+' + (bd.top10Bonus || 0).toFixed(0) + '</span></div>' +
              '</div>' +
            '</div>';
          }
        } else {
          muHtml = '<div class="col-span-full text-gray-500 text-sm">vs ' + opp + ' - No matchup data available</div>';
        }
      } else {
        muHtml = '<div class="col-span-full text-gray-500 text-sm">No opponent scheduled</div>';
      }
      
      this.dom.pmMatchupGrid.innerHTML = muHtml;
    }

    if (this.dom.playerModal) {
      this.dom.playerModal.classList.remove("hidden");
      this.dom.playerModal.classList.add("flex");
    }

    var maxWeek = 18;
    this.setProgress("Loading " + disp.name + " history‚Ä¶", 75);

    var labels = [], actual = [], projected = [], opps = [], oppNotes = [], playedArr = [], muArr = [];

    var loadWeeksAndRender = function(w) {
      if (w > maxWeek) {
        var playedWeeks = 0, boom = 0, bust = 0, within = 0, majorBoom = 0, majorBust = 0;
        for (var i = 0; i < labels.length; i++) {
          if (!playedArr[i]) continue; // Skip weeks they didn't play
          playedWeeks++;
          var proj = projected[i] || 0;
          var act = actual[i] || 0;
          var mu = muArr[i];
          if (proj > 0 && act >= proj * self.cfg.boomPct) {
            if (mu !== null && mu !== undefined && isFinite(mu) && mu < 30) majorBoom++;
            else boom++;
          } else if (proj > 0 && act <= proj * self.cfg.bustPct) {
            if (mu !== null && mu !== undefined && isFinite(mu) && mu > 80) majorBust++;
            else bust++;
          } else within++;
        }
        if (self.dom.pmBoomBustOverall) {
          self.dom.pmBoomBustOverall.textContent = playedWeeks ? ("Overall: Boom " + (boom + majorBoom) + (majorBoom ? (" (Major " + majorBoom + ")") : "") + " ‚Ä¢ Bust " + (bust + majorBust) + (majorBust ? (" (Major " + majorBust + ")") : "") + " ‚Ä¢ Within " + within) : "Overall: ‚Äî";
        }

        self.renderModalChart(labels, actual, projected);

        var tbody = self.dom.pmTable;
        if (!tbody) return;
        tbody.innerHTML = "";

        for (var w2 = 1; w2 <= maxWeek; w2++) {
          var idx = w2 - 1;
          var projVal = nvl(projected[idx], 0);
          var actVal = actual[idx];
          var played = playedArr[idx];
          var isFuture = actVal === null;
          var status = isFuture 
            ? { label: "Upcoming", color: "text-gray-400", bg: "bg-gray-800" }
            : self.boomBustStatus(projVal, nvl(actVal, 0), played, muArr[idx]);
          var delta = (played && !isFuture) ? (actVal - projVal) : null;

          var tr = document.createElement("tr");
          tr.innerHTML = 
            '<td class="px-4 py-2 font-mono text-gray-300">W' + w2 + '</td>' +
            '<td class="px-4 py-2 font-mono text-gray-300">' +
              '<div>' + opps[idx] + '</div>' +
              (oppNotes[idx] ? ('<div class="text-[10px] text-gray-500 font-mono mt-0.5">' + self.escapeHtml(oppNotes[idx]) + '</div>') : '') +
            '</td>' +
            '<td class="px-4 py-2 text-right font-mono text-gray-300">' + projVal.toFixed(2) + '</td>' +
            '<td class="px-4 py-2 text-right font-mono ' + (played ? self.scoreColor(projVal, actVal, true) : "text-gray-500") + '">' + (isFuture ? "‚Äî" : (played ? actVal.toFixed(2) : "0.00")) + '</td>' +
            '<td class="px-4 py-2 text-right font-mono text-gray-400">' + (delta !== null ? delta.toFixed(2) : "‚Äî") + '</td>' +
            '<td class="px-4 py-2">' +
              '<span class="text-xs font-mono px-2 py-1 rounded ' + status.bg + ' ' + status.color + ' ' + (status.label === "Major Boom" ? "glow-majorBoom" : (status.label === "Major Bust" ? "glow-majorBust" : "")) + '">' + status.label + '</span>' +
            '</td>';
          tbody.appendChild(tr);
        }

        self.setProgress("Ready", 100);
        return;
      }

      var wk = String(w);
      var currentNflWeek = (self.data.nflState ? self.getNflStateWeek() : 18) || 18;
      var proceed = function() {
        var projMap = self.data.weekProj[wk] || {};
        var statsMap = self.data.weekStats[wk] || {};
        var projStats = projMap[pid] || {};
        var actStats = statsMap[pid] || {};
        var proj = self.scoreFromStats(projStats, pid);
        var act = self.scoreFromStats(actStats, pid);
        var played = Object.keys(actStats).length > 0;
        var opp = self.getOpponent(actStats, projStats, p, w);
        var effectiveWeek = Number((self.data && self.data.maxWeek) || currentNflWeek || 1);
        var isFutureWeek = w > effectiveWeek;

        labels.push("W" + w);
        playedArr.push(played);
        
        if (isFutureWeek) {
          // Future week - show projections
          projected.push(proj);
          actual.push(null); // No actual yet
        } else if (played) {
          // Past week where player played
          projected.push(proj);
          actual.push(act);
        } else {
          // Past week where player didn't play (bye/out) - show 0
          projected.push(0);
          actual.push(0);
        }
        opps.push(opp || "‚Äî");
        var muVal = null;
              // Defense-vs-role note (aggregates + depth roles)
              try {
                var primary = (disp && disp.posPrimary) ? String(disp.posPrimary).toUpperCase() : "";
                var roleKey = primary;
                if (primary === "DL" || primary === "LB" || primary === "DB") {
                  var depth = (p && (p.depth_chart_position || p.depth_chart_pos)) ? String(p.depth_chart_position || p.depth_chart_pos).toUpperCase() : "";
                  roleKey = depth || primary;
                }
                var info = self.getDefenseRoleInfo(opp, roleKey);
                if (!info && roleKey !== primary && primary) info = self.getDefenseRoleInfo(opp, primary);
                if (info && isFinite(info.ppg)) {
                  var rk = info.rankMost ? ("#" + info.rankMost) : "";
                  var parts = [];
                  var rk2 = info.rankMost ? ("#" + info.rankMost) : "";
                  parts.push(roleKey + " " + info.ppg.toFixed(1) + " PPG" + (rk2 ? (" (" + rk2 + ")") : ""));
                  if (isFinite(info.last4)) parts.push("L4 " + info.last4.toFixed(1));
                  if (isFinite(info.matchScore)) { muVal = info.matchScore; parts.push("MU " + Math.round(info.matchScore)); }
                  oppNotes.push(parts.join(" ‚Ä¢ "));
                } else {
                  oppNotes.push("");
                }
              } catch (e) {
                oppNotes.push("");
              }
        muArr.push(muVal);

        loadWeeksAndRender(w + 1);
      };

      if (!self.data.weekProj[wk] || !self.data.weekStats[wk]) {
        self.loadWeek(w).then(proceed);
      } else {
        proceed();
      }
    };

    loadWeeksAndRender(1);
  },

  renderModalChart: function(labels, actual, projected) {
    var ctx = this.dom.pmChart.getContext("2d");

    if (this.ui.chart) {
      this.ui.chart.destroy();
      this.ui.chart = null;
    }

    this.ui.chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: labels,
        datasets: [
          { 
            label: "Actual (custom)", 
            data: actual, 
            spanGaps: true, 
            tension: 0.25, 
            pointRadius: 4,
            pointBackgroundColor: "#22c55e",
            borderColor: "#22c55e",
            backgroundColor: "rgba(34, 197, 94, 0.1)"
          },
          { 
            label: "Projected (custom)", 
            data: projected, 
            tension: 0.25, 
            borderDash: [6, 6], 
            pointRadius: 3,
            pointBackgroundColor: "#10b981",
            borderColor: "#10b981",
            backgroundColor: "rgba(0, 206, 184, 0.1)"
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          intersect: false,
          mode: 'index'
        },
        plugins: {
          legend: { 
            labels: { 
              color: "#cbd5e1",
              usePointStyle: true,
              padding: 20
            } 
          },
          tooltip: { 
            backgroundColor: "rgba(15, 23, 42, 0.9)",
            titleColor: "#fff",
            bodyColor: "#cbd5e1",
            borderColor: "#334155",
            borderWidth: 1,
            padding: 12,
            callbacks: { 
              label: function(context) { 
                var val = context.raw;
                if (val === null || val === undefined) return context.dataset.label + ": ‚Äî";
                return context.dataset.label + ": " + Number(val).toFixed(2); 
              } 
            } 
          }
        },
        scales: {
          x: { 
            ticks: { color: "#94a3b8" }, 
            grid: { color: "rgba(148,163,184,0.10)" } 
          },
          y: { 
            ticks: { color: "#94a3b8" }, 
            grid: { color: "rgba(148,163,184,0.10)" }, 
            beginAtZero: true 
          }
        }
      }
    });
  },

  renderDefenses: function() {
    var self = this;
    var content = this.dom.defContent;
    if (!content) return;
    
    // Check if defense stats were loaded and have actual data
    var stats = this.data.pfrDefenseStats || {};
    var hasData = Object.keys(stats).some(function(team) {
      return stats[team] && stats[team].games > 0;
    });
    
    if (!hasData) {
      content.innerHTML = '<div class="col-span-2 flex items-center justify-center py-12"><div class="text-gray-500">No defense stats available yet. Stats will populate once games have been played.</div></div>';
      return;
    }
    
    this.renderDefensesContent();
  },

  renderDefensesContent: function() {
    var self = this;
    var content = this.dom.defContent;
    content.innerHTML = "";

    // NFL Teams data with conference/division info
    var nflTeams = {
      AFC: {
        East: ["BUF", "MIA", "NE", "NYJ"],
        North: ["BAL", "CIN", "CLE", "PIT"],
        South: ["HOU", "IND", "JAX", "TEN"],
        West: ["DEN", "KC", "LV", "LAC"]
      },
      NFC: {
        East: ["DAL", "NYG", "PHI", "WAS"],
        North: ["CHI", "DET", "GB", "MIN"],
        South: ["ATL", "CAR", "NO", "TB"],
        West: ["ARI", "LAR", "SF", "SEA"]
      }
    };

    var teamNames = {
      ARI: "Arizona Cardinals", ATL: "Atlanta Falcons", BAL: "Baltimore Ravens", BUF: "Buffalo Bills",
      CAR: "Carolina Panthers", CHI: "Chicago Bears", CIN: "Cincinnati Bengals", CLE: "Cleveland Browns",
      DAL: "Dallas Cowboys", DEN: "Denver Broncos", DET: "Detroit Lions", GB: "Green Bay Packers",
      HOU: "Houston Texans", IND: "Indianapolis Colts", JAX: "Jacksonville Jaguars", KC: "Kansas City Chiefs",
      LAC: "Los Angeles Chargers", LAR: "Los Angeles Rams", LV: "Las Vegas Raiders", MIA: "Miami Dolphins",
      MIN: "Minnesota Vikings", NE: "New England Patriots", NO: "New Orleans Saints", NYG: "New York Giants",
      NYJ: "New York Jets", PHI: "Philadelphia Eagles", PIT: "Pittsburgh Steelers", SEA: "Seattle Seahawks",
      SF: "San Francisco 49ers", TB: "Tampa Bay Buccaneers", TEN: "Tennessee Titans", WAS: "Washington Commanders"
    };

    var conf = this.ui.selectedConference;
    var divisions = nflTeams[conf];
    var pfrStats = this.data.pfrDefenseStats;
    //var season = this.getSeason();
    var season = 2025;
    var dataSource = season + " NFL Season Stats (via Pro-Football-Reference)";

    // Get defense stats from our data
    var getTeamDefenseStats = function(teamAbbr) {
      if (pfrStats && pfrStats[teamAbbr]) {
        var pfr = pfrStats[teamAbbr];
        return {
          team: teamAbbr,
          name: teamNames[teamAbbr] || teamAbbr,
          gamesPlayed: pfr.games || 17,
          ptsPerGame: pfr.ptsPerGame || "0.0",
          passYdsPerGame: pfr.passYdsPerGame || "0.0",
          rushYdsPerGame: pfr.rushYdsPerGame || "0.0",
          totalPts: pfr.totalPts || 0,
          sacks: pfr.sacks || 0,
          interceptions: pfr.interceptions || 0,
          passTD: pfr.passTD || 0,
          rushTD: pfr.rushTD || 0,
          hasRealPassRushData: pfr.hasRealPassRushData || false
        };
      }
      // Fallback for any missing team
      return {
        team: teamAbbr,
        name: teamNames[teamAbbr] || teamAbbr,
        gamesPlayed: 0,
        ptsPerGame: "0.0",
        passYdsPerGame: "0.0",
        rushYdsPerGame: "0.0",
        totalPts: 0,
        sacks: 0,
        interceptions: 0,
        passTD: 0,
        rushTD: 0,
        hasRealPassRushData: false
      };
    };

    // Collect all team stats for ranking (both conferences for accurate rankings)
    var allTeamStats = [];
    Object.keys(nflTeams.AFC).forEach(function(div) {
      nflTeams.AFC[div].forEach(function(team) {
        allTeamStats.push(getTeamDefenseStats(team));
      });
    });
    Object.keys(nflTeams.NFC).forEach(function(div) {
      nflTeams.NFC[div].forEach(function(team) {
        allTeamStats.push(getTeamDefenseStats(team));
      });
    });

    // Sort by points allowed per game (lower is better)
    allTeamStats.sort(function(a, b) { return parseFloat(a.ptsPerGame) - parseFloat(b.ptsPerGame); });

    // Assign rankings
    allTeamStats.forEach(function(t, idx) { t.overallRank = idx + 1; });

    // Helper to get numeric value for sorting, putting N/A at end
    var getNumericForSort = function(val) {
      var num = parseFloat(val);
      return isNaN(num) ? 99999 : num;
    };

    // Check if we have real pass/rush data (not all estimated from total yards)
    var hasRealData = self.data.hasRealPassRushData;
    
    if (hasRealData) {
      // Use actual pass/rush yard rankings
      var passRanks = allTeamStats.slice().sort(function(a, b) { 
        return getNumericForSort(a.passYdsPerGame) - getNumericForSort(b.passYdsPerGame); 
      });
      passRanks.forEach(function(t, idx) { 
        var orig = allTeamStats.find(function(x) { return x.team === t.team; });
        if (orig) orig.passRank = t.passYdsPerGame === "N/A" ? "‚Äî" : (idx + 1);
      });

      var rushRanks = allTeamStats.slice().sort(function(a, b) { 
        return getNumericForSort(a.rushYdsPerGame) - getNumericForSort(b.rushYdsPerGame); 
      });
      rushRanks.forEach(function(t, idx) { 
        var orig = allTeamStats.find(function(x) { return x.team === t.team; });
        if (orig) orig.rushRank = t.rushYdsPerGame === "N/A" ? "‚Äî" : (idx + 1);
      });
    } else {
      // Data is estimated - use points-allowed ranking with slight variation
      // to provide meaningful but honest differentiation
      // Sort by total yards (from estimated data) for total yards ranking
      var totalYardsRanks = allTeamStats.slice().sort(function(a, b) { 
        var aTotal = getNumericForSort(a.passYdsPerGame) + getNumericForSort(a.rushYdsPerGame);
        var bTotal = getNumericForSort(b.passYdsPerGame) + getNumericForSort(b.rushYdsPerGame);
        return aTotal - bTotal;
      });
      
      // Assign total yards rank to both pass and rush (since they're estimated from same source)
      totalYardsRanks.forEach(function(t, idx) { 
        var orig = allTeamStats.find(function(x) { return x.team === t.team; });
        if (orig) {
          var rank = t.passYdsPerGame === "N/A" ? "‚Äî" : (idx + 1);
          orig.passRank = rank;
          orig.rushRank = rank;
          orig.yardsEstimated = true;  // Flag that this is estimated data
        }
      });
    }

    // Create lookup
    var statsLookup = {};
    allTeamStats.forEach(function(t) { statsLookup[t.team] = t; });

    // Store ranks back into pfrDefenseStats for insights to use
    allTeamStats.forEach(function(t) {
      if (self.data.pfrDefenseStats[t.team]) {
        self.data.pfrDefenseStats[t.team].overallRank = t.overallRank;
        self.data.pfrDefenseStats[t.team].passRank = t.passRank;
        self.data.pfrDefenseStats[t.team].rushRank = t.rushRank;
        self.data.pfrDefenseStats[t.team].yardsEstimated = t.yardsEstimated;
      }
    });

    // Add data source indicator
    var sourceIndicator = document.createElement("div");
    sourceIndicator.className = "col-span-2 mb-4 px-4 py-2 bg-gray-900/50 border border-gray-800 rounded-lg flex items-center justify-between";
    sourceIndicator.innerHTML = 
      '<div class="flex items-center gap-2">' +
        '<div class="w-2 h-2 rounded-full bg-accent"></div>' +
        '<span class="text-xs text-gray-400 font-mono">Data source: <span class="text-white">' + dataSource + '</span></span>' +
      '</div>' +
      '<div class="text-[10px] text-gray-500 font-mono">Rankings across all 32 NFL teams</div>';
    content.appendChild(sourceIndicator);

    // Render each division
    Object.keys(divisions).forEach(function(divName) {
      var teams = divisions[divName];
      
      var divCard = document.createElement("div");
      divCard.className = "bg-gray-900 border border-gray-800 rounded-2xl";
      
      var header = document.createElement("div");
      header.className = "p-4 border-b border-gray-800 bg-gray-950 rounded-t-2xl";
      header.innerHTML = 
        '<div class="flex items-center gap-3">' +
          '<div class="w-10 h-10 rounded-xl bg-gradient-to-br from-accent/30 to-gray-800/30 flex items-center justify-center">' +
            '<span class="text-accent font-bold text-sm">' + conf.charAt(0) + '</span>' +
          '</div>' +
          '<div>' +
            '<div class="text-white font-bold">' + conf + ' ' + divName + '</div>' +
            '<div class="text-xs text-gray-500 font-mono">Defensive rankings (lower = better)</div>' +
          '</div>' +
        '</div>';
      divCard.appendChild(header);

      var teamList = document.createElement("div");
      teamList.className = "divide-y divide-gray-800";

      teams.forEach(function(teamAbbr) {
        var stats = statsLookup[teamAbbr] || {};
        var teamRow = document.createElement("div");
        teamRow.className = "p-4 hover:bg-gray-950/50";

        // Color coding for rankings (1-8 green, 9-16 yellow, 17-32 red for 32 teams)
        var getRankColor = function(rank) {
          if (rank <= 8) return "text-sleeper-boom bg-sleeper-boom/20";
          if (rank <= 16) return "text-yellow-400 bg-yellow-900/20";
          if (rank <= 24) return "text-orange-400 bg-orange-900/20";
          return "text-red-400 bg-red-900/20";
        };

        var ptsColor = getRankColor(stats.overallRank || 16);
        var passColor = getRankColor(stats.passRank || 16);
        var rushColor = getRankColor(stats.rushRank || 16);
        
        // Check if yard data is estimated (pass/rush split not available from API)
        var yardsEstimated = stats.yardsEstimated;
        var yardsSection = '';
        
        // With real NFL.com data, we always have separate pass/rush stats
        yardsSection = 
          '<div class="bg-gray-950 rounded-lg p-2 text-center">' +
            '<div class="text-[10px] text-gray-500 uppercase font-mono flex items-center justify-center gap-1">' +
              'Pass Yds <span class="' + passColor + ' px-1 rounded text-[9px]">#' + (stats.passRank || "‚Äî") + '</span>' +
            '</div>' +
            '<div class="text-lg font-bold text-white">' + (stats.passYdsPerGame || "‚Äî") + '</div>' +
          '</div>' +
          '<div class="bg-gray-950 rounded-lg p-2 text-center">' +
            '<div class="text-[10px] text-gray-500 uppercase font-mono flex items-center justify-center gap-1">' +
              'Rush Yds <span class="' + rushColor + ' px-1 rounded text-[9px]">#' + (stats.rushRank || "‚Äî") + '</span>' +
            '</div>' +
            '<div class="text-lg font-bold text-white">' + (stats.rushYdsPerGame || "‚Äî") + '</div>' +
          '</div>';
        
        // Extra stats row (sacks, INTs, TDs allowed)
        var extraStats = '';
        if (stats.sacks || stats.interceptions) {
          extraStats = 
            '<div class="mt-2 grid grid-cols-3 gap-2">' +
              '<div class="bg-gray-950/50 rounded p-1.5 text-center">' +
                '<div class="text-[9px] text-gray-600 uppercase">Sacks</div>' +
                '<div class="text-sm font-bold text-accent">' + (stats.sacks || 0) + '</div>' +
              '</div>' +
              '<div class="bg-gray-950/50 rounded p-1.5 text-center">' +
                '<div class="text-[9px] text-gray-600 uppercase">INTs</div>' +
                '<div class="text-sm font-bold text-accent">' + (stats.interceptions || 0) + '</div>' +
              '</div>' +
              '<div class="bg-gray-950/50 rounded p-1.5 text-center">' +
                '<div class="text-[9px] text-gray-600 uppercase">TDs Allow</div>' +
                '<div class="text-sm font-bold text-red-400">' + ((stats.passTD || 0) + (stats.rushTD || 0)) + '</div>' +
              '</div>' +
            '</div>';
        }

        teamRow.innerHTML = 
          '<div class="flex items-center justify-between gap-4">' +
            '<div class="flex items-center gap-3">' +
              '<img src="' + self.teamLogoUrl(teamAbbr) + '" class="w-10 h-10 rounded-lg bg-gray-800" onerror="this.style.display=\'none\'" />' +
              '<div>' +
                '<div class="font-bold text-white">' + (stats.name || teamAbbr) + '</div>' +
                '<div class="text-xs text-gray-500 font-mono">' + (stats.gamesPlayed || 0) + ' games played</div>' +
              '</div>' +
            '</div>' +
            '<div class="text-right">' +
              '<span class="text-xs font-mono px-2 py-1 rounded ' + ptsColor + '">#' + (stats.overallRank || "‚Äî") + ' Overall</span>' +
            '</div>' +
          '</div>' +
          '<div class="mt-3 grid grid-cols-3 gap-2">' +
            '<div class="bg-gray-950 rounded-lg p-2 text-center">' +
              '<div class="text-[10px] text-gray-500 uppercase font-mono">Pts/Game</div>' +
              '<div class="text-lg font-bold text-white">' + (stats.ptsPerGame || "‚Äî") + '</div>' +
            '</div>' +
            yardsSection +
          '</div>' +
          extraStats +
          '<div class="mt-2 text-[10px] text-gray-600 font-mono">' +
            'Weakness: ' + self.getDefenseWeakness(stats) +
          '</div>';

        teamList.appendChild(teamRow);
      });

      divCard.appendChild(teamList);
      content.appendChild(divCard);
    });
  },

  getDefenseWeakness: function(stats) {
    if (!stats.passRank && !stats.rushRank) return "Data loading...";
    
    // If data is estimated, we can't compare pass vs rush meaningfully
    if (stats.yardsEstimated) {
      var overallRank = stats.overallRank || 16;
      var totalYds = parseFloat(stats.passYdsPerGame || 0) + parseFloat(stats.rushYdsPerGame || 0);
      if (overallRank <= 6) {
        return "ELITE defense (" + totalYds.toFixed(1) + " total yds/game)";
      } else if (overallRank <= 12) {
        return "Above average defense";
      } else if (overallRank <= 20) {
        return "Average defense";
      } else if (overallRank <= 26) {
        return "Below average defense (" + totalYds.toFixed(1) + " yds/game)";
      } else {
        return "WEAK defense - exploitable (" + totalYds.toFixed(1) + " yds/game)";
      }
    }
    
    var passRank = stats.passRank || 16;
    var rushRank = stats.rushRank || 16;
    
    if (passRank > rushRank + 4) {
      return "Vulnerable to PASSING (" + stats.passYdsPerGame + " yds/game allowed)";
    } else if (rushRank > passRank + 4) {
      return "Vulnerable to RUSHING (" + stats.rushYdsPerGame + " yds/game allowed)";
    } else if (passRank > 10 && rushRank > 10) {
      return "Weak against BOTH pass and rush";
    } else if (passRank <= 6 && rushRank <= 6) {
      return "ELITE defense - no major weaknesses";
    } else {
      return "Balanced - slight edge to " + (passRank > rushRank ? "pass" : "rush") + " attack";
    }
  },

  // ===============================
  // HISTORY TAB FUNCTIONS
  // ===============================

  buildHistoryWeekSelect: function() {
    var self = this;
    var sel = this.dom.historyWeekSelect;
    if (!sel) return;
    sel.innerHTML = "";
    var cw = this.getMaxWeek();
    for (var w = 1; w <= cw; w++) {
      var opt = document.createElement("option");
      opt.value = String(w);
      opt.textContent = "Week " + w;
      if (w === cw) opt.selected = true;
      sel.appendChild(opt);
    }
    this.ui.historySelectedWeek = cw;
  },

  loadHistoricalWeek: function() {
    var self = this;
    var week = this.ui.historySelectedWeek || 1;
    var loading = this.dom.historyLoading;
    
    // Show loading
    if (loading) {
      loading.classList.remove('hidden');
      loading.classList.add('flex');
    }

    // Fetch matchups for the selected week
    var url = "https://api.sleeper.app/v1/league/" + this.cfg.leagueId + "/matchups/" + week;
    
    this.fetchJson(url).then(function(matchups) {
      // Also ensure we have stats and projections for this week
      return self.loadWeek(week).then(function() {
        return matchups;
      });
    }).then(function(matchups) {
      if (loading) {
        loading.classList.add('hidden');
        loading.classList.remove('flex');
      }
      
      // Store matchups in UI state
      self.ui.historyMatchups = matchups;
      
      // Set default selected roster if not set
      if (!self.ui.historySelectedRosterId && self.data.rosters.length > 0) {
        self.ui.historySelectedRosterId = self.data.rosters[0].roster_id;
      }
      
      // Update comparison subtitle
      if (self.dom.historyCompareSubtitle) {
        self.dom.historyCompareSubtitle.textContent = "Week " + week + " totals by position.";
      }
      
      // Render the view
      self.renderHistoryTeamTabs();
      self.renderHistoryRoster();
      self.renderHistoryComparison();
    }).catch(function(err) {
      if (loading) {
        loading.classList.add('hidden');
        loading.classList.remove('flex');
      }
      if (self.dom.historyRosterList) {
        self.dom.historyRosterList.innerHTML = '<div class="text-red-400 text-sm p-4">Error loading week ' + week + ': ' + err.message + '</div>';
      }
    });
  },

  renderHistoryTeamTabs: function() {
    var self = this;
    var tabs = this.dom.historyTeamTabs;
    if (!tabs) return;
    tabs.innerHTML = "";

    this.data.rosters.forEach(function(r) {
      var name = self.rosterLabel(r);
      var btn = document.createElement("button");
      var active = String(r.roster_id) === String(self.ui.historySelectedRosterId);
      btn.className = active
        ? "px-4 py-2 rounded-xl font-bold whitespace-nowrap madden-tab madden-tab-active"
        : "px-4 py-2 rounded-xl font-bold whitespace-nowrap madden-tab text-gray-300";
      btn.textContent = name;
      btn.onclick = function() {
        self.ui.historySelectedRosterId = r.roster_id;
        self.renderHistoryTeamTabs();
        self.renderHistoryRoster();
        self.renderHistoryComparison();
      };
      tabs.appendChild(btn);
    });
  },

  renderHistoryRoster: function() {
    var self = this;
    if (this.ui.historyMode === "best") { this.renderHistoryBestLineup(); return; }
    var list = this.dom.historyRosterList;
    if (!list) return;
    list.innerHTML = "";

    var week = this.ui.historySelectedWeek || 1;
    var weekStr = String(week);
    var matchups = this.ui.historyMatchups || [];

    // Find the matchup data for the selected roster
    var matchupData = matchups.find(function(m) {
      return m && String(m.roster_id) === String(self.ui.historySelectedRosterId);
    }) || {};

    var roster = this.data.rosters.find(function(r) {
      return String(r.roster_id) === String(self.ui.historySelectedRosterId);
    });

    if (!roster) {
      list.innerHTML = '<div class="text-gray-400">Select a team.</div>';
      return;
    }

    var user = this.data.usersById[roster.owner_id];
    if (this.dom.historyTeamTitle) {
      this.dom.historyTeamTitle.textContent = this.rosterLabel(roster);
    }
    if (this.dom.historyTeamSubtitle) {
      var weekTotal = matchupData.points || 0;
      this.dom.historyTeamSubtitle.textContent = "Week " + week + " ‚Ä¢ " + weekTotal.toFixed(2) + " pts";
    }

    var statsMap = this.data.weekStats[weekStr] || {};
    var projMap = this.data.weekProj[weekStr] || {};

    var isInjuredOut = function(p) {
      var status = ((p && (p.injury_status || p.status)) || "").toString().trim().toUpperCase();
      var outStatuses = ["OUT", "IR", "PUP", "NFI", "SUSP", "SUSPENDED", "COVID", "INACTIVE", "DNR"];
      return outStatuses.indexOf(status) >= 0;
    };

    // Get starters and players from the matchup data (historical roster for that week)
    var starters = matchupData.starters || roster.starters || [];
    var allPlayers = matchupData.players || roster.players || [];
    var slots = (this.data.league && this.data.league.roster_positions) || [];

    // Render starters section
    var startersHeader = document.createElement("div");
    startersHeader.className = "flex items-center justify-between pb-2 border-b border-gray-800 mb-4";
    startersHeader.innerHTML = 
      '<div class="flex items-center gap-2">' +
        '<div class="w-2 h-2 rounded-full bg-accent"></div>' +
        '<span class="text-xs font-bold text-gray-300 uppercase tracking-wider">Active Starters</span>' +
      '</div>' +
      '<div class="text-[10px] text-gray-500 font-mono">Week ' + week + ' lineup</div>';
    list.appendChild(startersHeader);

    var starterItems = [];
    var seenStarter = new Set();

    starters.forEach(function(pid, idx) {
      if (!pid || pid === "0") return;
      pid = String(pid);
      if (seenStarter.has(pid)) return;
      seenStarter.add(pid);

      var p = self.data.playersById[pid] || {};
      var disp = self.playerDisplay(p);
      var proj = self.scoreFromStats(projMap[pid] || {}, pid);
      var actual = self.scoreFromStats(statsMap[pid] || {}, pid);
      var hasPlayed = Object.keys(statsMap[pid] || {}).length > 0;
      var opp = self.getOpponent(statsMap[pid] || {}, projMap[pid] || {}, p, week);
      var enh = self.getEnhancedMatchupInfo(pid, opp);
      var muScore = (enh && enh.matchScore !== undefined) ? enh.matchScore : null;
      var status = self.boomBustStatus(proj, actual, hasPlayed, muScore);
      var score = hasPlayed ? actual : proj;
      var scoreCls = hasPlayed ? self.scoreColor(proj, actual, true) : "text-gray-200";
      var valObj = self.getPlayerValue(pid);
      var valueScore = valObj ? valObj.score : null;
      var posRank = self.positionRank(pid);
      var ppgRank = self.getPlayerPpgRank(pid);
      var deltaRank = self.getPlayerDeltaRank(pid);
      var seasonTotal = (self.data.seasonTotals && (self.data.seasonTotals[pid] || self.data.seasonTotals[String(pid)])) || 0;
      var effMetrics = self.getPlayerEfficiencyMetrics(pid, p);
      var slot = slots[idx] || "ST";

      starterItems.push({
        pid: pid,
        player: p,
        disp: disp,
        proj: proj,
        act: actual,
        hasPlayed: hasPlayed,
        scoreToShow: score,
        scoreCls: scoreCls,
        status: status,
        slot: slot,
        valueScore: valueScore,
        opp: opp,
        enhancedMU: enh,
        posRank: posRank,
        ppgRank: ppgRank,
        deltaRank: deltaRank,
        seasonTotal: seasonTotal,
        effMetrics: effMetrics,
        isOut: isInjuredOut(p)
      });
    });

    // Group active starters by lineup slot, mirroring the Current Teams view
    var positionOrder = ["QB", "RB", "WR", "TE", "FLEX", "SUPER_FLEX", "REC_FLEX", "K", "DEF", "DL", "LB", "DB", "IDP_FLEX", "ST"];
    var positionLabels = {
      "QB": "Quarterbacks",
      "RB": "Running Backs",
      "WR": "Wide Receivers",
      "TE": "Tight Ends",
      "FLEX": "Flex",
      "SUPER_FLEX": "SF",
      "REC_FLEX": "Rec Flex",
      "K": "Kickers",
      "DEF": "Defense",
      "DL": "Defensive Line",
      "LB": "Linebackers",
      "DB": "Defensive Backs",
      "IDP_FLEX": "IDP Flex",
      "ST": "Starters"
    };

    var startersBySlot = {};
    starterItems.forEach(function(it) {
      var key = it.slot || "ST";
      if (!startersBySlot[key]) startersBySlot[key] = [];
      startersBySlot[key].push(it);
    });

    var renderHistoryCard = function(item, showSlot) {
      return self.buildPlayerCardElement(item, { showSlot: showSlot });
    };

    // Render grouped starters
    positionOrder.forEach(function(slotKey) {
      var arr = startersBySlot[slotKey];
      if (!arr || !arr.length) return;

      var section = document.createElement("div");
      section.className = "mb-4";

      var header = document.createElement("div");
      header.className = "text-[11px] uppercase tracking-wider text-gray-400 font-bold mb-2";
      header.textContent = positionLabels[slotKey] || slotKey;
      section.appendChild(header);

      var grid = document.createElement("div");
      grid.className = "ui2k-card-grid";
      arr.forEach(function(item) { grid.appendChild(renderHistoryCard(item, true)); });
      section.appendChild(grid);

      list.appendChild(section);
    });

    // Render bench section
    var starterIds = starters.map(String);
    var bench = allPlayers.filter(function(pid) { return starterIds.indexOf(String(pid)) < 0; });

    if (bench.length > 0) {
      var benchHeader = document.createElement("div");
      benchHeader.className = "flex items-center justify-between pb-2 border-b border-gray-800 mb-4";
      benchHeader.innerHTML = 
        '<div class="flex items-center gap-2">' +
          '<div class="w-2 h-2 rounded-full bg-gray-500"></div>' +
          '<span class="text-xs font-bold text-gray-400 uppercase tracking-wider">Bench</span>' +
          '<span class="text-[10px] text-gray-600 font-mono">(' + bench.length + ' players)</span>' +
        '</div>';
      list.appendChild(benchHeader);

      var benchGrid = document.createElement("div");
      benchGrid.className = "ui2k-card-grid";

      bench.forEach(function(pid) {
        if (!pid || pid === "0") return;
        pid = String(pid);
        var p = self.data.playersById[pid] || {};
        var disp = self.playerDisplay(p);
        var proj = self.scoreFromStats(projMap[pid] || {}, pid);
        var actual = self.scoreFromStats(statsMap[pid] || {}, pid);
        var hasPlayed = Object.keys(statsMap[pid] || {}).length > 0;
        var opp = self.getOpponent(statsMap[pid] || {}, projMap[pid] || {}, p, week);
        var enh = self.getEnhancedMatchupInfo(pid, opp);
        var muScore = (enh && enh.matchScore !== undefined) ? enh.matchScore : null;
        var status = self.boomBustStatus(proj, actual, hasPlayed, muScore);
        var score = hasPlayed ? actual : proj;
        var scoreCls = hasPlayed ? self.scoreColor(proj, actual, true) : "text-gray-200";
        var valObj = self.getPlayerValue(pid);
        var valueScore = valObj ? valObj.score : null;
        var posRank = self.positionRank(pid);
        var ppgRank = self.getPlayerPpgRank(pid);
        var deltaRank = self.getPlayerDeltaRank(pid);
        var seasonTotal = (self.data.seasonTotals && (self.data.seasonTotals[pid] || self.data.seasonTotals[String(pid)])) || 0;
        var effMetrics = self.getPlayerEfficiencyMetrics(pid, p);

        var cardItem = {
          pid: pid,
          slot: "BN",
          player: p,
          disp: disp,
          proj: proj,
          act: actual,
          hasPlayed: hasPlayed,
          scoreToShow: score,
          scoreCls: scoreCls,
          status: status,
          opp: opp,
          enhancedMU: enh,
          valueScore: valueScore,
          posRank: posRank,
          ppgRank: ppgRank,
          deltaRank: deltaRank,
          seasonTotal: seasonTotal,
          effMetrics: effMetrics,
          isOut: isInjuredOut(p)
        };
        benchGrid.appendChild(self.buildPlayerCardElement(cardItem, { showSlot: true }));
      });

      list.appendChild(benchGrid);
    }
  },

  renderHistoryComparison: function() {
    var self = this;
    if (this.ui.historyMode === "best") { this.renderHistoryBestComparison(); return; }
    var box = this.dom.historyCompareBox;
    if (!box) return;
    box.innerHTML = "";

    var week = this.ui.historySelectedWeek || 1;
    var weekStr = String(week);
    var matchups = this.ui.historyMatchups || [];
    var projMap = this.data.weekProj[weekStr] || {};
    var statsMap = this.data.weekStats[weekStr] || {};
    var posList = ["QB", "RB", "WR", "TE", "K", "DL", "LB", "DB"];

    var positionMap = {
      "QB": "QB", "RB": "RB", "WR": "WR", "TE": "TE", "K": "K",
      "DL": "DL", "DE": "DL", "DT": "DL", "NT": "DL",
      "LB": "LB", "ILB": "LB", "OLB": "LB", "MLB": "LB",
      "DB": "DB", "CB": "DB", "S": "DB", "SS": "DB", "FS": "DB",
      "DEF": "DL"
    };

    // Create a map of roster_id to their matchup data
    var rosterMatchupData = {};
    matchups.forEach(function(m) {
      if (m && m.roster_id) {
        rosterMatchupData[m.roster_id] = {
          starters: m.starters || [],
          players: m.players || []
        };
      }
    });

    var summarizePlayers = function(pids, useActual) {
      var posTotals = { QB: 0, RB: 0, WR: 0, TE: 0, K: 0, DL: 0, LB: 0, DB: 0 };
      var scoreMap = useActual ? statsMap : projMap;
      (pids || []).forEach(function(pid) {
        var id = String(pid);
        var p = self.data.playersById[id];
        if (!p) return;
        var mappedPos = positionMap[p.position];
        if (!mappedPos || !posTotals.hasOwnProperty(mappedPos)) return;
        posTotals[mappedPos] += self.scoreFromStats(scoreMap[id] || {}, id);
      });
      Object.keys(posTotals).forEach(function(k) { posTotals[k] = Math.round(posTotals[k] * 100) / 100; });
      var total = Math.round(posList.reduce(function(acc, k) { return acc + (posTotals[k] || 0); }, 0) * 100) / 100;
      return { posTotals: posTotals, total: total };
    };

    var selected = this.data.rosters.find(function(r) { return String(r.roster_id) === String(self.ui.historySelectedRosterId); });
    if (!selected) return;

    var mkHeatmapTable = function(opts) {
      var title = opts.title;
      var subtitle = opts.subtitle;
      var selectorFn = opts.selectorFn;
      
      var matchData = rosterMatchupData[selected.roster_id] || {};
      var selectedS = selectorFn(selected, matchData);
      var selUser = self.data.usersById[selected.owner_id];
      var selName = (selUser && selUser.display_name) || ("Team " + selected.roster_id);

      var allTeams = self.data.rosters.map(function(r) {
        var u = self.data.usersById[r.owner_id];
        var md = rosterMatchupData[r.roster_id] || {};
        return { 
          roster: r, 
          name: (u && u.display_name) || ("Team " + r.roster_id), 
          s: selectorFn(r, md), 
          isSelected: String(r.roster_id) === String(selected.roster_id) 
        };
      });

      // Normalize selector results so missing data doesn't crash the heatmaps
      var normalizeSummary = function(s) {
        s = s || {};
        if (!s.posTotals) s.posTotals = {};
        posList.forEach(function(pos) {
          var v = s.posTotals[pos];
          if (v == null || Number.isNaN(v)) s.posTotals[pos] = 0;
        });
        if (s.total == null || Number.isNaN(s.total)) s.total = 0;
        return s;
      };

      selectedS = normalizeSummary(selectedS);
      allTeams.forEach(function(t) { t.s = normalizeSummary(t.s); });

      var posValues = {};
      var totalValues = [];
      posList.forEach(function(pos) { posValues[pos] = []; });

      allTeams.forEach(function(t) {
        posList.forEach(function(pos) { posValues[pos].push(t.s.posTotals[pos] || 0); });
        totalValues.push(t.s.total || 0);
      });
var wrap = document.createElement("div");
      wrap.className = "mb-6";

      var headerCells = posList.map(function(p) { return '<th class="text-center px-1 py-1.5 w-[7%] bg-gray-950">' + p + '</th>'; }).join("");
      
      wrap.innerHTML = 
        '<div class="text-sm font-bold text-white">' + title + '</div>' +
        '<div class="mt-1 text-xs text-gray-500 font-mono">' + subtitle + '</div>' +
        '<div class="mt-3 max-h-[250px] overflow-y-auto border border-gray-800 rounded-lg">' +
          '<table class="w-full text-[12px] table-fixed tabular-nums">' +
            '<thead class="text-[11px] uppercase text-gray-400 sticky top-0 z-10">' +
              '<tr class="bg-gray-950">' +
                '<th class="text-left px-2 py-1.5 w-[33%] bg-gray-950">Team</th>' +
                headerCells +
                '<th class="text-center px-2 py-1.5 w-[11%] hidden md:table-cell bg-gray-950">TOT</th>' +
              '</tr>' +
            '</thead>' +
            '<tbody class="divide-y divide-gray-800/50"></tbody>' +
          '</table>' +
        '</div>';

      var body = wrap.querySelector("tbody");

      var sorted = allTeams.slice().sort(function(a, b) {
        if (a.isSelected) return -1;
        if (b.isSelected) return 1;
        return (b.s.total || 0) - (a.s.total || 0);
      });

      sorted.forEach(function(team) {
        var tr = document.createElement("tr");
        tr.className = team.isSelected ? "bg-gray-800/30" : "";
        
        var html = '<td class="px-2 py-1.5 ' + (team.isSelected ? 'font-bold text-white' : 'text-gray-200') + ' truncate">' + (team.isSelected ? '‚Üí ' : '') + team.name + '</td>';
        
        posList.forEach(function(pos) {
          var val = team.s.posTotals[pos] || 0;
          var color = self.getHeatmapColor(val, selectedS.posTotals[pos], posValues[pos]);
          html += '<td class="px-1 py-1.5 text-center font-mono ' + color.text + '" style="background:' + color.bg + '">' + val.toFixed(0) + '</td>';
        });
        
        var totalColor = self.getHeatmapColor(team.s.total || 0, selectedS.total, totalValues, true);
        html += '<td class="px-2 py-1.5 text-center font-mono font-bold ' + totalColor.text + ' hidden md:table-cell" style="background:' + totalColor.bg + '">' + (team.s.total || 0).toFixed(0) + '</td>';
        
        tr.innerHTML = html;
        body.appendChild(tr);
      });

      return wrap;
    };

    // Four heatmaps - using historical matchup data
    box.appendChild(mkHeatmapTable({
      title: "Team Score Projected",
      subtitle: "Week " + week + " projections for all rostered players.",
      selectorFn: function(roster, matchData) { 
        return summarizePlayers(matchData.players || roster.players || [], false); 
      }
    }));

    box.appendChild(mkHeatmapTable({
      title: "Team Score Actual",
      subtitle: "Week " + week + " actual points for all rostered players.",
      selectorFn: function(roster, matchData) { 
        return summarizePlayers(matchData.players || roster.players || [], true); 
      }
    }));

    box.appendChild(mkHeatmapTable({
      title: "Starters Score Projected",
      subtitle: "Week " + week + " projections for starters only.",
      selectorFn: function(roster, matchData) { 
        return summarizePlayers(matchData.starters || roster.starters || [], false); 
      }
    }));

    box.appendChild(mkHeatmapTable({
      title: "Starters Score Actual",
      subtitle: "Week " + week + " actual points for starters only.",
      selectorFn: function(roster, matchData) { 
        return summarizePlayers(matchData.starters || roster.starters || [], true); 
      }
    }));
  },

  // ===============================
  // INSIGHTS TAB FUNCTIONS
  // ===============================


  // Compute "best lineup" suggestions for a historical week using weighted MU + Proj + Upside.
  // FIT balances projection + MU with stability signals (season PPG, last-4 form, consistency, snaps, and boom/bust tendency).
  computeHistoryBestLineupData: function() {
    var self = this;
    var week = this.ui.historySelectedWeek || 1;
    var rosterId = this.ui.historySelectedRosterId;
    var weekStr = String(week);
    var cacheKey = weekStr + "_" + String(rosterId || "");
    this.ui._historyBestCache = this.ui._historyBestCache || {};
    if (this.ui._historyBestCache[cacheKey]) return this.ui._historyBestCache[cacheKey];

    var matchups = this.ui.historyMatchups || [];
    var matchupData = matchups.find(function(m) { return m && String(m.roster_id) === String(rosterId); }) || {};
    var rosterObj = (this.data.rosters || []).find(function(r) { return r && String(r.roster_id) === String(rosterId); }) || {};

    var allPlayers = (matchupData.players && matchupData.players.length) ? matchupData.players : (rosterObj.players || []);
    var actualStarters = (matchupData.starters && matchupData.starters.length) ? matchupData.starters : (rosterObj.starters || []);
    allPlayers = (allPlayers || []).map(function(x){ return String(x); }).filter(function(x){ return x && x !== "null" && x !== "undefined"; });
    actualStarters = (actualStarters || []).map(function(x){ return String(x); }).filter(function(x){ return x && x !== "null" && x !== "undefined"; });

    var projMap = this.data.weekProj[weekStr] || {};
    var statsMap = this.data.weekStats[weekStr] || {};

    // Starter slots (exclude bench-type slots)
    var rosterPositions = (this.data.league && Array.isArray(this.data.league.roster_positions)) ? this.data.league.roster_positions : [];
    var isBenchSlot = function(slot) {
      slot = String(slot || "").toUpperCase();
      return slot === "BN" || slot === "BE" || slot === "BENCH" || slot === "IR" || slot === "RES" || slot === "R" || slot === "TAXI" || slot === "TX";
    };
    var starterSlots = rosterPositions.filter(function(s) { return !isBenchSlot(s); }).map(function(s){ return String(s); });

    // If the matchup's starters length doesn't match the roster_positions starter length, prefer matchup length (handles odd leagues)
    if (actualStarters.length && starterSlots.length && starterSlots.length !== actualStarters.length) {
      starterSlots = starterSlots.slice(0, actualStarters.length);
    }

    // Eligibility (mirrors league-insights optimal lineup helper)
    var slotEligible = function(slot, pos) {
      slot = String(slot || "").toUpperCase();
      pos = String(pos || "").toUpperCase();

      if (slot === pos) return true;
      if (slot === "SF" || slot === "SUPER_FLEX") return (pos === "QB" || pos === "RB" || pos === "WR" || pos === "TE");
      if (slot === "OP" || slot === "OFFENSE_PLAYER") return (pos === "QB" || pos === "RB" || pos === "WR" || pos === "TE");
      if (slot === "FLEX" || slot === "WRRB_FLEX") return (pos === "RB" || pos === "WR" || pos === "TE");
      if (slot === "REC_FLEX") return (pos === "WR" || pos === "TE");
      if (slot === "IDP_FLEX") return (pos === "DL" || pos === "LB" || pos === "DB");
      if (slot === "DEF") return (pos === "DEF" || pos === "DST");
      return false;
    };

    // Pre-compute MU, projections, upside for scaling
    var projVals = [];
    var projById = {};
    var actById = {};
    var hasPlayedById = {};
    var muById = {};
    var ceilById = {};

    allPlayers.forEach(function(pid) {
      var p = self.data.playersById[pid] || {};
      var projStats = projMap[pid] || {};
      var actStats = statsMap[pid] || {};

      var proj = self.scoreFromStats(projStats, pid);
      var act = self.scoreFromStats(actStats, pid);
      var hasPlayed = Object.keys(actStats || {}).length > 0;

      // If projections are missing but the week is completed, fall back to actual so the tab still works
      if ((!isFinite(proj) || proj === 0) && hasPlayed && isFinite(act)) proj = act;

      projById[pid] = isFinite(proj) ? proj : 0;
      actById[pid] = isFinite(act) ? act : 0;
      hasPlayedById[pid] = !!hasPlayed;

      if (isFinite(projById[pid]) && projById[pid] > 0) projVals.push(projById[pid]);

      var opp = self.getOpponent(actStats, projStats, p, week);
      var enh = self.getEnhancedMatchupInfo(pid, opp);

      var mu = null;
      if (enh && isFinite(enh.matchScore)) mu = enh.matchScore;
      if ((mu === null || mu === undefined) && opp) {
        var roleKey = self.primaryRoleKeyForPlayer(p);
        var infoMU = self.getDefenseRoleInfo(opp, roleKey);
        if (infoMU && isFinite(infoMU.matchScore)) mu = infoMU.matchScore;
      }
      if (mu === null || mu === undefined || !isFinite(mu)) mu = 50;
      muById[pid] = mu;

      var ceil = (enh && enh.ceilRate !== null && enh.ceilRate !== undefined && isFinite(enh.ceilRate)) ? enh.ceilRate : 0.5;
      ceilById[pid] = ceil;
    });

    // P90 projection for scaling proj -> 0..100
    projVals.sort(function(a,b){ return a-b; });
    var p90 = projVals.length ? projVals[Math.floor((projVals.length - 1) * 0.9)] : 0;
    var projDenom = (p90 && p90 > 0) ? p90 : 20;

    // Composite "FIT" score per player (0..100)
    // FIT is meant to balance "how good the spot is" (projection + MU) with player reliability signals
    // (season PPG, last-4 form, consistency, snaps, and boom/bust tendency).
    var fitById = {};
    var pickById = {};
    var valById = {}, ppgById = {}, l4ById = {}, consById = {}, snapById = {}, bbById = {}, deltaById = {}, seasonById = {};
    var valVals = [], ppgVals = [], l4Vals = [], deltaVals = [], seasonVals = [];

    var outStatuses = ["OUT","IR","PUP","NFI","SUSP","SUSPENDED","COVID","INACTIVE","DNR"];
    var doubtfulStatuses = ["DOUBTFUL"];
    var questionableStatuses = ["QUESTIONABLE","Q"];

    allPlayers.forEach(function(pid) {
      pid = String(pid);
      var m = (self.data.playerValueMetrics && self.data.playerValueMetrics[pid]) ? self.data.playerValueMetrics[pid] : null;

      var ppg = (m && isFinite(m.ppg)) ? m.ppg : null;
      var l4 = (m && isFinite(m.l4)) ? m.l4 : null;
      var cons = (m && isFinite(m.consistency)) ? m.consistency : 0.5;
      var snap = (m && isFinite(m.snapAdj)) ? m.snapAdj : 0.5;
      var bb = (m && isFinite(m.bbAdj)) ? m.bbAdj : 0.5;
      var dlt = (m && isFinite(m.deltaAvg)) ? m.deltaAvg : 0;

      var vObj = (self.data.playerValues && self.data.playerValues[pid]) ? self.data.playerValues[pid] : null;
      var valScore = (vObj && isFinite(vObj.score)) ? vObj.score : null;
      var seasonTotal = (self.data.seasonTotals && (self.data.seasonTotals[pid] || self.data.seasonTotals[String(pid)])) || 0;

      ppgById[pid] = ppg;
      l4ById[pid] = l4;
      consById[pid] = cons;
      snapById[pid] = snap;
      bbById[pid] = bb;
      deltaById[pid] = dlt;
      valById[pid] = valScore;
      seasonById[pid] = seasonTotal;

      if (valScore !== null) valVals.push(valScore);
      if (ppg !== null) ppgVals.push(ppg);
      if (l4 !== null) l4Vals.push(l4);
      if (isFinite(dlt)) deltaVals.push(dlt);
      if (isFinite(seasonTotal)) seasonVals.push(seasonTotal);
    });

    var p90 = function(arr, fallback) {
      if (!arr || !arr.length) return fallback;
      var a = arr.slice().sort(function(x,y){ return x-y; });
      var idx = Math.floor(0.90 * (a.length - 1));
      var v = a[Math.max(0, Math.min(a.length - 1, idx))];
      return (isFinite(v) && v > 0) ? v : fallback;
    };

    var valDenom = p90(valVals, 800);

    var ppgDenom = p90(ppgVals, 12);
    var l4Denom = p90(l4Vals, 12);
    var seasonDenom = p90(seasonVals, 200);
    var dMin = null, dMax = null;
    deltaVals.forEach(function(v){
      if (!isFinite(v)) return;
      if (dMin === null || v < dMin) dMin = v;
      if (dMax === null || v > dMax) dMax = v;
    });
    var dRange = (dMin !== null && dMax !== null) ? (dMax - dMin) : 0;

    var clamp = function(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); };

    // Stability weights (sum to 1.00) for the FIT signal (separate from slider weights).
    // FIT focuses on reliability signals so the sliders can control value/proj/matchup directly.
    var W_PPG  = 0.22;
    var W_L4   = 0.22;
    var W_CS   = 0.18; // Consistency/Snaps combined
    var W_BB   = 0.10;
    var W_DLT  = 0.08;
    var W_CEIL = 0.10;
    var W_SEASON = 0.10;

    var pickWeights = self.getOptimalWeights();

    allPlayers.forEach(function(pid) {
      pid = String(pid);

      var mu = isFinite(muById[pid]) ? muById[pid] : 50;
      mu = clamp(mu, 0, 100);

      var proj = isFinite(projById[pid]) ? projById[pid] : 0;
      var projScaled = projDenom ? clamp((proj / projDenom) * 100, 0, 100) : 0;

      var val = valById[pid];
      var valScaled = (valDenom && isFinite(val)) ? clamp((val / valDenom) * 100, 0, 100) : 50;

      var ppg = ppgById[pid];
      var ppgScaled = (ppgDenom && isFinite(ppg)) ? clamp((ppg / ppgDenom) * 100, 0, 100) : 50;

      var l4 = l4ById[pid];
      var l4Scaled = (l4Denom && isFinite(l4)) ? clamp((l4 / l4Denom) * 100, 0, 100) : 50;

      var consScaled = clamp((consById[pid] || 0.5) * 100, 0, 100);
      var snapScaled = clamp((snapById[pid] || 0.5) * 100, 0, 100);
      var csScaled   = (consScaled + snapScaled) / 2;
      var bbScaled   = clamp((bbById[pid]   || 0.5) * 100, 0, 100);
      var ceilScaled = clamp((ceilById[pid] || 0) * 100, 0, 100);
      var seasonTotal = seasonById[pid];
      var seasonScaled = (seasonDenom && isFinite(seasonTotal)) ? clamp((seasonTotal / seasonDenom) * 100, 0, 100) : 50;

      var dlt = deltaById[pid];
      var dltScaled = 50;
      if (isFinite(dlt) && dRange > 0) dltScaled = clamp(((dlt - dMin) / dRange) * 100, 0, 100);

      // Availability penalty (avoid starting "Out/IR" or very doubtful players)
      var p = self.data.playersById[pid] || {};
      var st = ((p && (p.injury_status || p.status)) || "").toString().trim().toUpperCase();
      var availability = 1.0;
      if (outStatuses.indexOf(st) >= 0) availability = 0.05;
      else if (doubtfulStatuses.indexOf(st) >= 0) availability = 0.60;
      else if (questionableStatuses.indexOf(st) >= 0) availability = 0.85;

      var fitRaw =
        (W_PPG  * ppgScaled) +
        (W_L4   * l4Scaled) +
        (W_CS   * csScaled) +
        (W_BB   * bbScaled) +
        (W_DLT  * dltScaled) +
        (W_CEIL * ceilScaled) +
        (W_SEASON * seasonScaled);

      var fitAdj = clamp(fitRaw * availability, 0, 100);
      fitById[pid] = Math.round(fitAdj * 100) / 100;
      var pickRaw =
        (pickWeights.value * valScaled) +
        (pickWeights.proj * projScaled) +
        (pickWeights.mu * mu) +
        (pickWeights.fit * fitRaw) +
        (pickWeights.ppg * ppgScaled) +
        (pickWeights.l4 * l4Scaled) +
        (pickWeights.consistency * consScaled) +
        (pickWeights.snaps * snapScaled) +
        (pickWeights.boomBust * bbScaled) +
        (pickWeights.delta * dltScaled) +
        (pickWeights.ceil * ceilScaled) +
        (pickWeights.season * seasonScaled);

      var pickAdj = clamp(pickRaw * availability, 0, 100);
      pickById[pid] = Math.round(pickAdj * 100) / 100;
    });


// Build pool with primary role categories
    var pool = allPlayers.map(function(pid) {
      var p = self.data.playersById[pid] || {};
      var pos = self.primaryRoleKeyForPlayer(p) || String(p.position || "").toUpperCase();
      if (pos === "DST") pos = "DEF";
      return { id: pid, pos: pos, fit: fitById[pid] || 0, pick: pickById[pid] || 0 };
    }).filter(function(it) { return it.id && it.pos; });

    pool.sort(function(a,b){ return (b.pick || 0) - (a.pick || 0); });

    // Greedy selection (same structure as existing optimal lineup helper)
    var used = {};
    var picks = [];
    var totalFit = 0;

    var takeBest = function(slot) {
      for (var i = 0; i < pool.length; i++) {
        var it = pool[i];
        if (used[it.id]) continue;
        if (!slotEligible(slot, it.pos)) continue;
        used[it.id] = true;
        picks.push({ pid: it.id, slot: String(slot), pos: it.pos, fit: it.fit || 0 });
        totalFit += (it.fit || 0);
        return;
      }
    };

    // Fixed slots first
    var flexSlots = ["FLEX","WRRB_FLEX","REC_FLEX","SUPER_FLEX","SF","OP","IDP_FLEX"];
    starterSlots.forEach(function(slot) {
      var s = String(slot || "").toUpperCase();
      if (flexSlots.indexOf(s) >= 0) return;
      takeBest(slot);
    });
    // Then flex slots
    starterSlots.forEach(function(slot) {
      var s = String(slot || "").toUpperCase();
      if (flexSlots.indexOf(s) < 0) return;
      takeBest(slot);
    });

    // Totals vs actual starters (proj-based)
    var actualStarterSet = {};
    actualStarters.forEach(function(pid){ actualStarterSet[String(pid)] = true; });

    var bestProjTotal = 0, bestActTotal = 0, bestMuAvg = 0;
    picks.forEach(function(p) {
      var pid = p.pid;
      bestProjTotal += (projById[pid] || 0);
      bestActTotal += (actById[pid] || 0);
      bestMuAvg += (muById[pid] || 50);
    });
    if (picks.length) bestMuAvg = bestMuAvg / picks.length;

    var actualProjTotal = 0;
    actualStarters.forEach(function(pid) { actualProjTotal += (projById[String(pid)] || 0); });

    
    var actualActTotal = 0;
    actualStarters.forEach(function(pid) { actualActTotal += (actById[String(pid)] || 0); });
// Suggested changes (based on this weighted best lineup)
    var pickSet = {};
    picks.forEach(function(p){ pickSet[p.pid] = true; });

    var shouldStart = picks.filter(function(p){ return !actualStarterSet[p.pid]; }).map(function(p){ return p.pid; });
    var shouldSit = actualStarters.filter(function(pid){ return !pickSet[String(pid)]; });

    
    // Everyone else on the roster (bench / reserves) for this week
    var benchPids = allPlayers.filter(function(pid){ return !pickSet[String(pid)]; });
var data = {
      week: week,
      rosterId: rosterId,
      matchupData: matchupData,
      rosterObj: rosterObj,
      starterSlots: starterSlots,
      picks: picks,
      fitById: fitById,
      muById: muById,
      projById: projById,
      actById: actById,
      hasPlayedById: hasPlayedById,
      bestFitTotal: Math.round(totalFit * 100) / 100,
      bestProjTotal: Math.round(bestProjTotal * 100) / 100,
      bestActTotal: Math.round(bestActTotal * 100) / 100,
      bestMuAvg: Math.round(bestMuAvg * 10) / 10,
      actualProjTotal: Math.round(actualProjTotal * 100) / 100,
            actualActTotal: Math.round(actualActTotal * 100) / 100,
actualStarters: actualStarters,
      benchPids: benchPids,
      shouldStart: shouldStart,
      shouldSit: shouldSit
    };

    this.ui._historyBestCache[cacheKey] = data;
    return data;
  },

  renderHistoryBestLineup: function() {
    var self = this;
    var list = this.dom.historyRosterList;
    if (!list) return;
    list.innerHTML = "";

    var data = this.computeHistoryBestLineupData();

    // Update header title to selected team (fix: title wasn't updating in weighted lineup mode)
    if (this.dom.historyTeamTitle) {
      var _r = (data && data.rosterObj) || this.data.rosters.find(function(rr){ return String(rr.roster_id) === String(this.ui.historySelectedRosterId); }.bind(this));
      if (_r) this.dom.historyTeamTitle.textContent = this.rosterLabel(_r);
    }
    if (!data || !data.picks || !data.picks.length) {
      list.innerHTML = '<div class="text-gray-500">No roster data available for this week.</div>';
      return;
    }

    var week = data.week;

    var isInjuredOut = function(p) {
      var status = ((p && (p.injury_status || p.status)) || "").toString().trim().toUpperCase();
      var outStatuses = ["OUT", "IR", "PUP", "NFI", "SUSP", "SUSPENDED", "COVID", "INACTIVE", "DNR"];
      return outStatuses.indexOf(status) >= 0;
    };

    // Subtitle
    if (this.dom.historyTeamSubtitle) {
      this.dom.historyTeamSubtitle.textContent = "Week " + week + " | Weighted lineup view";
    }

    // Build items for rendering
    var projMap = this.data.weekProj[String(week)] || {};
    var statsMap = this.data.weekStats[String(week)] || {};

    var positionOrder = ["QB", "RB", "WR", "TE", "FLEX", "SUPER_FLEX", "REC_FLEX", "K", "DEF", "DL", "LB", "DB", "IDP_FLEX"];
    var positionLabels = {
      "QB": "Quarterbacks",
      "RB": "Running Backs",
      "WR": "Wide Receivers",
      "TE": "Tight Ends",
      "FLEX": "Flex",
      "SUPER_FLEX": "SF",
      "SF": "SF",
      "REC_FLEX": "Rec Flex",
      "K": "Kickers",
      "DEF": "Defense",
      "DL": "Defensive Line",
      "LB": "Linebackers",
      "DB": "Defensive Backs",
      "IDP_FLEX": "IDP Flex"
    };

    var startersBySlot = {};
    data.picks.forEach(function(pk) {
      var slotKey = String(pk.slot || "").toUpperCase();
      if (!startersBySlot[slotKey]) startersBySlot[slotKey] = [];
      startersBySlot[slotKey].push(pk);
    });

    var makeItem = function(pk) {
      var pid = String(pk.pid);
      var p = self.data.playersById[pid] || {};
      var disp = self.playerDisplay(p);
      var projStats = projMap[pid] || {};
      var actStats = statsMap[pid] || {};

      var proj = data.projById[pid] || 0;
      var actual = data.actById[pid] || 0;
      var hasPlayed = data.hasPlayedById[pid] || false;

      var opp = self.getOpponent(actStats, projStats, p, week);
      var enh = self.getEnhancedMatchupInfo(pid, opp);
      var muScore = (enh && isFinite(enh.matchScore)) ? enh.matchScore : (data.muById[pid] || 50);

      var status = self.boomBustStatus(proj, actual, hasPlayed, muScore);
      var score = hasPlayed ? actual : proj;
      var scoreCls = hasPlayed ? self.scoreColor(proj, actual, true) : "text-gray-200";

      var valObj = self.getPlayerValue(pid);
      var valueScore = valObj ? valObj.score : null;

      var posRank = self.positionRank(pid);
      var ppgRank = self.getPlayerPpgRank(pid);
      var deltaRank = self.getPlayerDeltaRank(pid);
      var seasonTotal = (self.data.seasonTotals && (self.data.seasonTotals[pid] || self.data.seasonTotals[String(pid)])) || 0;
      var effMetrics = self.getPlayerEfficiencyMetrics(pid, p);

      return {
        pid: pid,
        slot: pk.slot,
        isStarter: (pk && pk.isStarter !== false),
        player: p,
        disp: disp,
        proj: proj,
        act: actual,
        hasPlayed: hasPlayed,
        status: status,
        scoreToShow: score,
        scoreCls: scoreCls,
        opp: opp,
        enhancedMU: enh,
        valueScore: valueScore,
        muScore: muScore,
        fit: data.fitById[pid] || 0,
        posRank: posRank,
        ppgRank: ppgRank,
        deltaRank: deltaRank,
        seasonTotal: seasonTotal,
        effMetrics: effMetrics,
        isOut: isInjuredOut(p)
      };
    };

    var renderCard = function(item, showSlot) {
      return self.buildPlayerCardElement(item, { showSlot: showSlot });
    };

    // Render grouped starters in consistent order
    positionOrder.forEach(function(slotKey) {
      var arr = startersBySlot[String(slotKey).toUpperCase()];
      if (!arr || !arr.length) return;

      var section = document.createElement("div");
      section.className = "mb-4";

      var header = document.createElement("div");
      header.className = "text-[11px] uppercase tracking-wider text-gray-400 font-bold mb-2";
      header.textContent = positionLabels[slotKey] || slotKey;
      section.appendChild(header);

      var grid = document.createElement("div");
      grid.className = "ui2k-card-grid";
      arr.map(makeItem).forEach(function(item) { grid.appendChild(renderCard(item, false)); });

      section.appendChild(grid);
      list.appendChild(section);
    });

    // If any slots are not in our known order, render them at the end
    Object.keys(startersBySlot).forEach(function(slotKey) {
      if (positionOrder.indexOf(slotKey) >= 0) return;
      var arr = startersBySlot[slotKey];
      if (!arr || !arr.length) return;

      var section = document.createElement("div");
      section.className = "mb-4";

      var header = document.createElement("div");
      header.className = "text-[11px] uppercase tracking-wider text-gray-400 font-bold mb-2";
      header.textContent = positionLabels[slotKey] || slotKey;
      section.appendChild(header);

      var grid = document.createElement("div");
      grid.className = "ui2k-card-grid";
      arr.map(makeItem).forEach(function(item) { grid.appendChild(renderCard(item, false)); });

      section.appendChild(grid);
      list.appendChild(section);
    });
    // Bench / remaining players (show the full roster: starters + bench)
    if (data.benchPids && data.benchPids.length) {
      var benchSection = document.createElement("div");
      benchSection.className = "mt-6";
      var bh = document.createElement("div");
      bh.className = "text-sm font-semibold text-gray-300 mb-2";
      bh.textContent = "Bench";
      benchSection.appendChild(bh);

      var bgrid = document.createElement("div");
      bgrid.className = "ui2k-card-grid";
      data.benchPids
        .map(function(pid){ return { pid: pid, slot: "BN", isStarter: false }; })
        .map(makeItem)
        .forEach(function(item) { bgrid.appendChild(renderCard(item, true)); });

      benchSection.appendChild(bgrid);
      list.appendChild(benchSection);
    }

  },

  renderHistoryBestComparison: function() {
    var self = this;
    var box = this.dom.historyCompareBox;
    if (!box) return;
    box.innerHTML = "";

    var data = this.computeHistoryBestLineupData();
    if (!data || !data.picks || !data.picks.length) {
      box.innerHTML = '<div class="text-gray-500">No comparison data available.</div>';
      if (this.dom.historyCompareSubtitle) this.dom.historyCompareSubtitle.textContent = "Best Lineup";
      return;
    }

    if (this.dom.historyCompareSubtitle) {
      this.dom.historyCompareSubtitle.textContent = "Best Lineup (B)";
    }

        // Totals: compare the lineup you actually used vs the computed optimal lineup for this week
    var anyPlayed = false;
    try {
      anyPlayed = !!(data && data.picks && data.picks.length && data.hasPlayedById && data.picks.some(function(pk){ return data.hasPlayedById[String(pk.pid)]; }));
    } catch (e) { anyPlayed = false; }
    var bestActText = anyPlayed ? data.bestActTotal.toFixed(2) : "‚Äî";

    var usedAnyPlayed = false;
    try {
      usedAnyPlayed = !!(data && data.actualStarters && data.actualStarters.length && data.hasPlayedById && data.actualStarters.some(function(pid){ return data.hasPlayedById[String(pid)]; }));
    } catch (e) { usedAnyPlayed = false; }
    var usedActText = usedAnyPlayed ? data.actualActTotal.toFixed(2) : "‚Äî";

    var deltaAct = (anyPlayed && usedAnyPlayed) ? Math.round((data.bestActTotal - data.actualActTotal) * 100) / 100 : null;
var fmtPid = function(pid) {
      var p = self.data.playersById[String(pid)] || {};
      var d = self.playerDisplay(p);
      return self.escapeHtml(d.name || ("#" + pid));
    };

    var fmtLine = function(pid) {
      var proj = data.projById[String(pid)] || 0;
      var mu = data.muById[String(pid)] || 50;
      var fit = data.fitById[String(pid)] || 0;
      return '<div class="flex items-center justify-between gap-3 bg-gray-950 border border-gray-800 rounded-xl p-3">' +
        '<div class="min-w-0">' +
          '<div class="font-bold text-white truncate">' + fmtPid(pid) + '</div>' +
          '<div class="text-[10px] text-gray-500 font-mono">MU ' + Math.round(mu) + ' ‚Ä¢ FIT ' + Math.round(fit) + '</div>' +
        '</div>' +
        '<div class="text-right">' +
          '<div class="text-sm font-black text-white">' + proj.toFixed(2) + '</div>' +
          '<div class="text-[10px] text-gray-500 font-mono">Proj</div>' +
        '</div>' +
      '</div>';
    };

    box.innerHTML =
      '<div class="bg-gray-950 border border-gray-800 rounded-2xl p-5">' +
        '<div class="flex items-start justify-between gap-4">' +
          '<div>' +
            '<div class="text-sm font-bold text-white">Totals (weighted picks)</div>' +
            '<div class="text-xs text-gray-500">Shows optimal lineup actual score vs the lineup you actually used (projected + actual), plus the actual-score delta.</div>' +
          '</div>' +
          '<div class="text-right">' +
            '<div class="text-2xl font-black text-white">' + bestActText + '</div>' +
            '<div class="text-xs text-gray-500 font-mono">Optimal Actual Score</div>' +
          '</div>' +
        '</div>' +
        '<div class="grid grid-cols-4 gap-3 mt-4">' +
          '<div class="bg-gray-900/50 border border-gray-800 rounded-xl p-3">' +
            '<div class="text-[10px] text-gray-500 font-mono">Avg MU</div>' +
            '<div class="text-lg font-black text-accent">' + data.bestMuAvg.toFixed(1) + '</div>' +
          '</div>' +
          '<div class="bg-gray-900/50 border border-gray-800 rounded-xl p-3">' +
            '<div class="text-[10px] text-gray-500 font-mono">Used Proj Score</div>' +
            '<div class="text-lg font-black text-gray-200">' + data.actualProjTotal.toFixed(2) + '</div>' +
          '</div>' +
          '<div class="bg-gray-900/50 border border-gray-800 rounded-xl p-3">' +
            '<div class="text-[10px] text-gray-500 font-mono">Used Actual Score</div>' +
            '<div class="text-lg font-black text-gray-200">' + usedActText + '</div>' +
          '</div>' +
          '<div class="bg-gray-900/50 border border-gray-800 rounded-xl p-3">' +
            '<div class="text-[10px] text-gray-500 font-mono">Delta (Opt ‚àí Used)</div>' +
            '<div class="text-lg font-black ' + (deltaAct === null ? 'text-gray-500' : (deltaAct >= 0 ? 'text-accent' : 'text-red-400')) + '">' +
              (deltaAct === null ? '‚Äî' : ((deltaAct >= 0 ? '+' : '') + deltaAct.toFixed(2))) +
            '</div>' +
          '</div>' +
        '</div>' +
      '</div>' +
      '<div class="mt-4 grid grid-cols-1 gap-4">' +
        '<div class="bg-gray-950 border border-gray-800 rounded-2xl p-5">' +
          '<div class="text-sm font-bold text-white mb-3">Start</div>' +
          (data.shouldStart && data.shouldStart.length ? data.shouldStart.map(fmtLine).join('') : '<div class="text-gray-500 text-sm">No changes (best lineup matches starters).</div>') +
        '</div>' +
        '<div class="bg-gray-950 border border-gray-800 rounded-2xl p-5">' +
          '<div class="text-sm font-bold text-white mb-3">Sit</div>' +
          (data.shouldSit && data.shouldSit.length ? data.shouldSit.map(fmtLine).join('') : '<div class="text-gray-500 text-sm">None.</div>') +
        '</div>' +
      '</div>';
  },


  renderInsightsCharts: function() {
    var self = this;
    var metrics = this.data.leagueMetrics;
    if (!metrics || !metrics.teams) return;

    var teamsArr = Object.values(metrics.teams);
    teamsArr.sort(function(a, b) { return b.pf - a.pf; });

    // Points For Bar Chart
    var pfCtx = this.dom.insightsPFChart;
    if (pfCtx) {
      var pfLabels = teamsArr.map(function(t) { return t.name.substring(0, 12); });
      var pfData = teamsArr.map(function(t) { return t.pf; });
      
      
      var pfColors = teamsArr.map(function(t) { return self.rosterColor(t.roster_id); });
      var pfColorsBg = pfColors.map(function(c) { return c + '99'; });
      if (this.ui.pfChart) this.ui.pfChart.destroy();
      this.ui.pfChart = new Chart(pfCtx, {
        type: 'bar',
        data: {
          labels: pfLabels,
          datasets: [{
            label: 'Points For',
            data: pfData,
            backgroundColor: pfColorsBg,
            borderColor: pfColors,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          scales: {
            y: { beginAtZero: false, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148,163,184,0.1)' } },
            x: { ticks: { color: '#94a3b8', maxRotation: 45 }, grid: { display: false } }
          }
        }
      });
    }

    // Luck vs Expected Wins Scatter Chart
    var luckCtx = this.dom.insightsLuckChart;
    if (luckCtx) {
      var scatterData = teamsArr.map(function(t) {
        return { x: t.expW, y: t.luck, label: t.name };
      });
      
      if (this.ui.luckChart) this.ui.luckChart.destroy();
      this.ui.luckChart = new Chart(luckCtx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Teams',
            data: scatterData,
            backgroundColor: scatterData.map(function(d) {
              return d.y >= 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)';
            }),
            pointRadius: 8,
            pointHoverRadius: 10
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function(ctx) {
                  var d = ctx.raw;
                  return d.label + ': xW=' + d.x.toFixed(1) + ', Luck=' + (d.y >= 0 ? '+' : '') + d.y.toFixed(2);
                }
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Expected Wins', color: '#94a3b8' }, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148,163,184,0.1)' } },
            y: { title: { display: true, text: 'Luck Rating', color: '#94a3b8' }, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148,163,184,0.1)' } }
          }
        }
      });
    }

    // Luckiest/Unluckiest/Most Consistent lists
    var luckySorted = teamsArr.slice().sort(function(a, b) { return b.luck - a.luck; });
    var consistentSorted = teamsArr.slice().sort(function(a, b) { return a.stddev - b.stddev; });

    var luckyContainer = this.dom.insightsLucky;
    if (luckyContainer) {
      luckyContainer.innerHTML = '';
      luckySorted.slice(0, 5).forEach(function(t, i) {
        var item = document.createElement('div');
        item.className = 'flex items-center justify-between p-2 bg-gray-950 rounded-lg';
        item.innerHTML = '<span class="text-white text-sm">' + (i + 1) + '. ' + t.name + '</span><span class="text-sleeper-boom font-mono text-sm">+' + t.luck.toFixed(2) + '</span>';
        luckyContainer.appendChild(item);
      });
    }

    var unluckyContainer = this.dom.insightsUnlucky;
    if (unluckyContainer) {
      unluckyContainer.innerHTML = '';
      luckySorted.slice(-5).reverse().forEach(function(t, i) {
        var item = document.createElement('div');
        item.className = 'flex items-center justify-between p-2 bg-gray-950 rounded-lg';
        item.innerHTML = '<span class="text-white text-sm">' + (i + 1) + '. ' + t.name + '</span><span class="text-red-400 font-mono text-sm">' + t.luck.toFixed(2) + '</span>';
        unluckyContainer.appendChild(item);
      });
    }

    var consistentContainer = this.dom.insightsConsistent;
    if (consistentContainer) {
      consistentContainer.innerHTML = '';
      consistentSorted.slice(0, 5).forEach(function(t, i) {
        var item = document.createElement('div');
        item.className = 'flex items-center justify-between p-2 bg-gray-950 rounded-lg';
        item.innerHTML = '<span class="text-white text-sm">' + (i + 1) + '. ' + t.name + '</span><span class="text-accent font-mono text-sm">¬±' + t.stddev.toFixed(1) + '</span>';
        consistentContainer.appendChild(item);
      });
    }

    // Weekly Scoring Trends Line Chart
    this.renderTrendsChart();
  },

  renderTrendsChart: function() {
    var self = this;
    var trendsCtx = this.dom.insightsTrendsChart;
    if (!trendsCtx) return;

    var cw = this.getMaxWeek();
    var labels = [];
    for (var w = 1; w <= cw; w++) labels.push('W' + w);

    var datasets = [];

    this.data.rosters.forEach(function(roster, idx) {
      var u = self.data.usersById[roster.owner_id];
      var name = (u && u.display_name) || ('Team ' + roster.roster_id);
      var data = [];

      var c = self.rosterColor(roster.roster_id);

      for (var w = 1; w <= cw; w++) {
        var weekMatchups = self.data.weekMatchups[String(w)] || [];
        var match = weekMatchups.find(function(m) { return m && m.roster_id === roster.roster_id; });
        data.push(match ? (match.points || 0) : null);
      }

      datasets.push({
        label: name,
        data: data,
        borderColor: c,
        backgroundColor: c + '20',
        tension: 0.3,
        pointRadius: 3,
        borderWidth: 2
      });
    });

    if (this.ui.trendsChart) this.ui.trendsChart.destroy();
    this.ui.trendsChart = new Chart(trendsCtx, {
      type: 'line',
      data: { labels: labels, datasets: datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { position: 'bottom', labels: { color: '#94a3b8', usePointStyle: true, padding: 10, boxWidth: 8 } }
        },
        scales: {
          x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148,163,184,0.1)' } },
          y: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148,163,184,0.1)' }, beginAtZero: false }
        }
      }
    });
  },

  closePlayerModal: function() {
    if (this.dom.playerModal) {
      this.dom.playerModal.classList.add("hidden");
      this.dom.playerModal.classList.remove("flex");
    }
    if (this.ui.chart) {
      this.ui.chart.destroy();
      this.ui.chart = null;
    }
  }
};


  // ------------------------------
  // Settings (localStorage-backed)
  // ------------------------------
  APP._settingsKey = "sleeper_app_settings_v3_3";

  APP.loadAppSettings = function() {
    try {
      var raw = localStorage.getItem(APP._settingsKey);
      if (!raw) return;
      var obj = JSON.parse(raw);
      if (!obj || typeof obj !== "object") return;
      if (typeof obj.autoSetup === "boolean") APP.cfg.autoSetup = obj.autoSetup;
      if (obj.manual && typeof obj.manual === "object") {
        APP.cfg.manual = APP.cfg.manual || {};
        for (var k in obj.manual) APP.cfg.manual[k] = obj.manual[k];
      }
      if (obj.weekSelectionMode) APP.cfg.weekSelectionMode = String(obj.weekSelectionMode);
      if (obj.selectedSeasonChoice) APP.cfg.selectedSeasonChoice = String(obj.selectedSeasonChoice);
      APP.cfg.seasonType = "regular";
      if (APP.cfg.manual) APP.cfg.manual.seasonType = "regular";
    } catch(e) {}
  };

  APP.saveAppSettings = function() {
    try {
      var out = {
        autoSetup: !!APP.cfg.autoSetup,
        manual: APP.cfg.manual || {},
        selectedSeasonChoice: String(APP.cfg.selectedSeasonChoice || ""),
        weekSelectionMode: String(APP.cfg.weekSelectionMode || "max_week"),
        seasonType: "regular"
      };
      localStorage.setItem(APP._settingsKey, JSON.stringify(out));
    } catch(e) {}
  };

  APP.resolveLeagueId = function() {
    var man = (APP.cfg && APP.cfg.manual) ? APP.cfg.manual : {};
    var override = (man && man.leagueId) ? String(man.leagueId).trim() : "";
    if (override) return override;
    var yr = String(APP.cfg.selectedSeasonChoice || "");
    if (APP.cfg.seasonLeagues && APP.cfg.seasonLeagues[yr]) return APP.cfg.seasonLeagues[yr];
    return APP.cfg.leagueId;
  };

  APP.getLastScoredWeek = function(league) {
    try {
      var s = (league && league.settings) ? league.settings : {};
      // Sleeper stores the most recently scored week in settings.last_scored_leg (aka "leg")
      var v = Number(s.last_scored_leg || s.leg || 0);
      if (!isFinite(v) || v < 1) return 0;
      return v;
    } catch(e) {
      return 0;
    }
  };

  APP.renderSettingsView = function() {
    // Refresh DOM refs (cacheDom may not include new fields in older builds)
    APP.dom = APP.dom || {};
    var d = APP.dom;
    if (!d.viewSettings) d.viewSettings = document.getElementById("viewSettings");
    if (!d.btnTabSettings) d.btnTabSettings = document.getElementById("btnTabSettings");
    if (!d.settingsAutoSetup) d.settingsAutoSetup = document.getElementById("settingsAutoSetup");
    if (!d.settingsLeagueId) d.settingsLeagueId = document.getElementById("settingsLeagueId");
    if (!d.settingsSeason) d.settingsSeason = document.getElementById("settingsSeason");
    if (!d.settingsSeasonType) d.settingsSeasonType = document.getElementById("settingsSeasonType");
    if (!d.settingsWeekMode) d.settingsWeekMode = document.getElementById("settingsWeekMode");
    if (!d.settingsCurrentWeek) d.settingsCurrentWeek = document.getElementById("settingsCurrentWeek");
    if (!d.settingsMaxWeek) d.settingsMaxWeek = document.getElementById("settingsMaxWeek");
    if (!d.settingsApply) d.settingsApply = document.getElementById("settingsApply");
    if (!d.settingsReset) d.settingsReset = document.getElementById("settingsReset");
    if (!d.settingsEffective) d.settingsEffective = document.getElementById("settingsEffective");

    if (!d.viewSettings) return;

    // Populate season dropdown (union of known years + current selection)
    try {
      if (d.settingsSeason && d.settingsSeason.options.length === 0) {
        var years = [];
        for (var y in (APP.cfg.seasonLeagues || {})) years.push(String(y));
        years.sort();
        var manualSeason = (APP.cfg.manual && APP.cfg.manual.season) ? String(APP.cfg.manual.season) : "";
        if (manualSeason && years.indexOf(manualSeason) === -1) years.push(manualSeason);
        years.sort();
        for (var i=0;i<years.length;i++) {
          var opt = document.createElement("option");
          opt.value = years[i];
          opt.textContent = years[i];
          d.settingsSeason.appendChild(opt);
        }
      }
    } catch(e) {}

    try { if (d.settingsAutoSetup) d.settingsAutoSetup.checked = (APP.cfg.autoSetup !== false); } catch(e) {}
    try { if (d.settingsLeagueId) d.settingsLeagueId.value = (APP.cfg.manual && APP.cfg.manual.leagueId) ? String(APP.cfg.manual.leagueId) : ""; } catch(e) {}
    try {
      var seasonVal = (APP.cfg.manual && APP.cfg.manual.season) ? String(APP.cfg.manual.season) : String(APP.cfg.selectedSeasonChoice || "");
      if (d.settingsSeason) d.settingsSeason.value = seasonVal;
    } catch(e) {}
    try { if (d.settingsSeasonType) d.settingsSeasonType.value = "regular"; } catch(e) {}
    try { if (d.settingsWeekMode) d.settingsWeekMode.value = String(APP.cfg.weekSelectionMode || "max_week"); } catch(e) {}
    try { if (d.settingsCurrentWeek) d.settingsCurrentWeek.value = Number((APP.cfg.manual && APP.cfg.manual.currentWeek) || (APP.ui && APP.ui.selectedWeek) || 1); } catch(e) {}
    try { if (d.settingsMaxWeek) d.settingsMaxWeek.value = Number((APP.cfg.manual && APP.cfg.manual.maxWeek) || (APP.data && APP.data.maxWeek) || 18); } catch(e) {}

    // Effective config preview
    try {
      var eff = {
        autoSetup: (APP.cfg.autoSetup !== false),
        leagueId: APP.resolveLeagueId(),
        selectedSeasonChoice: APP.cfg.selectedSeasonChoice,
        seasonType: APP.cfg.seasonType,
        weekSelectionMode: APP.cfg.weekSelectionMode || "max_week",
        selectedWeek: (APP.ui && APP.ui.selectedWeek) ? APP.ui.selectedWeek : null,
        maxWeek: (APP.data && APP.data.maxWeek) ? APP.data.maxWeek : null,
        manual: APP.cfg.manual || {}
      };
      if (d.settingsEffective) d.settingsEffective.textContent = JSON.stringify(eff, null, 2);
    } catch(e) {}

    // Wire buttons once
    if (!APP._settingsWired) {
      APP._settingsWired = true;

      if (d.settingsApply) d.settingsApply.onclick = function() {
        APP.cfg.manual = APP.cfg.manual || {};
        APP.cfg.autoSetup = !!(d.settingsAutoSetup && d.settingsAutoSetup.checked);

        var lid = (d.settingsLeagueId && d.settingsLeagueId.value) ? String(d.settingsLeagueId.value).trim() : "";
        APP.cfg.manual.leagueId = lid;

        var yr = (d.settingsSeason && d.settingsSeason.value) ? String(d.settingsSeason.value).trim() : "";
        if (yr) {
          APP.cfg.manual.season = yr;
          APP.cfg.selectedSeasonChoice = yr;
          try { localStorage.setItem("sleeper_app_season_choice", yr); } catch(e) {}
        }

        var st = "regular";
        APP.cfg.manual.seasonType = st;
        APP.cfg.seasonType = st;

        var wkMode = (d.settingsWeekMode && d.settingsWeekMode.value) ? String(d.settingsWeekMode.value) : "max_week";
        APP.cfg.weekSelectionMode = wkMode;

        var cw = Number(d.settingsCurrentWeek && d.settingsCurrentWeek.value);
        var mw = Number(d.settingsMaxWeek && d.settingsMaxWeek.value);
        if (isFinite(cw) && cw > 0) APP.cfg.manual.currentWeek = cw;
        if (isFinite(mw) && mw > 0) APP.cfg.manual.maxWeek = mw;

        // Resolve leagueId now
        APP.cfg.leagueId = APP.resolveLeagueId();

        try { APP.saveAppSettings(); } catch(e) {}

        // Use the built-in switchSeason when possible, otherwise do a hard reload
        if (APP.cfg.seasonLeagues && APP.cfg.seasonLeagues[APP.cfg.selectedSeasonChoice]) {
          APP.switchSeason(APP.cfg.selectedSeasonChoice);
        } else {
          // minimal reload
          try { APP.data = APP.data || {}; APP.data.weekCache = {}; APP.data.statsByWeek = {}; APP.data.projByWeek = {}; } catch(e) {}
          APP.init();
        }
      };

      if (d.settingsReset) d.settingsReset.onclick = function() {
        try { localStorage.removeItem(APP._settingsKey); } catch(e) {}
        try {
          APP.cfg.autoSetup = true;
          APP.cfg.manual = { leagueId: "", season: "", seasonType: "regular", currentWeek: 1, maxWeek: 18 };
          APP.cfg.weekSelectionMode = "max_week";
          APP.saveAppSettings();
        } catch(e) {}
        try { APP.data = APP.data || {}; APP.data.weekCache = {}; APP.data.statsByWeek = {}; APP.data.projByWeek = {}; } catch(e) {}
        APP.init();
      };
    }
  };


document.addEventListener("DOMContentLoaded", function() {
  APP.init();
});
</script>
</body>
</html>
